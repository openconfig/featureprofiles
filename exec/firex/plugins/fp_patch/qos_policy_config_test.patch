diff --git a/feature/experimental/qos/ate_tests/qos_policy_config_test/qos_policy_config_test.go b/feature/experimental/qos/ate_tests/qos_policy_config_test/qos_policy_config_test.go
index e65bd45..54afaad 100644
--- a/feature/experimental/qos/ate_tests/qos_policy_config_test/qos_policy_config_test.go
+++ b/feature/experimental/qos/ate_tests/qos_policy_config_test/qos_policy_config_test.go
@@ -15,7 +15,7 @@
 package qos_policy_config_test
 
 import (
-	"math"
+	//"math"
 	"sort"
 	"testing"
 
@@ -24,6 +24,7 @@ import (
 	"github.com/openconfig/ondatra"
 	"github.com/openconfig/ondatra/gnmi"
 	"github.com/openconfig/ondatra/gnmi/oc"
+	"github.com/openconfig/ygot/ygot"
 )
 
 func TestMain(m *testing.M) {
@@ -85,6 +86,12 @@ func TestQoSClassifierConfig(t *testing.T) {
 	dut := ondatra.DUT(t, "dut")
 	d := &oc.Root{}
 	q := d.GetOrCreateQos()
+	queues := []string{"tc7", "tc6", "tc5", "tc4", "tc3", "tc2", "tc1"}
+	for _, queue := range queues {
+		q1 := q.GetOrCreateQueue(queue)
+		q1.Name = ygot.String(queue)
+		gnmi.Update(t, dut, gnmi.OC().Qos().Queue(*q1.Name).Config(), q1)
+	}
 
 	cases := []struct {
 		desc         string
@@ -95,101 +102,101 @@ func TestQoSClassifierConfig(t *testing.T) {
 		dscpSet      []uint8
 	}{{
 		desc:         "classifier_ipv4_be1",
-		name:         "dscp_based_classifier_ipv4",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV4,
 		termID:       "0",
-		targetGrpoup: "target-group-BE1",
+		targetGrpoup: "tc1",
 		dscpSet:      []uint8{0, 1, 2, 3},
 	}, {
 		desc:         "classifier_ipv4_be0",
-		name:         "dscp_based_classifier_ipv4",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV4,
 		termID:       "1",
-		targetGrpoup: "target-group-BE0",
+		targetGrpoup: "tc2",
 		dscpSet:      []uint8{4, 5, 6, 7},
 	}, {
 		desc:         "classifier_ipv4_af1",
-		name:         "dscp_based_classifier_ipv4",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV4,
 		termID:       "2",
-		targetGrpoup: "target-group-AF1",
+		targetGrpoup: "tc3",
 		dscpSet:      []uint8{8, 9, 10, 11},
 	}, {
 		desc:         "classifier_ipv4_af2",
-		name:         "dscp_based_classifier_ipv4",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV4,
 		termID:       "3",
-		targetGrpoup: "target-group-AF2",
+		targetGrpoup: "tc4",
 		dscpSet:      []uint8{16, 17, 18, 19},
 	}, {
 		desc:         "classifier_ipv4_af3",
-		name:         "dscp_based_classifier_ipv4",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV4,
 		termID:       "4",
-		targetGrpoup: "target-group-AF3",
+		targetGrpoup: "tc5",
 		dscpSet:      []uint8{24, 25, 26, 27},
 	}, {
 		desc:         "classifier_ipv4_af4",
-		name:         "dscp_based_classifier_ipv4",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV4,
 		termID:       "5",
-		targetGrpoup: "target-group-AF4",
+		targetGrpoup: "tc6",
 		dscpSet:      []uint8{32, 33, 34, 35},
 	}, {
 		desc:         "classifier_ipv4_nc1",
-		name:         "dscp_based_classifier_ipv4",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV4,
 		termID:       "6",
-		targetGrpoup: "target-group-NC1",
+		targetGrpoup: "tc7",
 		dscpSet:      []uint8{48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59},
 	}, {
 		desc:         "classifier_ipv6_be1",
-		name:         "dscp_based_classifier_ipv6",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV6,
-		termID:       "0",
-		targetGrpoup: "target-group-BE1",
+		termID:       "10",
+		targetGrpoup: "tc1",
 		dscpSet:      []uint8{0, 1, 2, 3},
 	}, {
 		desc:         "classifier_ipv6_be0",
-		name:         "dscp_based_classifier_ipv6",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV6,
-		termID:       "1",
-		targetGrpoup: "target-group-BE0",
+		termID:       "11",
+		targetGrpoup: "tc2",
 		dscpSet:      []uint8{4, 5, 6, 7},
 	}, {
 		desc:         "classifier_ipv6_af1",
-		name:         "dscp_based_classifier_ipv6",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV6,
-		termID:       "2",
-		targetGrpoup: "target-group-AF1",
+		termID:       "12",
+		targetGrpoup: "tc3",
 		dscpSet:      []uint8{8, 9, 10, 11},
 	}, {
 		desc:         "classifier_ipv6_af2",
-		name:         "dscp_based_classifier_ipv6",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV6,
-		termID:       "3",
-		targetGrpoup: "target-group-AF2",
+		termID:       "13",
+		targetGrpoup: "tc4",
 		dscpSet:      []uint8{16, 17, 18, 19},
 	}, {
 		desc:         "classifier_ipv6_af3",
-		name:         "dscp_based_classifier_ipv6",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV6,
-		termID:       "4",
-		targetGrpoup: "target-group-AF3",
+		termID:       "14",
+		targetGrpoup: "tc5",
 		dscpSet:      []uint8{24, 25, 26, 27},
 	}, {
 		desc:         "classifier_ipv6_af4",
-		name:         "dscp_based_classifier_ipv6",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV6,
-		termID:       "5",
-		targetGrpoup: "target-group-AF4",
+		termID:       "15",
+		targetGrpoup: "tc6",
 		dscpSet:      []uint8{32, 33, 34, 35},
 	}, {
 		desc:         "classifier_ipv6_nc1",
-		name:         "dscp_based_classifier_ipv6",
+		name:         "dscp_based_classifier",
 		classType:    oc.Qos_Classifier_Type_IPV6,
-		termID:       "6",
-		targetGrpoup: "target-group-NC1",
+		termID:       "16",
+		targetGrpoup: "tc7",
 		dscpSet:      []uint8{48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59},
 	}}
 
@@ -207,17 +214,27 @@ func TestQoSClassifierConfig(t *testing.T) {
 			term.SetId(tc.termID)
 			action := term.GetOrCreateActions()
 			action.SetTargetGroup(tc.targetGrpoup)
+
 			condition := term.GetOrCreateConditions()
-			if tc.name == "dscp_based_classifier_ipv4" {
+			if tc.classType == oc.Qos_Classifier_Type_IPV4 {
 				condition.GetOrCreateIpv4().SetDscpSet(tc.dscpSet)
-			} else if tc.name == "dscp_based_classifier_ipv6" {
+			} else {
 				condition.GetOrCreateIpv6().SetDscpSet(tc.dscpSet)
+
 			}
-			gnmi.Replace(t, dut, gnmi.OC().Qos().Config(), q)
+			fwdgroups := q.GetOrCreateForwardingGroup(tc.targetGrpoup)
+			fwdgroups.Name = ygot.String(tc.targetGrpoup)
+			fwdgroups.OutputQueue = ygot.String(tc.targetGrpoup)
+			//gnmi.Update(t, dut, gnmi.OC().Qos().Config(), q)
 		})
 
+	}
+	gnmi.Update(t, dut, gnmi.OC().Qos().Config(), q)
+	t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
+	for _, tc := range cases {
+
 		// TODO: Remove the following t.Skipf() after the config verification code has been tested.
-		t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
+		//t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
 
 		// Verify the Classifier is applied by checking the telemetry path state values.
 		classifier := gnmi.OC().Qos().Classifier(tc.name)
@@ -248,11 +265,11 @@ func TestQoSClassifierConfig(t *testing.T) {
 			return out
 		})
 
-		if tc.name == "dscp_based_classifier_ipv4" {
+		if tc.classType == oc.Qos_Classifier_Type_IPV4 {
 			if equal := cmp.Equal(condition.Ipv4().DscpSet().State(), tc.dscpSet, trans); !equal {
 				t.Errorf("condition.Ipv4().DscpSet().State(): got %v, want %v", condition.Ipv4().DscpSet().State(), tc.dscpSet)
 			}
-		} else if tc.name == "dscp_based_classifier_ipv6" {
+		} else if tc.classType == oc.Qos_Classifier_Type_IPV6 {
 			if equal := cmp.Equal(condition.Ipv6().DscpSet().State(), tc.dscpSet, trans); !equal {
 				t.Errorf("condition.Ipv4().DscpSet().State(): got %v, want %v", condition.Ipv6().DscpSet().State(), tc.dscpSet)
 			}
@@ -264,109 +281,50 @@ func TestQoSInputIntfClassifierConfig(t *testing.T) {
 	dut := ondatra.DUT(t, "dut")
 	dp := dut.Port(t, "port1")
 
-	cases := []struct {
-		desc                string
-		inputClassifierType oc.E_Input_Classifier_Type
-		classifier          string
-	}{{
-		desc:                "Input Classifier Type IPV4",
-		inputClassifierType: oc.Input_Classifier_Type_IPV4,
-		classifier:          "dscp_based_classifier_ipv4",
-	}, {
-		desc:                "Input Classifier Type IPV6",
-		inputClassifierType: oc.Input_Classifier_Type_IPV6,
-		classifier:          "dscp_based_classifier_ipv6",
-	}}
+	// cases := []struct {
+	// 	desc                string
+	// 	inputClassifierType oc.E_Input_Classifier_Type
+	// 	classifier          string
+	// }{{
+	// 	desc:                "Input Classifier Type IPV4",
+	// 	inputClassifierType: oc.Input_Classifier_Type_IPV4,
+	// 	classifier:          "dscp_based_classifier_ipv4",
+	// }, {
+	// 	desc:                "Input Classifier Type IPV6",
+	// 	inputClassifierType: oc.Input_Classifier_Type_IPV6,
+	// 	classifier:          "dscp_based_classifier_ipv4",
+	// },
+	// 	{
+	// 		desc:                "Input Classifier Type MPLS",
+	// 		inputClassifierType: oc.Input_Classifier_Type_MPLS,
+	// 		classifier:          "dscp_based_classifier_ipv4",
+	// 	},
+	// }
 
 	d := &oc.Root{}
 	q := d.GetOrCreateQos()
 	i := q.GetOrCreateInterface(dp.Name())
-	i.SetInterfaceId(dp.Name())
-
-	t.Logf("qos input classifier config cases: %v", cases)
-	for _, tc := range cases {
-		t.Run(tc.desc, func(t *testing.T) {
-			c := i.GetOrCreateInput().GetOrCreateClassifier(tc.inputClassifierType)
-			c.SetType(tc.inputClassifierType)
-			c.SetName(tc.classifier)
-			gnmi.Replace(t, dut, gnmi.OC().Qos().Config(), q)
-		})
-
-		// TODO: Remove the following t.Skipf() after the config verification code has been tested.
-		t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
-
-		// Verify the Classifier is applied on interface by checking the telemetry path state values.
-		classifier := gnmi.OC().Qos().Interface(dp.Name()).Input().Classifier(tc.inputClassifierType)
-		if got, want := gnmi.Get(t, dut, classifier.Name().State()), tc.classifier; got != want {
-			t.Errorf("classifier.Name().State(): got %v, want %v", got, want)
-		}
-		if got, want := gnmi.Get(t, dut, classifier.Type().State()), tc.inputClassifierType; got != want {
-			t.Errorf("classifier.Name().State(): got %v, want %v", got, want)
-		}
+	i.InterfaceId = ygot.String(dp.Name())
+	c := i.GetOrCreateInput()
+
+	// c.SetType(tc.inputClassifierType)
+	// c.SetName(tc.classifier)
+	c.GetOrCreateClassifier(oc.Input_Classifier_Type_IPV4).Name = ygot.String("dscp_based_classifier")
+	c.GetOrCreateClassifier(oc.Input_Classifier_Type_IPV6).Name = ygot.String("dscp_based_classifier")
+	c.GetOrCreateClassifier(oc.Input_Classifier_Type_MPLS).Name = ygot.String("dscp_based_classifier")
+
+	gnmi.Update(t, dut, gnmi.OC().Qos().Config(), q)
+	// inputIntf := gnmi.GetAll(t, dut, gnmi.OC().Qos().Interface(dp.Name()).Input().ClassifierAny().Name().Config())
+	// t.Logf("qos input interface from telmetry: %v", inputIntf)
+	//t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
+
+	// Verify the Classifier is applied on interface by checking the telemetry path state values.
+	classifier := gnmi.OC().Qos().Interface(dp.Name()).Input().Classifier(oc.Input_Classifier_Type_IPV4)
+	if got, want := gnmi.Get(t, dut, classifier.Name().State()), "dscp_based_classifier"; got != want {
+		t.Errorf("classifier.Name().State(): got %v, want %v", got, want)
 	}
-}
-
-func TestQoSForwadingGroupsConfig(t *testing.T) {
-	dut := ondatra.DUT(t, "dut")
-	d := &oc.Root{}
-	q := d.GetOrCreateQos()
-
-	cases := []struct {
-		desc         string
-		queueName    string
-		targetGrpoup string
-	}{{
-		desc:         "forwarding-group-BE1",
-		queueName:    "BE1",
-		targetGrpoup: "target-group-BE1",
-	}, {
-		desc:         "forwarding-group-BE0",
-		queueName:    "BE0",
-		targetGrpoup: "target-group-BE0",
-	}, {
-		desc:         "forwarding-group-AF1",
-		queueName:    "AF1",
-		targetGrpoup: "target-group-AF1",
-	}, {
-		desc:         "forwarding-group-AF2",
-		queueName:    "AF2",
-		targetGrpoup: "target-group-AF2",
-	}, {
-		desc:         "forwarding-group-AF3",
-		queueName:    "AF3",
-		targetGrpoup: "target-group-AF3",
-	}, {
-		desc:         "forwarding-group-AF4",
-		queueName:    "AF4",
-		targetGrpoup: "target-group-AF4",
-	}, {
-		desc:         "forwarding-group-NC1",
-		queueName:    "NC1",
-		targetGrpoup: "target-group-NC1",
-	}}
-
-	t.Logf("qos forwarding groups config cases: %v", cases)
-	for _, tc := range cases {
-		t.Run(tc.desc, func(t *testing.T) {
-			fwdGroup := q.GetOrCreateForwardingGroup(tc.targetGrpoup)
-			fwdGroup.SetName(tc.targetGrpoup)
-			fwdGroup.SetOutputQueue(tc.queueName)
-			queue := q.GetOrCreateQueue(tc.queueName)
-			queue.SetName(tc.queueName)
-			gnmi.Replace(t, dut, gnmi.OC().Qos().Config(), q)
-		})
-
-		// TODO: Remove the following t.Skipf() after the config verification code has been tested.
-		t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
-
-		// Verify the ForwardingGroup is applied by checking the telemetry path state values.
-		forwardingGroup := gnmi.OC().Qos().ForwardingGroup(tc.targetGrpoup)
-		if got, want := gnmi.Get(t, dut, forwardingGroup.Name().State()), tc.targetGrpoup; got != want {
-			t.Errorf("forwardingGroup.Name().State(): got %v, want %v", got, want)
-		}
-		if got, want := gnmi.Get(t, dut, forwardingGroup.OutputQueue().State()), tc.queueName; got != want {
-			t.Errorf("forwardingGroup.OutputQueue().State(): got %v, want %v", got, want)
-		}
+	if got, want := gnmi.Get(t, dut, classifier.Type().State()), oc.Input_Classifier_Type_IPV4; got != want {
+		t.Errorf("classifier.Name().State(): got %v, want %v", got, want)
 	}
 }
 
@@ -374,6 +332,12 @@ func TestSchedulerPoliciesConfig(t *testing.T) {
 	dut := ondatra.DUT(t, "dut")
 	d := &oc.Root{}
 	q := d.GetOrCreateQos()
+	queues := []string{"tc7", "tc6", "tc5", "tc4", "tc3", "tc2", "tc1"}
+	for _, queue := range queues {
+		q1 := q.GetOrCreateQueue(queue)
+		q1.Name = ygot.String(queue)
+		gnmi.Update(t, dut, gnmi.OC().Qos().Queue(*q1.Name).Config(), q1)
+	}
 
 	cases := []struct {
 		desc         string
@@ -388,65 +352,65 @@ func TestSchedulerPoliciesConfig(t *testing.T) {
 		desc:         "scheduler-policy-BE1",
 		sequence:     uint32(1),
 		priority:     oc.Scheduler_Priority_UNSET,
-		inputID:      "BE1",
+		inputID:      "tc1",
 		inputType:    oc.Input_InputType_QUEUE,
 		weight:       uint64(1),
-		queueName:    "BE1",
-		targetGrpoup: "target-group-BE1",
+		queueName:    "tc1",
+		targetGrpoup: "tc1",
 	}, {
 		desc:         "scheduler-policy-BE0",
 		sequence:     uint32(1),
 		priority:     oc.Scheduler_Priority_UNSET,
-		inputID:      "BE0",
+		inputID:      "tc2",
 		inputType:    oc.Input_InputType_QUEUE,
 		weight:       uint64(2),
-		queueName:    "BE0",
-		targetGrpoup: "target-group-BE0",
+		queueName:    "tc2",
+		targetGrpoup: "tc2",
 	}, {
 		desc:         "scheduler-policy-AF1",
 		sequence:     uint32(1),
 		priority:     oc.Scheduler_Priority_UNSET,
-		inputID:      "AF1",
+		inputID:      "tc3",
 		inputType:    oc.Input_InputType_QUEUE,
 		weight:       uint64(4),
-		queueName:    "AF1",
-		targetGrpoup: "target-group-AF1",
+		queueName:    "tc3",
+		targetGrpoup: "tc3",
 	}, {
 		desc:         "scheduler-policy-AF2",
 		sequence:     uint32(1),
 		priority:     oc.Scheduler_Priority_UNSET,
-		inputID:      "AF2",
+		inputID:      "tc4",
 		inputType:    oc.Input_InputType_QUEUE,
 		weight:       uint64(8),
-		queueName:    "AF2",
-		targetGrpoup: "target-group-AF2",
+		queueName:    "tc4",
+		targetGrpoup: "tc4",
 	}, {
 		desc:         "scheduler-policy-AF3",
 		sequence:     uint32(1),
 		priority:     oc.Scheduler_Priority_UNSET,
-		inputID:      "AF3",
+		inputID:      "tc5",
 		inputType:    oc.Input_InputType_QUEUE,
 		weight:       uint64(16),
-		queueName:    "AF3",
-		targetGrpoup: "target-group-AF3",
+		queueName:    "tc5",
+		targetGrpoup: "tc5",
 	}, {
 		desc:         "scheduler-policy-AF4",
-		sequence:     uint32(0),
+		sequence:     uint32(2),
 		priority:     oc.Scheduler_Priority_STRICT,
-		inputID:      "AF4",
+		inputID:      "tc6",
 		inputType:    oc.Input_InputType_QUEUE,
-		weight:       uint64(100),
-		queueName:    "AF4",
-		targetGrpoup: "target-group-AF4",
+		weight:       uint64(6),
+		queueName:    "tc6",
+		targetGrpoup: "tc6",
 	}, {
 		desc:         "scheduler-policy-NC1",
-		sequence:     uint32(0),
+		sequence:     uint32(2),
 		priority:     oc.Scheduler_Priority_STRICT,
-		inputID:      "NC1",
+		inputID:      "tc7",
 		inputType:    oc.Input_InputType_QUEUE,
-		weight:       uint64(200),
-		queueName:    "NC1",
-		targetGrpoup: "target-group-NC1",
+		weight:       uint64(7),
+		queueName:    "tc7",
+		targetGrpoup: "tc7",
 	}}
 
 	schedulerPolicy := q.GetOrCreateSchedulerPolicy("scheduler")
@@ -459,16 +423,21 @@ func TestSchedulerPoliciesConfig(t *testing.T) {
 			s.SetPriority(tc.priority)
 			input := s.GetOrCreateInput(tc.inputID)
 			input.SetId(tc.inputID)
-			input.SetInputType(tc.inputType)
+			//input.SetInputType(tc.inputType)
 			input.SetQueue(tc.queueName)
 			input.SetWeight(tc.weight)
-			gnmi.Replace(t, dut, gnmi.OC().Qos().Config(), q)
 		})
+	}
+	gnmi.Update(t, dut, gnmi.OC().Qos().Config(), q)
+	t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
+	// dp := dut.Port(t, "port2")
+	// schedinterface := q.GetOrCreateInterface(dp.Name())
+	// schedinterface.InterfaceId = ygot.String(dp.Name())
+	// schedinterfaceout := schedinterface.GetOrCreateOutput()
+	// scheinterfaceschedpol := schedinterfaceout.GetOrCreateSchedulerPolicy()
+	// scheinterfaceschedpol.Name = ygot.String("scheduler")
 
-		// TODO: Remove the following t.Skipf() after the config verification code has been tested.
-		t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
-
-		// Verify the SchedulerPolicy is applied by checking the telemetry path state values.
+	for _, tc := range cases {
 		scheduler := gnmi.OC().Qos().SchedulerPolicy("scheduler").Scheduler(tc.sequence)
 		input := scheduler.Input(tc.inputID)
 
@@ -491,6 +460,8 @@ func TestSchedulerPoliciesConfig(t *testing.T) {
 			t.Errorf("input.Queue().State(): got %v, want %v", got, want)
 		}
 	}
+	// qosSchedulerPolicies := gnmi.GetAll(t, dut, gnmi.OC().Qos().SchedulerPolicyAny().Name().Config())
+	// t.Logf("qosSchedulerPolicies from telmetry: %v", qosSchedulerPolicies)
 }
 
 func TestECNConfig(t *testing.T) {
@@ -509,7 +480,7 @@ func TestECNConfig(t *testing.T) {
 		ecnEnabled:                true,
 		dropEnabled:               false,
 		minThreshold:              uint64(80000),
-		maxThreshold:              math.MaxUint64,
+		maxThreshold:              uint64(1000000),
 		maxDropProbabilityPercent: uint8(1),
 		weight:                    uint32(0),
 	}
@@ -519,7 +490,7 @@ func TestECNConfig(t *testing.T) {
 	wred := queueMgmtProfile.GetOrCreateWred()
 	uniform := wred.GetOrCreateUniform()
 	uniform.SetEnableEcn(ecnConfig.ecnEnabled)
-	uniform.SetDrop(ecnConfig.dropEnabled)
+	//uniform.SetDrop(ecnConfig.dropEnabled)
 	uniform.SetMinThreshold(ecnConfig.minThreshold)
 	uniform.SetMaxThreshold(ecnConfig.maxThreshold)
 	// TODO: uncomment the following config after it is supported.
@@ -527,7 +498,7 @@ func TestECNConfig(t *testing.T) {
 	// uniform.SetWeight(ecnConfig.weight)
 
 	t.Logf("qos ECN QueueManagementProfile config cases: %v", ecnConfig)
-	gnmi.Replace(t, dut, gnmi.OC().Qos().Config(), q)
+	gnmi.Update(t, dut, gnmi.OC().Qos().Config(), q)
 
 	// TODO: Remove the following t.Skipf() after the config verification code has been tested.
 	t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
@@ -565,37 +536,37 @@ func TestQoSOutputIntfConfig(t *testing.T) {
 		scheduler  string
 	}{{
 		desc:       "output-interface-BE1",
-		queueName:  "BE1",
+		queueName:  "tc1",
 		ecnProfile: "DropProfile",
 		scheduler:  "scheduler",
 	}, {
 		desc:       "output-interface-BE0",
-		queueName:  "BE0",
+		queueName:  "tc2",
 		ecnProfile: "DropProfile",
 		scheduler:  "scheduler",
 	}, {
 		desc:       "output-interface-AF1",
-		queueName:  "AF1",
+		queueName:  "tc3",
 		ecnProfile: "DropProfile",
 		scheduler:  "scheduler",
 	}, {
 		desc:       "output-interface-AF2",
-		queueName:  "AF2",
+		queueName:  "tc4",
 		ecnProfile: "DropProfile",
 		scheduler:  "scheduler",
 	}, {
 		desc:       "output-interface-AF3",
-		queueName:  "AF3",
+		queueName:  "tc5",
 		ecnProfile: "DropProfile",
 		scheduler:  "scheduler",
 	}, {
 		desc:       "output-interface-AF4",
-		queueName:  "AF4",
+		queueName:  "tc6",
 		ecnProfile: "DropProfile",
 		scheduler:  "scheduler",
 	}, {
 		desc:       "output-interface-NC1",
-		queueName:  "NC1",
+		queueName:  "tc7",
 		ecnProfile: "DropProfile",
 		scheduler:  "scheduler",
 	}}
@@ -614,13 +585,16 @@ func TestQoSOutputIntfConfig(t *testing.T) {
 			queue := output.GetOrCreateQueue(tc.queueName)
 			queue.SetQueueManagementProfile(tc.ecnProfile)
 			queue.SetName(tc.queueName)
-			gnmi.Replace(t, dut, gnmi.OC().Qos().Config(), q)
 		})
+	}
+	gnmi.Update(t, dut, gnmi.OC().Qos().Config(), q)
+	defer teardownQos(t)
 
-		// TODO: Remove the following t.Skipf() after the config verification code has been tested.
-		t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
+	// TODO: Remove the following t.Skipf() after the config verification code has been tested.
+	t.Skipf("Skip the QoS config verification until it is tested against a DUT.")
 
-		// Verify the policy is applied by checking the telemetry path state values.
+	// Verify the policy is applied by checking the telemetry path state values.
+	for _, tc := range cases {
 		policy := gnmi.OC().Qos().Interface(dp.Name()).Output().SchedulerPolicy()
 		outQueue := gnmi.OC().Qos().Interface(dp.Name()).Output().Queue(tc.queueName)
 		if got, want := gnmi.Get(t, dut, policy.Name().State()), tc.scheduler; got != want {
@@ -634,3 +608,9 @@ func TestQoSOutputIntfConfig(t *testing.T) {
 		}
 	}
 }
+
+func teardownQos(t *testing.T) {
+	dut := ondatra.DUT(t, "dut")
+	gnmi.Delete(t, dut, gnmi.OC().Qos().Config())
+	//gnmi.Get(t, dut, gnmi.OC().Qos().State())
+}
