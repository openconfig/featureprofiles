diff --git a/feature/interface/singleton/ate_tests/singleton_test/singleton_test.go b/feature/interface/singleton/ate_tests/singleton_test/singleton_test.go
index 46cc2d5..7304f4b 100644
--- a/feature/interface/singleton/ate_tests/singleton_test/singleton_test.go
+++ b/feature/interface/singleton/ate_tests/singleton_test/singleton_test.go
@@ -15,7 +15,10 @@
 package singleton_test
 
 import (
+	"context"
 	"fmt"
+	"strconv"
+	"strings"
 	"testing"
 	"time"
 
@@ -145,6 +148,31 @@ func (tc *testCase) configureDUTBreakout(t *testing.T) *oc.Component_Port_Breako
 
 }
 
+func (tc *testCase) getControlPacket(t *testing.T) int64 {
+	t.Helper()
+	ctx := context.Background()
+	ixNetwork := tc.ate.RawAPIs().IxNetwork(t)
+	portname := strings.Split(tc.ate.Port(t, "port2").Name(), "/")
+	args := struct {
+		AbsPath  string
+		PortName string
+		Stats    string
+	}{
+		AbsPath:  ixNetwork.AbsPath("statistics/view/8"),
+		PortName: fmt.Sprintf("%s/Card0%s/Port%s", tc.ate.Name(), portname[0], portname[1]),
+		Stats:    "Control Packet Tx.",
+	}
+
+	var rsp string
+	err := ixNetwork.Post(ctx, "statistics/view/operations/getvalue", args, &rsp)
+	if err != nil {
+		t.Fatalf("Error in getting Control Packet Tx: %v\n", err)
+	}
+
+	controlPkts, _ := strconv.ParseInt(rsp, 10, 64)
+	return controlPkts
+}
+
 func (tc *testCase) configureDUT(t *testing.T) {
 	d := gnmi.OC()
 
@@ -217,18 +245,20 @@ func (tc *testCase) verifyInterfaceDUT(
 		t.Errorf("%s oper-status got %v, want %v", dp, got, opUp)
 	}
 
-	disp := dip.Subinterface(0)
+	if *deviations.SubinterfaceOriginCheck {
+		disp := dip.Subinterface(0)
 
-	// IPv4 neighbor discovered by ARP.
-	dis4np := disp.Ipv4().Neighbor(atea.IPv4)
-	if got := gnmi.Get(t, tc.dut, dis4np.Origin().State()); got != dynamic {
-		t.Errorf("%s IPv4 neighbor %s origin got %v, want %v", dp, atea.IPv4, got, dynamic)
-	}
+		// IPv4 neighbor discovered by ARP.
+		dis4np := disp.Ipv4().Neighbor(atea.IPv4)
+		if got := gnmi.Get(t, tc.dut, dis4np.Origin().State()); got != dynamic {
+			t.Errorf("%s IPv4 neighbor %s origin got %v, want %v", dp, atea.IPv4, got, dynamic)
+		}
 
-	// IPv6 neighbor discovered by ARP.
-	dis6np := disp.Ipv6().Neighbor(atea.IPv6)
-	if got := gnmi.Get(t, tc.dut, dis6np.Origin().State()); got != dynamic {
-		t.Errorf("%s IPv6 neighbor %s origin got %v, want %v", dp, atea.IPv6, got, dynamic)
+		// IPv6 neighbor discovered by ARP.
+		dis6np := disp.Ipv6().Neighbor(atea.IPv6)
+		if got := gnmi.Get(t, tc.dut, dis6np.Origin().State()); got != dynamic {
+			t.Errorf("%s IPv6 neighbor %s origin got %v, want %v", dp, atea.IPv6, got, dynamic)
+		}
 	}
 }
 
@@ -321,6 +351,7 @@ func (tc *testCase) testFlow(t *testing.T, packetSize uint16, ipHeader ondatra.H
 	tc.ate.Traffic().Start(t, flow)
 	time.Sleep(15 * time.Second)
 	tc.ate.Traffic().Stop(t)
+	time.Sleep(120 * time.Second)
 
 	// Counters from ATE interface telemetry may be inaccurate.  Only
 	// showing them for diagnostics only.  Use flow telemetry counters
@@ -381,7 +412,10 @@ func (tc *testCase) testFlow(t *testing.T, packetSize uint16, ipHeader ondatra.H
 	} else if avg := octets / inPkts; avg > uint64(tc.mtu) {
 		t.Errorf("Flow destination packet size average got %d, want <= %d (MTU)", avg, tc.mtu)
 	}
-	if inPkts < p2OutDiff.unicast {
+
+	controlPkts := tc.getControlPacket(t)
+	t.Logf("Control Packet Tx : %d\n", controlPkts)
+	if inPkts < p2OutDiff.unicast-uint64(controlPkts) {
 		t.Errorf("ATE received too few destination packets: got %d, want >= %d", inPkts, p2OutDiff.unicast)
 	}
 	t.Logf("flow loss-pct %f", gnmi.Get(t, tc.ate, fp.LossPct().State()))
diff --git a/internal/deviations/deviations.go b/internal/deviations/deviations.go
index a485775..8b9d2d8 100644
--- a/internal/deviations/deviations.go
+++ b/internal/deviations/deviations.go
@@ -116,4 +116,6 @@ var (
 		"Device requires explicit attachment of an interface or subinterface to the default network instance. OpenConfig expects an unattached interface or subinterface to be implicitly part of the default network instance. Fully-compliant devices should pass with and without this deviation.")
 
 	ExplicitPortSpeed = flag.Bool("deviation_explicit_port_speed", false, "Device requires port-speed to be set because its default value may not be usable. Fully compliant devices should select the highest speed available based on negotiation.")
+
+	SubinterfaceOriginCheck = flag.Bool("subinterface_origin_check", false, "Skip telemetry on subinterfaces/subinterface/neighbors/neighbors/state/origin till CSCwc63655 is fixed")
 )
