diff --git a/feature/gnmi/ate_tests/telemetry_basic_check_test/telemetry_basic_check_test.go b/feature/gnmi/ate_tests/telemetry_basic_check_test/telemetry_basic_check_test.go
index 5e04f9e7..067c5b17
--- a/feature/gnmi/ate_tests/telemetry_basic_check_test/telemetry_basic_check_test.go
+++ b/feature/gnmi/ate_tests/telemetry_basic_check_test/telemetry_basic_check_test.go
@@ -35,7 +35,7 @@ import (
 )
 
 var (
-	p4rtNodeName = flag.String("p4rt_node_name", "SwitchChip3/0", "component name for P4RT Node")
+	p4rtNodeName = flag.String("p4rt_node_name", "0/0/CPU0-NPU0", "component name for P4RT Node")
 )
 
 const (
@@ -137,6 +137,7 @@ func TestInterfaceOperStatus(t *testing.T) {
 }
 
 func TestInterfacePhysicalChannel(t *testing.T) {
+	t.Skip("oc-transceiver support needed,tracked via CSCwb72703")
 	dut := ondatra.DUT(t, "dut")
 	dp := dut.Port(t, "port1")
 
@@ -191,6 +192,7 @@ func TestInterfaceStatusChange(t *testing.T) {
 }
 
 func TestHardwarePort(t *testing.T) {
+	t.Skip("openconfig:interfaces/interface/state/hardware-port not supported , tracked via CSCwd10734")
 	dut := ondatra.DUT(t, "dut")
 	dp := dut.Port(t, "port1")
 
@@ -336,29 +338,32 @@ func TestComponentParent(t *testing.T) {
 		regexpPattern string
 		parent        string
 	}{{
+		//NAME: "Rack 0-Fabric Card Slot 0", DESCR: "8812 Fabric Card Slot 0"
 		desc:          "Fabric",
-		regexpPattern: "^Fabric[0-9]",
-		parent:        componentParent["Fabric"],
+		regexpPattern: "^Rack [0-9]-Fabric Card Slot [0-9]$",
+		parent:        componentParent["Rack"],
 	}, {
+		//Cisco 8812 Fabric Card
 		desc:          "FabricChip",
-		regexpPattern: "^FabricChip",
-		parent:        componentParent["FabricChip"],
+		regexpPattern: "^[0-9]/FC[0-9]$",
+		parent:        componentParent["Rack"],
 	}, {
 		desc:          "Linecard",
-		regexpPattern: "^Linecard[0-9]",
-		parent:        componentParent["Linecard"],
+		regexpPattern: "^[0-9]/[0-9]/CPU[0-9]$",
+		parent:        componentParent["Rack"],
 	}, {
 		desc:          "Power supply",
-		regexpPattern: "^PowerSupply[0-9]",
-		parent:        componentParent["PowerSupply"],
+		regexpPattern: "^Rack [0-9]-[PSU|Power].*Slot [0-9]$",
+		parent:        componentParent["Rack"],
 	}, {
 		desc:          "Supervisor",
-		regexpPattern: "^Supervisor[0-9]$",
-		parent:        componentParent["Supervisor"],
+		regexpPattern: "^[0-9]/RP[0-9]/CPU[0-9]$",
+		parent:        componentParent["Rack"],
 	}, {
+		//"0/0/CPU0-LC-SW Control Ethernet Switch", DESCR: "LC-SW Control Ethernet Switch"
 		desc:          "SwitchChip",
-		regexpPattern: "^SwitchChip",
-		parent:        componentParent["SwitchChip"],
+		regexpPattern: "^[0-9]/[0-9]/CPU[0-9]-LC-SW.*Switch$",
+		parent:        componentParent["Rack"],
 	}}
 
 	for _, tc := range cases {
@@ -391,7 +396,7 @@ func TestComponentParent(t *testing.T) {
 
 func TestSoftwareVersion(t *testing.T) {
 	dut := ondatra.DUT(t, "dut")
-	regexpPattern := "^Supervisor[0-9]"
+	regexpPattern := "^[0-9]/RP[0-9]/CPU[0-9]-.*$"
 
 	r, err := regexp.Compile(regexpPattern)
 	if err != nil {
@@ -438,7 +443,7 @@ func TestSoftwareVersion(t *testing.T) {
 func TestCPU(t *testing.T) {
 	dut := ondatra.DUT(t, "dut")
 
-	r := regexp.MustCompile("^CPU")
+	r := regexp.MustCompile("^[0-9]/RP[0-9]/CPU[0-9]$")
 	cpus := findMatchedComponents(t, dut, r)
 	t.Logf("Found CPU list: %v", cpus)
 	if len(cpus) == 0 {
@@ -463,8 +468,9 @@ func TestCPU(t *testing.T) {
 }
 
 func TestSupervisorLastRebootInfo(t *testing.T) {
+	t.Skip("/components/component/state/last-reboot-time and last-reboot-reason not supported , tracked via CSCwd07369")
 	dut := ondatra.DUT(t, "dut")
-	regexpPattern := "^Supervisor[0-9]"
+	regexpPattern := "^[0-9]/RP[0-9]/CPU[0-9]$"
 
 	r, err := regexp.Compile(regexpPattern)
 	if err != nil {
@@ -514,7 +520,7 @@ func findMatchedComponents(t *testing.T, dut *ondatra.DUTDevice, r *regexp.Regex
 
 func TestAFT(t *testing.T) {
 	// TODO: Remove t.Skipf() after the issue is fixed.
-	t.Skipf("Test is skipped due to the failure")
+	//t.Skipf("Test is skipped due to the failure")
 
 	dut := ondatra.DUT(t, "dut")
 	afts := dut.Telemetry().NetworkInstanceAny().Afts().Lookup(t)
