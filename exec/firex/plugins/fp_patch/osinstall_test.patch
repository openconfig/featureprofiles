diff --git a/feature/gnoi/os/tests/osinstall/osinstall_test.go b/feature/gnoi/os/tests/osinstall/osinstall_test.go
index ef9a78df..6b7fa3d8 100644
--- a/feature/gnoi/os/tests/osinstall/osinstall_test.go
+++ b/feature/gnoi/os/tests/osinstall/osinstall_test.go
@@ -23,6 +23,7 @@ import (
 	"testing"
 	"time"
 
+	"github.com/openconfig/featureprofiles/internal/deviations"
 	"github.com/openconfig/featureprofiles/internal/fptest"
 	closer "github.com/openconfig/gocloser"
 	"github.com/openconfig/ondatra"
@@ -65,6 +66,8 @@ func TestMain(m *testing.M) {
 }
 
 func TestOSInstall(t *testing.T) {
+	*osFile = os.Getenv("XR_IMAGE_PATH")
+	*osVersion = os.Getenv("XR_IMAGE_VERSION")
 	if *osFile == "" || *osVersion == "" {
 		t.Fatal("Missing osfile or osver args")
 	}
@@ -86,13 +89,21 @@ func TestOSInstall(t *testing.T) {
 		sc:     dut.RawAPIs().GNOI().Default(t).System(),
 	}
 	tc.fetchStandbySupervisorStatus(ctx, t)
+	// install and activate os on master RP
 	tc.transferOS(ctx, t, false)
 	tc.activateOS(ctx, t, false)
-	if tc.dualSup {
+
+	if !*deviations.NoOSInstallForStandbyRP && tc.dualSup {
+		// install and activate os on master RP
 		tc.transferOS(ctx, t, true)
 		tc.activateOS(ctx, t, true)
 	}
-	tc.rebootDUT(ctx, t)
+
+	if *deviations.OSActiavteNoReboot {
+		tc.rebootDUT(ctx, t)
+	}
+	// reconnect GNOI client 
+	tc.osc = tc.dut.RawAPIs().GNOI().New(t).OS()
 	tc.verifyInstall(ctx, t)
 }
 
@@ -100,7 +111,7 @@ func (tc *testCase) activateOS(ctx context.Context, t *testing.T, standby bool)
 	act, err := tc.osc.Activate(ctx, &ospb.ActivateRequest{
 		StandbySupervisor: standby,
 		Version:           *osVersion,
-		NoReboot:          true,
+		NoReboot:          *deviations.OSActiavteNoReboot,
 	})
 	if err != nil {
 		t.Fatalf("OS.Activate request failed: %s", err)
@@ -119,6 +130,27 @@ func (tc *testCase) activateOS(ctx context.Context, t *testing.T, standby bool)
 	default:
 		t.Fatalf("OS.Activate unexpected response: got %v (%T)", resp, resp)
 	}
+	// when no reboot is set to false, the device expected to do reboot if is required. 
+	// Reboot is not neccessary in all cases and the device does reboot based on the number of updated packages and impacted processes.
+	// THe below code checks and make sure the possible reboot is completed. 
+	if !*deviations.OSActiavteNoReboot {
+		t.Log("Check for os reboot to be completed when  noreboot flag is set to false")
+		// wait for 1 minutes to ensure the reboot is started
+		deadline := time.Now().Add(*timeout)
+		time.Sleep(1*time.Minute) 
+		for {
+			var bootTime *telemetry.QualifiedUint64	
+			testt.CaptureFatal(t, func(t testing.TB) {
+				bootTime = tc.dut.Telemetry().System().BootTime().Lookup(t)
+			})
+			if bootTime != nil {
+				break
+			}
+			if time.Now().After(deadline) {
+				t.Fatal("Past reboot deadline, the device was not up after activation with noreboot=false")
+			}
+		}
+	}
 }
 
 // fetchStandbySupervisorStatus checks if the DUT has a standby supervisor available in a working state.
diff --git a/internal/deviations/deviations.go b/internal/deviations/deviations.go
index 4e12f89a..6a0ef7b7 100644
--- a/internal/deviations/deviations.go
+++ b/internal/deviations/deviations.go
@@ -92,7 +92,7 @@ var (
 	OmitL2MTU = flag.Bool("deviation_omit_l2_mtu", false,
 		"Device does not support setting the L2 MTU, so omit it.  OpenConfig allows a device to enforce that L2 MTU, which has a default value of 1514, must be set to a higher value than L3 MTU, so a full OpenConfig compliant device may fail with the deviation.")
 
-	GRIBIPreserveOnly = flag.Bool("deviation_gribi_preserve_only", true, "Device does not support gRIBI client with persistence DELETE, so this skips the optional test cases in DELETE mode.  However, tests explicitly testing DELETE mode will still run.  Full gRIBI compliant devices should pass both with and without this deviation.")
+	GRIBIPreserveOnly = flag.Bool("deviation_gribi_preserve_only", false, "Device does not support gRIBI client with persistence DELETE, so this skips the optional test cases in DELETE mode.  However, tests explicitly testing DELETE mode will still run.  Full gRIBI compliant devices should pass both with and without this deviation.")
 
 	GRIBIRIBAckOnly = flag.Bool("deviation_gribi_riback_only", false, "Device only supports RIB ack, so tests that normally expect FIB_ACK will allow just RIB_ACK.  Full gRIBI compliant devices should pass both with and without this deviation.")
 
@@ -101,5 +101,9 @@ var (
 
 	StaticProtocolName = flag.String("deviation_static_protocol_name", "DEFAULT", "The name used for the static routing protocol.  The default name in OpenConfig is \"DEFAULT\" but some devices use other names.")
 
+	OSActiavteNoReboot = flag.Bool("deviation_osactiavte_noreboot", false, "Device requires seperate reboot to activate OS.")
+
+	NoOSInstallForStandbyRP = flag.Bool("deviation_no_osinstall_for_standby_rp", false, "Device does not require OS installation on standby RP since the standby RP always kept in sync with the master RP, so suppress installing OS on standby RP.")
+
 	DeprecatedVlanID = flag.Bool("deviation_deprecated_vlan_id", false, "Device requires using the deprecated openconfig-vlan:vlan/config/vlan-id or openconfig-vlan:vlan/state/vlan-id leaves.")
 )
