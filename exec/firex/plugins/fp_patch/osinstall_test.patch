diff --git a/exec/firex/plugins/fp_patch/osinstall_test.patch b/exec/firex/plugins/fp_patch/osinstall_test.patch
index b96ffebe..e69de29b 100644
--- a/exec/firex/plugins/fp_patch/osinstall_test.patch
+++ b/exec/firex/plugins/fp_patch/osinstall_test.patch
@@ -1,107 +0,0 @@
-diff --git a/feature/gnoi/os/tests/osinstall/osinstall_test.go b/feature/gnoi/os/tests/osinstall/osinstall_test.go
-index ef9a78df..021aafa2
---- a/feature/gnoi/os/tests/osinstall/osinstall_test.go
-+++ b/feature/gnoi/os/tests/osinstall/osinstall_test.go
-@@ -87,20 +87,31 @@ func TestOSInstall(t *testing.T) {
- 	}
- 	tc.fetchStandbySupervisorStatus(ctx, t)
- 	tc.transferOS(ctx, t, false)
--	tc.activateOS(ctx, t, false)
--	if tc.dualSup {
--		tc.transferOS(ctx, t, true)
--		tc.activateOS(ctx, t, true)
-+	noreboot := true
-+	bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
-+	switch dut.Vendor() {
-+	case ondatra.CISCO:
-+		noreboot = false
-+	}
-+	tc.activateOS(ctx, t, false, noreboot)
-+	switch dut.Vendor() {
-+	case ondatra.CISCO:
-+		t.Logf("Skipping Activate on Standby Supervisor")
-+	default:
-+		if tc.dualSup {
-+			tc.transferOS(ctx, t, true)
-+			tc.activateOS(ctx, t, true, noreboot)
-+		}
- 	}
--	tc.rebootDUT(ctx, t)
-+	tc.rebootDUT(ctx, t, bootTime, noreboot)
- 	tc.verifyInstall(ctx, t)
- }
- 
--func (tc *testCase) activateOS(ctx context.Context, t *testing.T, standby bool) {
-+func (tc *testCase) activateOS(ctx context.Context, t *testing.T, standby bool, noreboot bool) {
- 	act, err := tc.osc.Activate(ctx, &ospb.ActivateRequest{
- 		StandbySupervisor: standby,
- 		Version:           *osVersion,
--		NoReboot:          true,
-+		NoReboot:          noreboot,
- 	})
- 	if err != nil {
- 		t.Fatalf("OS.Activate request failed: %s", err)
-@@ -144,18 +155,18 @@ func (tc *testCase) fetchStandbySupervisorStatus(ctx context.Context, t *testing
- 	}
- }
- 
--func (tc *testCase) rebootDUT(ctx context.Context, t *testing.T) {
--	bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
-+func (tc *testCase) rebootDUT(ctx context.Context, t *testing.T, bootTime uint64, noreboot bool) {
- 	deadline := time.Now().Add(*timeout)
--
--	t.Log("Send DUT Reboot Request")
--	_, err := tc.sc.Reboot(ctx, &spb.RebootRequest{
--		Method:  spb.RebootMethod_COLD,
--		Force:   true,
--		Message: "Apply GNOI OS Software Install",
--	})
--	if err != nil && status.Code(err) != codes.Unavailable {
--		t.Fatalf("System.Reboot request failed: %s", err)
-+	if noreboot {
-+		t.Log("Send DUT Reboot Request")
-+		_, err := tc.sc.Reboot(ctx, &spb.RebootRequest{
-+			Method:  spb.RebootMethod_COLD,
-+			Force:   true,
-+			Message: "Apply GNOI OS Software Install",
-+		})
-+		if err != nil && status.Code(err) != codes.Unavailable {
-+			t.Fatalf("System.Reboot request failed: %s", err)
-+		}
- 	}
- 	for {
- 		var curBootTime *telemetry.QualifiedUint64
-@@ -250,13 +261,28 @@ func (tc *testCase) transferOS(ctx context.Context, t *testing.T, standby bool)
- // verifyInstall validates the OS.Verify RPC returns no failures and version numbers match the
- // newly requested software version.
- func (tc *testCase) verifyInstall(ctx context.Context, t *testing.T) {
--	r, err := tc.osc.Verify(ctx, &ospb.VerifyRequest{})
--	if err != nil {
--		t.Fatalf("OS.Verify request failed: %s", err)
-+	osc := tc.dut.RawAPIs().GNOI().New(t).OS()
-+	deadline := time.Now().Add(5 * time.Minute)
-+	for {
-+		r, err := osc.Verify(ctx, &ospb.VerifyRequest{})
-+		if err != nil {
-+			t.Fatalf("OS.Verify request failed: %s", err)
-+		}
-+		if got, want := r.GetActivationFailMessage(), ""; got == want {
-+			t.Logf("Activation Completed")
-+			break
-+		}
-+		if time.Now().After(deadline) {
-+			t.Fatal("Past deadline for Activation to Complete")
-+		}
-+		t.Logf("OS.Verify ActivationFailMessage: got %q,want %q", r.GetActivationFailMessage(), "")
-+		t.Log("Waiting for Activation to Complete...")
-+		time.Sleep(20 * time.Second)
- 	}
- 
--	if got, want := r.GetActivationFailMessage(), ""; got != want {
--		t.Errorf("OS.Verify ActivationFailMessage: got %q, want %q", got, want)
-+	r, err := osc.Verify(ctx, &ospb.VerifyRequest{})
-+	if err != nil {
-+		t.Fatalf("OS.Verify request failed: %s", err)
- 	}
- 	if got, want := r.GetVersion(), *osVersion; got != want {
- 		t.Errorf("OS.Verify Version: got %q, want %q", got, want)
diff --git a/feature/gnoi/os/tests/osinstall/osinstall_test.go b/feature/gnoi/os/tests/osinstall/osinstall_test.go
index ef9a78df..ebc5a791 100644
--- a/feature/gnoi/os/tests/osinstall/osinstall_test.go
+++ b/feature/gnoi/os/tests/osinstall/osinstall_test.go
@@ -23,6 +23,7 @@ import (
 	"testing"
 	"time"
 
+	"github.com/openconfig/featureprofiles/internal/deviations"
 	"github.com/openconfig/featureprofiles/internal/fptest"
 	closer "github.com/openconfig/gocloser"
 	"github.com/openconfig/ondatra"
@@ -65,6 +66,8 @@ func TestMain(m *testing.M) {
 }
 
 func TestOSInstall(t *testing.T) {
+	*osFile = os.Getenv("XR_IMAGE_PATH")
+	*osVersion = os.Getenv("XR_IMAGE_VERSION") 
 	if *osFile == "" || *osVersion == "" {
 		t.Fatal("Missing osfile or osver args")
 	}
@@ -87,20 +90,36 @@ func TestOSInstall(t *testing.T) {
 	}
 	tc.fetchStandbySupervisorStatus(ctx, t)
 	tc.transferOS(ctx, t, false)
-	tc.activateOS(ctx, t, false)
-	if tc.dualSup {
+	if *deviations.OSActiavteRequiresReboot {
+		bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
+		tc.activateOS(ctx, t, true,false)
+		tc.verifyRebootStatus(t,bootTime,*timeout)
+	} else {
+		tc.activateOS(ctx, t, false,true)
+	}
+	// Install OS on standby if required
+	if !*deviations.NoOSInstallForStandbyRP && tc.dualSup {
 		tc.transferOS(ctx, t, true)
-		tc.activateOS(ctx, t, true)
+		if *deviations.OSActiavteRequiresReboot {
+			bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
+			tc.activateOS(ctx, t, true,false)
+			tc.verifyRebootStatus(t,bootTime,*timeout)
+		} else {
+			tc.activateOS(ctx, t, true,true)
+		}
+	}	
+
+	if !*deviations.OSActiavteRequiresReboot { // device is already rebooted during activation
+		tc.rebootDUT(ctx, t)
 	}
-	tc.rebootDUT(ctx, t)
 	tc.verifyInstall(ctx, t)
 }
 
-func (tc *testCase) activateOS(ctx context.Context, t *testing.T, standby bool) {
+func (tc *testCase) activateOS(ctx context.Context, t *testing.T, standby, noreboot bool) {
 	act, err := tc.osc.Activate(ctx, &ospb.ActivateRequest{
 		StandbySupervisor: standby,
 		Version:           *osVersion,
-		NoReboot:          true,
+		NoReboot:          noreboot,
 	})
 	if err != nil {
 		t.Fatalf("OS.Activate request failed: %s", err)
@@ -144,19 +163,8 @@ func (tc *testCase) fetchStandbySupervisorStatus(ctx context.Context, t *testing
 	}
 }
 
-func (tc *testCase) rebootDUT(ctx context.Context, t *testing.T) {
-	bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
-	deadline := time.Now().Add(*timeout)
-
-	t.Log("Send DUT Reboot Request")
-	_, err := tc.sc.Reboot(ctx, &spb.RebootRequest{
-		Method:  spb.RebootMethod_COLD,
-		Force:   true,
-		Message: "Apply GNOI OS Software Install",
-	})
-	if err != nil && status.Code(err) != codes.Unavailable {
-		t.Fatalf("System.Reboot request failed: %s", err)
-	}
+func (tc *testCase) verifyRebootStatus(t *testing.T, bootTime uint64, timeout time.Duration) {
+	deadline := time.Now().Add(timeout)
 	for {
 		var curBootTime *telemetry.QualifiedUint64
 
@@ -180,6 +188,21 @@ func (tc *testCase) rebootDUT(ctx context.Context, t *testing.T) {
 	}
 }
 
+func (tc *testCase) rebootDUT(ctx context.Context, t *testing.T) {
+	bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
+
+	t.Log("Send DUT Reboot Request")
+	_, err := tc.sc.Reboot(ctx, &spb.RebootRequest{
+		Method:  spb.RebootMethod_COLD,
+		Force:   true,
+		Message: "Apply GNOI OS Software Install",
+	})
+	if err != nil && status.Code(err) != codes.Unavailable {
+		t.Fatalf("System.Reboot request failed: %s", err)
+	}
+	tc.verifyRebootStatus(t, bootTime,*timeout)
+}
+
 func (tc *testCase) transferOS(ctx context.Context, t *testing.T, standby bool) {
 	ctx, cancel := context.WithCancel(ctx)
 	defer cancel()
diff --git a/internal/deviations/deviations.go b/internal/deviations/deviations.go
index c85f112b..74da3a1f 100644
--- a/internal/deviations/deviations.go
+++ b/internal/deviations/deviations.go
@@ -89,9 +89,15 @@ var (
 	OmitL2MTU = flag.Bool("deviation_omit_l2_mtu", false,
 		"Device does not support setting the L2 MTU, so omit it.  OpenConfig allows a device to enforce that L2 MTU, which has a default value of 1514, must be set to a higher value than L3 MTU, so a full OpenConfig compliant device may fail with the deviation.")
 
-	GRIBIPreserveOnly = flag.Bool("deviation_gribi_preserve_only", true, "Device does not support gRIBI client with persistence DELETE, so this skips the optional test cases in DELETE mode.  However, tests explicitly testing DELETE mode will still run.  Full gRIBI compliant devices should pass both with and without this deviation.")
+	GRIBIPreserveOnly = flag.Bool("deviation_gribi_preserve_only", false, "Device does not support gRIBI client with persistence DELETE, so this skips the optional test cases in DELETE mode.  However, tests explicitly testing DELETE mode will still run.  Full gRIBI compliant devices should pass both with and without this deviation.")
 
 	GRIBIRIBAckOnly = flag.Bool("deviation_gribi_riback_only", false, "Device only supports RIB ack, so tests that normally expect FIB_ACK will allow just RIB_ACK.  Full gRIBI compliant devices should pass both with and without this deviation.")
 
 	NextHopAFTNotSupported = flag.Bool("deviation_nexthop_aft_not_supported", false, "Device currently doesnot support AFT Next Hop Telemetry. A fully compliant device should support all types of AFT telemetry without this deviation.")
+
+	OSActiavteRequiresReboot = flag.Bool("deviation_osactiavte_requires_reboot", false, "Device doesnot support OS activation without reboot, so we pass noreboot=false when calling GNOI activate commend.")
+
+	NoOSInstallForStandbyRP = flag.Bool("deviation_no_osinstall_for_standby_rp", false, "Device doesnot require OS installation on standby RP since the standby RP always kept in sync with the master RP, so suppress installing OS on standby RP.")
+
+
 )
