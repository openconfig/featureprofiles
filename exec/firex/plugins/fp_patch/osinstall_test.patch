diff --git a/feature/gnoi/os/tests/osinstall/osinstall_test.go b/feature/gnoi/os/tests/osinstall/osinstall_test.go
index ef9a78df..8a8fb1c3 100644
--- a/feature/gnoi/os/tests/osinstall/osinstall_test.go
+++ b/feature/gnoi/os/tests/osinstall/osinstall_test.go
@@ -23,6 +23,7 @@ import (
 	"testing"
 	"time"
 
+	"github.com/openconfig/featureprofiles/internal/deviations"
 	"github.com/openconfig/featureprofiles/internal/fptest"
 	closer "github.com/openconfig/gocloser"
 	"github.com/openconfig/ondatra"
@@ -65,6 +66,8 @@ func TestMain(m *testing.M) {
 }
 
 func TestOSInstall(t *testing.T) {
+	*osFile = os.Getenv("XR_IMAGE_PATH")
+	*osVersion = os.Getenv("XR_IMAGE_VERSION")
 	if *osFile == "" || *osVersion == "" {
 		t.Fatal("Missing osfile or osver args")
 	}
@@ -87,20 +90,36 @@ func TestOSInstall(t *testing.T) {
 	}
 	tc.fetchStandbySupervisorStatus(ctx, t)
 	tc.transferOS(ctx, t, false)
-	tc.activateOS(ctx, t, false)
-	if tc.dualSup {
+	if *deviations.OSActiavteRequiresReboot {
+		bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
+		tc.activateOS(ctx, t, false /*standby*/, false /*noreboot*/)
+		tc.verifyRebootStatus(t, bootTime, *timeout)
+	} else {
+		tc.activateOS(ctx, t, false /*standby*/, true /*noreboot*/)
+	}
+	// Install OS on standby if required
+	if !*deviations.NoOSInstallForStandbyRP && tc.dualSup {
 		tc.transferOS(ctx, t, true)
-		tc.activateOS(ctx, t, true)
+		if *deviations.OSActiavteRequiresReboot {
+			bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
+			tc.activateOS(ctx, t, true, false)
+			tc.verifyRebootStatus(t, bootTime, *timeout)
+		} else {
+			tc.activateOS(ctx, t, true, true)
+		}
+	}
+
+	if !*deviations.OSActiavteRequiresReboot { // device is already rebooted during activation
+		tc.rebootDUT(ctx, t)
 	}
-	tc.rebootDUT(ctx, t)
 	tc.verifyInstall(ctx, t)
 }
 
-func (tc *testCase) activateOS(ctx context.Context, t *testing.T, standby bool) {
+func (tc *testCase) activateOS(ctx context.Context, t *testing.T, standby, noreboot bool) {
 	act, err := tc.osc.Activate(ctx, &ospb.ActivateRequest{
 		StandbySupervisor: standby,
 		Version:           *osVersion,
-		NoReboot:          true,
+		NoReboot:          noreboot,
 	})
 	if err != nil {
 		t.Fatalf("OS.Activate request failed: %s", err)
@@ -144,19 +163,8 @@ func (tc *testCase) fetchStandbySupervisorStatus(ctx context.Context, t *testing
 	}
 }
 
-func (tc *testCase) rebootDUT(ctx context.Context, t *testing.T) {
-	bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
-	deadline := time.Now().Add(*timeout)
-
-	t.Log("Send DUT Reboot Request")
-	_, err := tc.sc.Reboot(ctx, &spb.RebootRequest{
-		Method:  spb.RebootMethod_COLD,
-		Force:   true,
-		Message: "Apply GNOI OS Software Install",
-	})
-	if err != nil && status.Code(err) != codes.Unavailable {
-		t.Fatalf("System.Reboot request failed: %s", err)
-	}
+func (tc *testCase) verifyRebootStatus(t *testing.T, bootTime uint64, timeout time.Duration) {
+	deadline := time.Now().Add(timeout)
 	for {
 		var curBootTime *telemetry.QualifiedUint64
 
@@ -180,6 +188,21 @@ func (tc *testCase) rebootDUT(ctx context.Context, t *testing.T) {
 	}
 }
 
+func (tc *testCase) rebootDUT(ctx context.Context, t *testing.T) {
+	bootTime := tc.dut.Telemetry().System().BootTime().Get(t)
+
+	t.Log("Send DUT Reboot Request")
+	_, err := tc.sc.Reboot(ctx, &spb.RebootRequest{
+		Method:  spb.RebootMethod_COLD,
+		Force:   true,
+		Message: "Apply GNOI OS Software Install",
+	})
+	if err != nil && status.Code(err) != codes.Unavailable {
+		t.Fatalf("System.Reboot request failed: %s", err)
+	}
+	tc.verifyRebootStatus(t, bootTime, *timeout)
+}
+
 func (tc *testCase) transferOS(ctx context.Context, t *testing.T, standby bool) {
 	ctx, cancel := context.WithCancel(ctx)
 	defer cancel()
diff --git a/internal/deviations/deviations.go b/internal/deviations/deviations.go
index c85f112b..74da3a1f 100644
--- a/internal/deviations/deviations.go
+++ b/internal/deviations/deviations.go
@@ -89,9 +89,15 @@ var (
 	OmitL2MTU = flag.Bool("deviation_omit_l2_mtu", false,
 		"Device does not support setting the L2 MTU, so omit it.  OpenConfig allows a device to enforce that L2 MTU, which has a default value of 1514, must be set to a higher value than L3 MTU, so a full OpenConfig compliant device may fail with the deviation.")
 
-	GRIBIPreserveOnly = flag.Bool("deviation_gribi_preserve_only", true, "Device does not support gRIBI client with persistence DELETE, so this skips the optional test cases in DELETE mode.  However, tests explicitly testing DELETE mode will still run.  Full gRIBI compliant devices should pass both with and without this deviation.")
+	GRIBIPreserveOnly = flag.Bool("deviation_gribi_preserve_only", false, "Device does not support gRIBI client with persistence DELETE, so this skips the optional test cases in DELETE mode.  However, tests explicitly testing DELETE mode will still run.  Full gRIBI compliant devices should pass both with and without this deviation.")
 
 	GRIBIRIBAckOnly = flag.Bool("deviation_gribi_riback_only", false, "Device only supports RIB ack, so tests that normally expect FIB_ACK will allow just RIB_ACK.  Full gRIBI compliant devices should pass both with and without this deviation.")
 
 	NextHopAFTNotSupported = flag.Bool("deviation_nexthop_aft_not_supported", false, "Device currently doesnot support AFT Next Hop Telemetry. A fully compliant device should support all types of AFT telemetry without this deviation.")
+
+	OSActiavteRequiresReboot = flag.Bool("deviation_osactiavte_requires_reboot", false, "Device doesnot support OS activation without reboot, so we pass noreboot=false when calling GNOI activate commend.")
+
+	NoOSInstallForStandbyRP = flag.Bool("deviation_no_osinstall_for_standby_rp", false, "Device doesnot require OS installation on standby RP since the standby RP always kept in sync with the master RP, so suppress installing OS on standby RP.")
+
+
 )
