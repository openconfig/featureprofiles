diff --git a/feature/system/gnmi/metadata/tests/annotation_test/annotation_test.go b/feature/system/gnmi/metadata/tests/annotation_test/annotation_test.go
index 3c032e36..827b28c5 100644
--- a/feature/system/gnmi/metadata/tests/annotation_test/annotation_test.go
+++ b/feature/system/gnmi/metadata/tests/annotation_test/annotation_test.go
@@ -18,10 +18,13 @@ import (
 	"context"
 	"encoding/base64"
 	"encoding/json"
+	"flag"
 	"fmt"
 	"testing"
 
 	gpb "github.com/openconfig/gnmi/proto/gnmi"
+	"github.com/openconfig/ondatra/gnmi"
+	"github.com/openconfig/ygnmi/ygnmi"
 	"google.golang.org/protobuf/types/known/anypb"
 	"google.golang.org/protobuf/types/known/timestamppb"
 
@@ -29,6 +32,7 @@ import (
 	"github.com/openconfig/featureprofiles/internal/fptest"
 	"github.com/openconfig/ondatra"
 	"github.com/openconfig/ygot/util"
+	"github.com/openconfig/ygot/ygot"
 	"google.golang.org/protobuf/encoding/prototext"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/testing/protocmp"
@@ -69,6 +73,10 @@ func TestMain(m *testing.M) {
 //        /@/openconfig-metadata:protobuf-metadata: CNyR0gk=
 //
 
+var (
+	NoMetadataSingleUpdate = flag.Bool("deviation_nometadata_single_update", true, "Device requires metadata update to be accompanied by another update for an OC path.")
+)
+
 func TestGNMIMetadataAnnotation(t *testing.T) {
 	dut := ondatra.DUT(t, "dut")
 	cases := []struct {
@@ -100,6 +108,14 @@ func TestGNMIMetadataAnnotation(t *testing.T) {
 			t.Errorf("Cannot build a gNMI SetRequest from proto message: %v", err)
 		}
 
+		if *NoMetadataSingleUpdate {
+			t.Log("Appneding an update to the metadata due to NoMetadataSingleUpdate deviation")
+			// accompaniedPath and accompaniedUpdateVal can be any valid oc path and value
+			accompaniedPath := gnmi.OC().System().Hostname().Config().PathStruct()
+			accompaniedUpdateVal := gnmi.Get[string](t, dut, gnmi.OC().System().Hostname().State())
+			gpbSetRequest.Update = append(gpbSetRequest.Update, buildGNMIUpdate(t, accompaniedPath, &accompaniedUpdateVal))
+		}
+
 		t.Log("gnmiClient Set metadata annotation")
 		if _, err = gnmiClient.Set(context.Background(), gpbSetRequest); err != nil {
 			t.Errorf("gnmi.Set unexpected error: %v", err)
@@ -217,3 +233,23 @@ func extractMetadataAnnotation(getResponse *gpb.GetResponse, m proto.Message) er
 	}
 	return nil
 }
+
+// buildGNMIUpdate builds a gnmi update for a given ygot path and value.
+func buildGNMIUpdate(t *testing.T, yPath ygnmi.PathStruct, val interface{}) *gpb.Update {
+	path, _, errs := ygnmi.ResolvePath(yPath)
+	if errs != nil {
+		t.Fatalf("Could not resolve the ygot path; %v", errs)
+	}
+	js, err := ygot.Marshal7951(val, ygot.JSONIndent("  "), &ygot.RFC7951JSONConfig{AppendModuleName: true, PreferShadowPath: true})
+	if err != nil {
+		t.Fatalf("Could not encode value into JSON format: %v", err)
+	}
+	return &gpb.Update{
+		Path: path,
+		Val: &gpb.TypedValue{
+			Value: &gpb.TypedValue_JsonIetfVal{
+				JsonIetfVal: js,
+			},
+		},
+	}
+}
