diff --git a/feature/gribi/ate_tests/cisco/transit_wecmp_flush/transit_wecmp_flush_test.go b/feature/gribi/ate_tests/cisco/transit_wecmp_flush/transit_wecmp_flush_test.go
index 40dbcdc6..2982eda3 100755
--- a/feature/gribi/ate_tests/cisco/transit_wecmp_flush/transit_wecmp_flush_test.go
+++ b/feature/gribi/ate_tests/cisco/transit_wecmp_flush/transit_wecmp_flush_test.go
@@ -51,7 +51,7 @@ func testChangeFlowSpecToPBR(t *testing.T, args *testArgs) {
        configToChange := "no flowspec \nhw-module profile pbr vrf-redirect\n"
        config.Reload(args.ctx, t, args.dut, configToChange, "", 6*time.Minute)
        configbasePBR(t, args.dut)
-       args.dut.Config().NetworkInstance("default").PolicyForwarding().Interface("Bundle-Ether120").ApplyVrfSelectionPolicy().Update(t, pbrName)
+       args.dut.Config().NetworkInstance(*ciscoFlags.PbrInstance).PolicyForwarding().Interface("Bundle-Ether120").ApplyVrfSelectionPolicy().Update(t, pbrName)
 }
 
 func testCD2ConnectedNHIP(t *testing.T, args *testArgs) {
@@ -457,8 +457,8 @@ func testTwoPrefixesWithSameSetOfPrimaryAndBackup(t *testing.T, args *testArgs)
        args.topology.StartProtocols(t)
        defer args.topology.StopProtocols(t)
 
-       dscp16Flow := getDSCPFlow(t, portMaps, args.ate, "DSCP16", 1, 16, "12.11.11.12", "1/3")
-       dscp10Flow := getDSCPFlow(t, portMaps, args.ate, "DSCP10", 1, 10, "12.11.11.11", "1/2")
+       dscp16Flow := getDSCPFlow(t, portMaps, args.ate, "DSCP16", 1, 16, "12.11.11.12", "1/19")
+       dscp10Flow := getDSCPFlow(t, portMaps, args.ate, "DSCP10", 1, 10, "12.11.11.11", "1/18")
 
        checkTrafficFlows(t, args.ate, 60, dscp16Flow, dscp10Flow)
 }
@@ -485,10 +485,10 @@ func testSameForwardingEntriesAcrossMultipleVrfs(t *testing.T, args *testArgs) {
        args.topology.StartProtocols(t)
        defer args.topology.StopProtocols(t)
 
-       dscp16FlowVrfTE := getDSCPFlow(t, portMaps, args.ate, "DSCP16_vrf_TE", 1, 16, "12.11.11.12", "1/3")
-       dscp10FlowVrfTE := getDSCPFlow(t, portMaps, args.ate, "DSCP10_vrf_TE", 1, 10, "12.11.11.11", "1/2")
-       dscp18Flow1VrfVRF1 := getDSCPFlow(t, portMaps, args.ate, "DSCP16_vrf_VRF1", 1, 18, "12.11.11.12", "1/3")
-       dscp18Flow2VrfVRF1 := getDSCPFlow(t, portMaps, args.ate, "DSCP10_vrf_VRF1", 1, 18, "12.11.11.11", "1/2")
+       dscp16FlowVrfTE := getDSCPFlow(t, portMaps, args.ate, "DSCP16_vrf_TE", 1, 16, "12.11.11.12", "1/19")
+       dscp10FlowVrfTE := getDSCPFlow(t, portMaps, args.ate, "DSCP10_vrf_TE", 1, 10, "12.11.11.11", "1/18")
+       dscp18Flow1VrfVRF1 := getDSCPFlow(t, portMaps, args.ate, "DSCP16_vrf_VRF1", 1, 18, "12.11.11.12", "1/19")
+       dscp18Flow2VrfVRF1 := getDSCPFlow(t, portMaps, args.ate, "DSCP10_vrf_VRF1", 1, 18, "12.11.11.11", "1/18")
 
        checkTrafficFlows(t, args.ate, 60, dscp16FlowVrfTE, dscp10FlowVrfTE, dscp18Flow1VrfVRF1, dscp18Flow2VrfVRF1)
 }
@@ -1164,8 +1164,8 @@ func testIsisBgpControlPlaneInteractionWithGribi(t *testing.T, args *testArgs) {
        args.c1.AddIPv4Batch(t, prefixes, 1, *ciscoFlags.NonDefaultNetworkInstance, *ciscoFlags.DefaultNetworkInstance, false, ciscoFlags.GRIBIChecks)
 
        //Generate flows over ISIS and BGP sessions.
-       isisFlow := util.GetBoundedFlow(t, args.ate, args.topology, "1/1", "1/2", "isis_network1", "isis_network2", "isis", 16)
-       bgpFlow := util.GetBoundedFlow(t, args.ate, args.topology, "1/1", "1/2", "bgp_network", "bgp_network", "bgp", 16)
+       isisFlow := util.GetBoundedFlow(t, args.ate, args.topology, "1/17", "1/18", "isis_network1", "isis_network2", "isis", 16)
+       bgpFlow := util.GetBoundedFlow(t, args.ate, args.topology, "1/17", "1/18", "bgp_network", "bgp_network", "bgp", 16)
        scaleFlow := getScaleFlow(t, args.topology.Interfaces(), args.ate, "IPinIPWithScale", int(*ciscoFlags.GRIBIScale))
        // Configure ATE and Verify traffic
        performATEActionForMultipleFlows(t, "ate", true, 0.90, isisFlow, bgpFlow, scaleFlow)
@@ -1209,7 +1209,7 @@ func testBgpProtocolOverGribiTransitEntry(t *testing.T, args *testArgs) {
 
        //Configure BGP on TGN
        //Generate DSCP48 flow
-       bgpFlow := util.GetBoundedFlow(t, args.ate, args.topology, "1/1", "1/2", "bgp_transit_network", "bgp_transit_network", "bgp", 48)
+       bgpFlow := util.GetBoundedFlow(t, args.ate, args.topology, "1/17", "1/18", "bgp_transit_network", "bgp_transit_network", "bgp", 48)
 
        // Configure ATE and Verify traffic
        performATEActionForMultipleFlows(t, "ate", true, 0.99, bgpFlow)
        //flow with dscp=48, ttl=100
-       dscpTTLFlow := util.GetBoundedFlow(t, args.ate, args.topology, "1/1", "1/2", "network101", "network102", "dscpTtlFlow", 48, 100)
+       dscpTTLFlow := util.GetBoundedFlow(t, args.ate, args.topology, "1/17", "1/18", "network101", "network102", "dscpTtlFlow", 48, 100)
        //add acl with dscp=48, ttl=99. Transit traffic will have ttl decremented by 1
        aclName := "ttl_dscp"
        aclConfig := util.GetIpv4Acl(aclName, 10, 48, 99, telemetry.Acl_FORWARDING_ACTION_ACCEPT)
@@ -2000,11 +2000,11 @@ func TestTransitWECMPFlush(t *testing.T) {
                desc string
                fn   func(t *testing.T, args *testArgs)
        }{
-               {
-                       name: "TestAddPBR",
-                       desc: "ADD PBR", // make sure that PBR is added and no flowspec config is not in router
-                       fn:   testChangeFlowSpecToPBR,
-               },
+               // {
+               //      name: "TestAddPBR",
+               //      desc: "ADD PBR", // make sure that PBR is added and no flowspec config is not in router
+               //      fn:   testChangeFlowSpecToPBR,
+               // },
                {
                        name: "CD2ConnectedNHIP",
                        desc: "Transit Connected nexthop",



diff --git a/feature/gribi/ate_tests/cisco/transit_wecmp_flush/traffic_test.go b/feature/gribi/ate_tests/cisco/transit_wecmp_flush/traffic_test.go
index ce875d64..2ea92a54 100755
--- a/feature/gribi/ate_tests/cisco/transit_wecmp_flush/traffic_test.go
+++ b/feature/gribi/ate_tests/cisco/transit_wecmp_flush/traffic_test.go
@@ -44,9 +44,9 @@ func generateBaseScenario(t *testing.T, ate *ondatra.ATEDevice, topoobj *ondatra
        for _, p := range ate.Device.Ports() {
                intf := topoobj.AddInterface(p.Name())
                intf.WithPort(ate.Port(t, p.ID()))
-               for i := 0; i < 9; i++ {
+               for i := 16; i < 9+16; i++ {
                        if fmt.Sprintf("1/%d", i+1) == p.Name() {
-                               intf.IPv4().WithAddress(fmt.Sprintf("100.%d.1.2/24", 120+i)).WithDefaultGateway(fmt.Sprintf("100.%d.1.1", 120+i))
+                               intf.IPv4().WithAddress(fmt.Sprintf("100.%d.1.2/24", 104+i)).WithDefaultGateway(fmt.Sprintf("100.%d.1.1", 104+i))
                        }
                }
        }
@@ -56,27 +56,27 @@ func generateBaseScenario(t *testing.T, ate *ondatra.ATEDevice, topoobj *ondatra
 func addNetworkAndProtocolsToAte(t *testing.T, ate *ondatra.ATEDevice, topo *ondatra.ATETopology) {
        //Add prefixes/networks on ports
        scale := uint32(10)
-       util.AddIpv4Network(t, topo, "1/1", "network101", "101.1.1.1/32", scale)
-       util.AddIpv4Network(t, topo, "1/2", "network102", "102.1.1.1/32", scale)
+       util.AddIpv4Network(t, topo, "1/17", "network101", "101.1.1.1/32", scale)
+       util.AddIpv4Network(t, topo, "1/18", "network102", "102.1.1.1/32", scale)
        //Configure ISIS, BGP on TGN
-       util.AddAteISISL2(t, topo, "1/1", "490001", "isis_network1", 20, "120.1.1.1/32", scale)
-       util.AddAteISISL2(t, topo, "1/2", "490002", "isis_network2", 20, "121.1.1.1/32", scale)
-       util.AddAteEBGPPeer(t, topo, "1/1", "100.120.1.1", 64001, "bgp_network", "100.120.0.2", "130.1.1.1/32", scale, false)
-       util.AddAteEBGPPeer(t, topo, "1/2", "100.121.1.1", 64001, "bgp_network", "100.121.0.2", "131.1.1.1/32", scale, false)
+       util.AddAteISISL2(t, topo, "1/17", "490001", "isis_network1", 20, "120.1.1.1/32", scale)
+       util.AddAteISISL2(t, topo, "1/18", "490002", "isis_network2", 20, "121.1.1.1/32", scale)
+       util.AddAteEBGPPeer(t, topo, "1/17", "100.120.1.1", 64001, "bgp_network", "100.120.0.2", "130.1.1.1/32", scale, false)
+       util.AddAteEBGPPeer(t, topo, "1/18", "100.121.1.1", 64001, "bgp_network", "100.121.0.2", "131.1.1.1/32", scale, false)
        //Configure loopbacks for BGP to use as source addresses
-       util.AddLoopback(t, topo, "1/1", "11.11.11.1/32")
-       util.AddLoopback(t, topo, "1/2", "12.12.12.1/32")
+       util.AddLoopback(t, topo, "1/17", "11.11.11.1/32")
+       util.AddLoopback(t, topo, "1/18", "12.12.12.1/32")
        //BGP instance for traffic over gRIBI transit forwarding entries
        //BGP uses DSCP48 for control traffic. Router needs to be configured to handle DSCP48 accordingly.
-       util.AddAteEBGPPeer(t, topo, "1/1", "12.12.12.1", 64001, "bgp_transit_network", "100.121.0.2", "11.11.11.1/32", 1, true)
-       util.AddAteEBGPPeer(t, topo, "1/2", "11.11.11.1", 64002, "bgp_transit_network", "100.122.0.2", "12.12.12.1/32", 1, true)
+       util.AddAteEBGPPeer(t, topo, "1/17", "12.12.12.1", 64001, "bgp_transit_network", "100.121.0.2", "11.11.11.1/32", 1, true)
+       util.AddAteEBGPPeer(t, topo, "1/18", "11.11.11.1", 64002, "bgp_transit_network", "100.122.0.2", "12.12.12.1/32", 1, true)
 }
 
 func getBaseFlow(t *testing.T, atePorts map[string]*ondatra.Interface, ate *ondatra.ATEDevice, flowName string, vrf ...string) *ondatra.Flow {
        flow := ate.Traffic().NewFlow(flowName)
        t.Log("Setting up base flow...")
-       srcPort := "1/1"
-       dstPort := "1/2"
+       srcPort := "1/17"
+       dstPort := "1/18"
        flow.WithSrcEndpoints(atePorts[srcPort])
        flow.WithDstEndpoints(atePorts[dstPort])
        ethheader := ondatra.NewEthernetHeader()
@@ -101,11 +101,11 @@ func getBaseFlow(t *testing.T, atePorts map[string]*ondatra.Interface, ate *onda
 func getScaleFlow(t *testing.T, atePorts map[string]*ondatra.Interface, ate *ondatra.ATEDevice, flowName string, scale int, vrf ...string) *ondatra.Flow {
        flow := ate.Traffic().NewFlow(flowName)
        t.Log("Setting up scale flow...")
-       flow.WithSrcEndpoints(atePorts["1/1"])
+       flow.WithSrcEndpoints(atePorts["1/17"])
 
        t.Log("Extending to multiple receiver ports...")
        rxPorts := []ondatra.Endpoint{}
-       for i := 1; i < 9; i++ {
+       for i := 18; i < 8+17; i++ {
                rxPorts = append(rxPorts, atePorts[fmt.Sprintf("1/%d", i)])
        }
        flow.WithDstEndpoints(rxPorts...)
@@ -169,7 +169,7 @@ func performATEActionForMultipleFlows(t *testing.T, ateName string, expectPass b
 func getDSCPFlow(t *testing.T, atePorts map[string]*ondatra.Interface, ate *ondatra.ATEDevice, flowName string, scale int, dscp uint8, dstAddress string, rxPort string) *ondatra.Flow {
        flow := ate.Traffic().NewFlow(flowName)
        t.Log("Setting up flow -> ", flowName)
-       flow.WithSrcEndpoints(atePorts["1/1"])
+       flow.WithSrcEndpoints(atePorts["1/17"])
        flow.WithDstEndpoints(atePorts[rxPort])
        ethheader := ondatra.NewEthernetHeader()
        ethheader.WithSrcAddress("00:11:01:00:00:01")


diff --git a/feature/gribi/ate_tests/cisco/transit_wecmp_flush/pbr_setup.go b/feature/gribi/ate_tests/cisco/transit_wecmp_flush/pbr_setup.go
index 05e8e9b4..9242b326 100755
--- a/feature/gribi/ate_tests/cisco/transit_wecmp_flush/pbr_setup.go
+++ b/feature/gribi/ate_tests/cisco/transit_wecmp_flush/pbr_setup.go
@@ -18,6 +18,7 @@ package transitwecmpflush_test
 import (
        "testing"
 
+       ciscoFlags "github.com/openconfig/featureprofiles/internal/cisco/flags"
        "github.com/openconfig/ondatra"
        "github.com/openconfig/ondatra/telemetry"
        "github.com/openconfig/ygot/ygot"
@@ -64,5 +65,5 @@ func configbasePBR(t *testing.T, dut *ondatra.DUTDevice) {
        policy := telemetry.NetworkInstance_PolicyForwarding{}
        policy.Policy = map[string]*telemetry.NetworkInstance_PolicyForwarding_Policy{pbrName: &p}
 
-       dut.Config().NetworkInstance("default").PolicyForwarding().Replace(t, &policy)
+       dut.Config().NetworkInstance(*ciscoFlags.PbrInstance).PolicyForwarding().Replace(t, &policy)
 }
