diff --git a/feature/bgp/prefixlimit/ate_tests/bgp_prefix_limit_test/bgp_prefix_limit_test.go b/feature/bgp/prefixlimit/ate_tests/bgp_prefix_limit_test/bgp_prefix_limit_test.go
index 99b650e..7ad74a7 100644
--- a/feature/bgp/prefixlimit/ate_tests/bgp_prefix_limit_test/bgp_prefix_limit_test.go
+++ b/feature/bgp/prefixlimit/ate_tests/bgp_prefix_limit_test/bgp_prefix_limit_test.go
@@ -66,6 +66,9 @@ const (
 	plenIPv6               = 126
 	tolerance              = 50
 	lossTolerance          = 2
+	routerID               = "192.0.2.9"
+	rplType                = telemetry.RoutingPolicy_PolicyResultType_ACCEPT_ROUTE
+	rplName                = "ALLOW"
 )
 
 var (
@@ -112,13 +115,15 @@ func configureDUT(t *testing.T, dut *ondatra.DUTDevice) {
 	i2 := dutDst.NewInterface(p2)
 	dc.Interface(p2).Replace(t, i2)
 
+	configureRoutePolicy(t, dut, rplName, rplType)
 	dutConfPath := dc.NetworkInstance(*deviations.DefaultNetworkInstance).Protocol(telemetry.PolicyTypes_INSTALL_PROTOCOL_TYPE_BGP, "BGP").Bgp()
 	dutConf := createBGPNeighbor(dutAS, ateAS, prefixLimit, grRestartTime)
 	dutConfPath.Replace(t, dutConf)
 }
 
 func (tc *testCase) verifyPortsUp(t *testing.T, dev *ondatra.Device) {
-	for _, p := range dev.Ports() {
+	// for _, p := range dev.Ports() {
+	for _, p := range []*ondatra.Port{dev.Port(t, "port1"), dev.Port(t, "port2")} {
 		portStatus := dev.Telemetry().Interface(p.Name()).OperStatus().Get(t)
 		if want := telemetry.Interface_OperStatus_UP; portStatus != want {
 			t.Errorf("%s Status: got %v, want %v", p, portStatus, want)
@@ -217,31 +222,49 @@ func createBGPNeighbor(localAs, peerAs, pLimit uint32, restartTime uint16) *tele
 	bgp := ni1.GetOrCreateProtocol(telemetry.PolicyTypes_INSTALL_PROTOCOL_TYPE_BGP, "BGP").GetOrCreateBgp()
 	global := bgp.GetOrCreateGlobal()
 	global.As = ygot.Uint32(localAs)
+	global.GetOrCreateAfiSafi(telemetry.BgpTypes_AFI_SAFI_TYPE_IPV4_UNICAST).Enabled = ygot.Bool(true)
+	global.GetOrCreateAfiSafi(telemetry.BgpTypes_AFI_SAFI_TYPE_IPV6_UNICAST).Enabled = ygot.Bool(true)
+	global.RouterId = ygot.String(routerID)
 
 	for _, nbr := range nbrs {
 		if nbr.isV4 {
 			nv4 := bgp.GetOrCreateNeighbor(nbr.neighborip)
 			nv4.PeerAs = ygot.Uint32(nbr.as)
 			nv4.Enabled = ygot.Bool(true)
-			nv4.GetOrCreateTimers().RestartTime = ygot.Uint16(restartTime)
+			// nv4.GetOrCreateTimers().RestartTime = ygot.Uint16(restartTime)
 			afisafi := nv4.GetOrCreateAfiSafi(telemetry.BgpTypes_AFI_SAFI_TYPE_IPV4_UNICAST)
 			afisafi.Enabled = ygot.Bool(true)
 			prefixLimit := afisafi.GetOrCreateIpv4Unicast().GetOrCreatePrefixLimit()
 			prefixLimit.MaxPrefixes = ygot.Uint32(nbr.pfxLimit)
+			rpl := afisafi.GetOrCreateApplyPolicy()
+			rpl.ImportPolicy = []string{rplName}
+			rpl.ExportPolicy = []string{rplName}
 		} else {
 			nv6 := bgp.GetOrCreateNeighbor(nbr.neighborip)
 			nv6.PeerAs = ygot.Uint32(nbr.as)
 			nv6.Enabled = ygot.Bool(true)
-			nv6.GetOrCreateTimers().RestartTime = ygot.Uint16(restartTime)
+			// nv6.GetOrCreateTimers().RestartTime = ygot.Uint16(restartTime)
 			afisafi6 := nv6.GetOrCreateAfiSafi(telemetry.BgpTypes_AFI_SAFI_TYPE_IPV6_UNICAST)
 			afisafi6.Enabled = ygot.Bool(true)
 			prefixLimit6 := afisafi6.GetOrCreateIpv6Unicast().GetOrCreatePrefixLimit()
 			prefixLimit6.MaxPrefixes = ygot.Uint32(nbr.pfxLimit)
+			rpl := afisafi6.GetOrCreateApplyPolicy()
+			rpl.ImportPolicy = []string{rplName}
+			rpl.ExportPolicy = []string{rplName}
 		}
 	}
 	return bgp
 }
 
+func configureRoutePolicy(t *testing.T, dut *ondatra.DUTDevice, name string, pr telemetry.E_RoutingPolicy_PolicyResultType) {
+	d := &telemetry.Device{}
+	rp := d.GetOrCreateRoutingPolicy()
+	pd := rp.GetOrCreatePolicyDefinition(name)
+	st := pd.GetOrCreateStatement("id-1")
+	st.GetOrCreateActions().PolicyResult = pr //telemetry.RoutingPolicy_PolicyResultType_ACCEPT_ROUTE
+	dut.Config().RoutingPolicy().Replace(t, rp)
+}
+
 func waitForBGPSession(t *testing.T, dut *ondatra.DUTDevice, wantEstablished bool) {
 	statePath := dut.Telemetry().NetworkInstance(*deviations.DefaultNetworkInstance).Protocol(telemetry.PolicyTypes_INSTALL_PROTOCOL_TYPE_BGP, "BGP").Bgp()
 	nbrPath := statePath.Neighbor(ateDst.IPv4)
@@ -279,26 +302,30 @@ func waitForBGPSession(t *testing.T, dut *ondatra.DUTDevice, wantEstablished boo
 func verifyPrefixLimitTelemetry(t *testing.T, n *telemetry.NetworkInstance_Protocol_Bgp_Neighbor, wantEstablished bool) {
 	t.Run("verifyPrefixLimitTelemetry", func(t *testing.T) {
 		// TODO: Remove skip when Telemetry Parameters are supported
-		t.Skip("Skipped since Telemetry parameters are not supported")
-		plv4 := n.GetAfiSafi(telemetry.BgpTypes_AFI_SAFI_TYPE_IPV4_UNICAST).GetIpv4Unicast().GetPrefixLimit()
-		plv6 := n.GetAfiSafi(telemetry.BgpTypes_AFI_SAFI_TYPE_IPV6_UNICAST).GetIpv6Unicast().GetPrefixLimit()
-
-		maxPrefix := plv4.GetMaxPrefixes()
-		limitExceeded := plv4.GetPrefixLimitExceeded()
-		if maxPrefix != prefixLimit {
-			t.Errorf("PrefixLimit max-prefixes v4 mismatch: got %d, want %d", maxPrefix, prefixLimit)
-		}
-		if (wantEstablished && limitExceeded) || (!wantEstablished && !limitExceeded) {
-			t.Errorf("PrefixLimitExceeded v4 mismatch: got %t, want %t", limitExceeded, !wantEstablished)
-		}
+		//t.Skip("Skipped since Telemetry parameters are not supported")
 
-		maxPrefix = plv6.GetMaxPrefixes()
-		limitExceeded = plv6.GetPrefixLimitExceeded()
-		if maxPrefix != prefixLimit {
-			t.Errorf("PrefixLimit max-prefixes v6 mismatch: got %d, want %d", maxPrefix, prefixLimit)
-		}
-		if (wantEstablished && limitExceeded) || (!wantEstablished && !limitExceeded) {
-			t.Errorf("PrefixLimitExceeded v6 mismatch: got %t, want %t", limitExceeded, !wantEstablished)
+		if n.NeighborAddress == &ateDst.IPv4 {
+			plv4 := n.GetAfiSafi(telemetry.BgpTypes_AFI_SAFI_TYPE_IPV4_UNICAST).GetIpv4Unicast().GetPrefixLimit()
+
+			maxPrefix := plv4.GetMaxPrefixes()
+			limitExceeded := plv4.GetPrefixLimitExceeded()
+			if maxPrefix != prefixLimit {
+				t.Errorf("PrefixLimit max-prefixes v4 mismatch: got %d, want %d", maxPrefix, prefixLimit)
+			}
+			if (wantEstablished && limitExceeded) || (!wantEstablished && !limitExceeded) {
+				t.Errorf("PrefixLimitExceeded v4 mismatch: got %t, want %t", limitExceeded, !wantEstablished)
+			}
+		} else if n.NeighborAddress == &ateDst.IPv6 {
+			plv6 := n.GetAfiSafi(telemetry.BgpTypes_AFI_SAFI_TYPE_IPV6_UNICAST).GetIpv6Unicast().GetPrefixLimit()
+
+			maxPrefix := plv6.GetMaxPrefixes()
+			limitExceeded := plv6.GetPrefixLimitExceeded()
+			if maxPrefix != prefixLimit {
+				t.Errorf("PrefixLimit max-prefixes v6 mismatch: got %d, want %d", maxPrefix, prefixLimit)
+			}
+			if (wantEstablished && limitExceeded) || (!wantEstablished && !limitExceeded) {
+				t.Errorf("PrefixLimitExceeded v6 mismatch: got %t, want %t", limitExceeded, !wantEstablished)
+			}
 		}
 	})
 }
@@ -412,6 +439,18 @@ func configureBGPRoutes(t *testing.T, topo *ondatra.ATETopology, allNets []*ixne
 	topo.UpdateNetworks(t)
 }
 
+func workaroundBgpFlap(t *testing.T, dut *ondatra.DUTDevice) {
+	config := dut.Config().NetworkInstance(*deviations.DefaultNetworkInstance).Protocol(telemetry.PolicyTypes_INSTALL_PROTOCOL_TYPE_BGP, "BGP").Bgp()
+	config.Neighbor(ateDst.IPv4).Delete(t)
+	config.Neighbor(ateDst.IPv6).Delete(t)
+	config.Neighbor(ateSrc.IPv4).Delete(t)
+	config.Neighbor(ateSrc.IPv6).Delete(t)
+
+	dutConf := createBGPNeighbor(dutAS, ateAS, prefixLimit, grRestartTime)
+	config.Replace(t, dutConf)
+
+}
+
 type testCase struct {
 	desc             string
 	name             string
@@ -423,6 +462,12 @@ type testCase struct {
 func (tc *testCase) run(t *testing.T, conf *config, dut *ondatra.DUTDevice, ate *ondatra.ATEDevice) {
 	t.Log(tc.desc)
 	configureBGPRoutes(t, conf.topo, conf.allNets, tc.numRoutes)
+
+	// Remove when RestartTime is fixed
+	if tc.name == "ReestablishedAtLimit" {
+		workaroundBgpFlap(t, dut)
+	}
+
 	// Verify Port Status
 	t.Log(" Verifying port status")
 	t.Run("verifyPortsUp", func(t *testing.T) {
@@ -447,6 +492,7 @@ func (tc *testCase) run(t *testing.T, conf *config, dut *ondatra.DUTDevice, ate
 			tc.verifyPacketLoss(t, ate, conf.allFlows)
 		})
 	}
+
 }
 
 func TestTrafficBGPPrefixLimit(t *testing.T) {
