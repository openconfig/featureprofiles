/*
Package fpoc is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /usr/local/google/home/sthesayi/go/pkg/mod/github.com/openconfig/ygot@v0.23.1/genutil/names.go
using the following YANG input files:
  - google-bgp-timers.yang
  - public/release/models/acl/openconfig-acl.yang
  - public/release/models/acl/openconfig-packet-match.yang
  - public/release/models/bgp/openconfig-bgp-policy.yang
  - public/release/models/bgp/openconfig-bgp-types.yang
  - public/release/models/interfaces/openconfig-if-aggregate.yang
  - public/release/models/interfaces/openconfig-if-ethernet.yang
  - public/release/models/interfaces/openconfig-if-ip-ext.yang
  - public/release/models/interfaces/openconfig-if-ip.yang
  - public/release/models/interfaces/openconfig-if-sdn-ext.yang
  - public/release/models/interfaces/openconfig-if-tunnel.yang
  - public/release/models/interfaces/openconfig-interfaces.yang
  - public/release/models/isis/openconfig-isis.yang
  - public/release/models/lacp/openconfig-lacp.yang
  - public/release/models/lldp/openconfig-lldp-types.yang
  - public/release/models/lldp/openconfig-lldp.yang
  - public/release/models/local-routing/openconfig-local-routing.yang
  - public/release/models/macsec/openconfig-macsec.yang
  - public/release/models/mpls/openconfig-mpls-types.yang
  - public/release/models/network-instance/openconfig-network-instance.yang
  - public/release/models/openconfig-extensions.yang
  - public/release/models/p4rt/openconfig-p4rt.yang
  - public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
  - public/release/models/policy/openconfig-policy-types.yang
  - public/release/models/policy/openconfig-routing-policy.yang
  - public/release/models/platform/openconfig-platform.yang
  - public/release/models/platform/openconfig-platform-port.yang
  - public/release/models/qos/openconfig-qos-elements.yang
  - public/release/models/qos/openconfig-qos-interfaces.yang
  - public/release/models/qos/openconfig-qos-types.yang
  - public/release/models/qos/openconfig-qos.yang
  - public/release/models/relay-agent/openconfig-relay-agent.yang
  - public/release/models/sampling/openconfig-sampling-sflow.yang
  - public/release/models/stp/openconfig-spanning-tree.yang
  - public/release/models/system/openconfig-aaa.yang
  - public/release/models/system/openconfig-aaa-types.yang
  - public/release/models/system/openconfig-system.yang
  - public/release/models/types/openconfig-inet-types.yang
  - public/release/models/types/openconfig-types.yang
  - public/release/models/types/openconfig-yang-types.yang
  - public/release/models/vlan/openconfig-vlan.yang
  - public/third_party/ietf/iana-if-type.yang
  - public/third_party/ietf/ietf-inet-types.yang
  - public/third_party/ietf/ietf-interfaces.yang
  - public/third_party/ietf/ietf-yang-types.yang

Imported modules were sourced from:
  - public/release/models/...
  - public/third_party/ietf/...
*/
package fpoc

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Device{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// Acl represents the /openconfig-acl/acl YANG schema element.
type Acl struct {
	AclSet            map[Acl_AclSet_Key]*Acl_AclSet `path:"acl-sets/acl-set" module:"openconfig-acl/openconfig-acl"`
	CounterCapability E_Acl_ACL_COUNTER_CAPABILITY   `path:"state/counter-capability" module:"openconfig-acl/openconfig-acl"`
	Interface         map[string]*Acl_Interface      `path:"interfaces/interface" module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl) IsYANGGoStruct() {}

// Acl_AclSet_Key represents the key for list AclSet of element /openconfig-acl/acl.
type Acl_AclSet_Key struct {
	Name string         `path:"name"`
	Type E_Acl_ACL_TYPE `path:"type"`
}

// NewAclSet creates a new entry in the AclSet list of the
// Acl struct. The keys of the list are populated from the input
// arguments.
func (t *Acl) NewAclSet(Name string, Type E_Acl_ACL_TYPE) (*Acl_AclSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclSet == nil {
		t.AclSet = make(map[Acl_AclSet_Key]*Acl_AclSet)
	}

	key := Acl_AclSet_Key{
		Name: Name,
		Type: Type,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AclSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AclSet", key)
	}

	t.AclSet[key] = &Acl_AclSet{
		Name: &Name,
		Type: Type,
	}

	return t.AclSet[key], nil
}

// RenameAclSet renames an entry in the list AclSet within
// the Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl) RenameAclSet(oldK, newK Acl_AclSet_Key) error {
	if _, ok := t.AclSet[newK]; ok {
		return fmt.Errorf("key %v already exists in AclSet", newK)
	}

	e, ok := t.AclSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AclSet", oldK)
	}
	e.Name = &newK.Name
	e.Type = newK.Type

	t.AclSet[newK] = e
	delete(t.AclSet, oldK)
	return nil
}

// GetOrCreateAclSet retrieves the value with the specified keys from
// the receiver Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl) GetOrCreateAclSet(Name string, Type E_Acl_ACL_TYPE) *Acl_AclSet {

	key := Acl_AclSet_Key{
		Name: Name,
		Type: Type,
	}

	if v, ok := t.AclSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAclSet(Name, Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAclSet got unexpected error: %v", err))
	}
	return v
}

// GetAclSet retrieves the value with the specified key from
// the AclSet map field of Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl) GetAclSet(Name string, Type E_Acl_ACL_TYPE) *Acl_AclSet {

	if t == nil {
		return nil
	}

	key := Acl_AclSet_Key{
		Name: Name,
		Type: Type,
	}

	if lm, ok := t.AclSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteAclSet deletes the value with the specified keys from
// the receiver Acl. If there is no such element, the function
// is a no-op.
func (t *Acl) DeleteAclSet(Name string, Type E_Acl_ACL_TYPE) {
	key := Acl_AclSet_Key{
		Name: Name,
		Type: Type,
	}

	delete(t.AclSet, key)
}

// AppendAclSet appends the supplied Acl_AclSet struct to the
// list AclSet of Acl. If the key value(s) specified in
// the supplied Acl_AclSet already exist in the list, an error is
// returned.
func (t *Acl) AppendAclSet(v *Acl_AclSet) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key for Name")
	}

	key := Acl_AclSet_Key{
		Name: *v.Name,
		Type: v.Type,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclSet == nil {
		t.AclSet = make(map[Acl_AclSet_Key]*Acl_AclSet)
	}

	if _, ok := t.AclSet[key]; ok {
		return fmt.Errorf("duplicate key for list AclSet %v", key)
	}

	t.AclSet[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Acl struct. The keys of the list are populated from the input
// arguments.
func (t *Acl) NewInterface(Id string) (*Acl_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Acl_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Acl_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl) GetOrCreateInterface(Id string) *Acl_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl) GetInterface(Id string) *Acl_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Acl. If there is no such element, the function
// is a no-op.
func (t *Acl) DeleteInterface(Id string) {
	key := Id

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Acl_Interface struct to the
// list Interface of Acl. If the key value(s) specified in
// the supplied Acl_Interface already exist in the list, an error is
// returned.
func (t *Acl) AppendInterface(v *Acl_Interface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Acl_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetCounterCapability retrieves the value of the leaf CounterCapability from the Acl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CounterCapability is set, it can
// safely use t.GetCounterCapability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CounterCapability == nil' before retrieving the leaf's value.
func (t *Acl) GetCounterCapability() E_Acl_ACL_COUNTER_CAPABILITY {
	if t == nil || t.CounterCapability == 0 {
		return 0
	}
	return t.CounterCapability
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl.
func (*Acl) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet represents the /openconfig-acl/acl/acl-sets/acl-set YANG schema element.
type Acl_AclSet struct {
	AclEntry    map[uint32]*Acl_AclSet_AclEntry `path:"acl-entries/acl-entry" module:"openconfig-acl/openconfig-acl"`
	Description *string                         `path:"config/description" module:"openconfig-acl/openconfig-acl" shadow-path:"state/description" shadow-module:"openconfig-acl/openconfig-acl"`
	Name        *string                         `path:"config/name|name" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"state/name|name" shadow-module:"openconfig-acl/openconfig-acl|openconfig-acl"`
	Type        E_Acl_ACL_TYPE                  `path:"config/type|type" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"state/type|type" shadow-module:"openconfig-acl/openconfig-acl|openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet) IsYANGGoStruct() {}

// NewAclEntry creates a new entry in the AclEntry list of the
// Acl_AclSet struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_AclSet) NewAclEntry(SequenceId uint32) (*Acl_AclSet_AclEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_AclSet_AclEntry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AclEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AclEntry", key)
	}

	t.AclEntry[key] = &Acl_AclSet_AclEntry{
		SequenceId: &SequenceId,
	}

	return t.AclEntry[key], nil
}

// RenameAclEntry renames an entry in the list AclEntry within
// the Acl_AclSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_AclSet) RenameAclEntry(oldK, newK uint32) error {
	if _, ok := t.AclEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in AclEntry", newK)
	}

	e, ok := t.AclEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AclEntry", oldK)
	}
	e.SequenceId = &newK

	t.AclEntry[newK] = e
	delete(t.AclEntry, oldK)
	return nil
}

// GetOrCreateAclEntry retrieves the value with the specified keys from
// the receiver Acl_AclSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_AclSet) GetOrCreateAclEntry(SequenceId uint32) *Acl_AclSet_AclEntry {

	key := SequenceId

	if v, ok := t.AclEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAclEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAclEntry got unexpected error: %v", err))
	}
	return v
}

// GetAclEntry retrieves the value with the specified key from
// the AclEntry map field of Acl_AclSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_AclSet) GetAclEntry(SequenceId uint32) *Acl_AclSet_AclEntry {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.AclEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteAclEntry deletes the value with the specified keys from
// the receiver Acl_AclSet. If there is no such element, the function
// is a no-op.
func (t *Acl_AclSet) DeleteAclEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.AclEntry, key)
}

// AppendAclEntry appends the supplied Acl_AclSet_AclEntry struct to the
// list AclEntry of Acl_AclSet. If the key value(s) specified in
// the supplied Acl_AclSet_AclEntry already exist in the list, an error is
// returned.
func (t *Acl_AclSet) AppendAclEntry(v *Acl_AclSet_AclEntry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_AclSet_AclEntry)
	}

	if _, ok := t.AclEntry[key]; ok {
		return fmt.Errorf("duplicate key for list AclEntry %v", key)
	}

	t.AclEntry[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the Acl_AclSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *Acl_AclSet) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the Acl_AclSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Acl_AclSet) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetType retrieves the value of the leaf Type from the Acl_AclSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Acl_AclSet) GetType() E_Acl_ACL_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the Acl_AclSet struct, which is a YANG list entry.
func (t *Acl_AclSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet.
func (*Acl_AclSet) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry YANG schema element.
type Acl_AclSet_AclEntry struct {
	Actions        *Acl_AclSet_AclEntry_Actions        `path:"actions" module:"openconfig-acl"`
	Description    *string                             `path:"config/description" module:"openconfig-acl/openconfig-acl" shadow-path:"state/description" shadow-module:"openconfig-acl/openconfig-acl"`
	InputInterface *Acl_AclSet_AclEntry_InputInterface `path:"input-interface" module:"openconfig-acl"`
	Ipv4           *Acl_AclSet_AclEntry_Ipv4           `path:"ipv4" module:"openconfig-acl"`
	Ipv6           *Acl_AclSet_AclEntry_Ipv6           `path:"ipv6" module:"openconfig-acl"`
	L2             *Acl_AclSet_AclEntry_L2             `path:"l2" module:"openconfig-acl"`
	MatchedOctets  *uint64                             `path:"state/matched-octets" module:"openconfig-acl/openconfig-acl"`
	MatchedPackets *uint64                             `path:"state/matched-packets" module:"openconfig-acl/openconfig-acl"`
	Mpls           *Acl_AclSet_AclEntry_Mpls           `path:"mpls" module:"openconfig-acl"`
	SequenceId     *uint32                             `path:"config/sequence-id|sequence-id" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"state/sequence-id|sequence-id" shadow-module:"openconfig-acl/openconfig-acl|openconfig-acl"`
	Transport      *Acl_AclSet_AclEntry_Transport      `path:"transport" module:"openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry) IsYANGGoStruct() {}

// GetOrCreateActions retrieves the value of the Actions field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateActions() *Acl_AclSet_AclEntry_Actions {
	if t.Actions != nil {
		return t.Actions
	}
	t.Actions = &Acl_AclSet_AclEntry_Actions{}
	return t.Actions
}

// GetOrCreateInputInterface retrieves the value of the InputInterface field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateInputInterface() *Acl_AclSet_AclEntry_InputInterface {
	if t.InputInterface != nil {
		return t.InputInterface
	}
	t.InputInterface = &Acl_AclSet_AclEntry_InputInterface{}
	return t.InputInterface
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateIpv4() *Acl_AclSet_AclEntry_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Acl_AclSet_AclEntry_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateIpv6() *Acl_AclSet_AclEntry_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Acl_AclSet_AclEntry_Ipv6{}
	return t.Ipv6
}

// GetOrCreateL2 retrieves the value of the L2 field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateL2() *Acl_AclSet_AclEntry_L2 {
	if t.L2 != nil {
		return t.L2
	}
	t.L2 = &Acl_AclSet_AclEntry_L2{}
	return t.L2
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateMpls() *Acl_AclSet_AclEntry_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &Acl_AclSet_AclEntry_Mpls{}
	return t.Mpls
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry) GetOrCreateTransport() *Acl_AclSet_AclEntry_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &Acl_AclSet_AclEntry_Transport{}
	return t.Transport
}

// GetActions returns the value of the Actions struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Actions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetActions() *Acl_AclSet_AclEntry_Actions {
	if t != nil && t.Actions != nil {
		return t.Actions
	}
	return nil
}

// GetInputInterface returns the value of the InputInterface struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field InputInterface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetInputInterface() *Acl_AclSet_AclEntry_InputInterface {
	if t != nil && t.InputInterface != nil {
		return t.InputInterface
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetIpv4() *Acl_AclSet_AclEntry_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetIpv6() *Acl_AclSet_AclEntry_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetL2 returns the value of the L2 struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field L2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetL2() *Acl_AclSet_AclEntry_L2 {
	if t != nil && t.L2 != nil {
		return t.L2
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetMpls() *Acl_AclSet_AclEntry_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from Acl_AclSet_AclEntry. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry) GetTransport() *Acl_AclSet_AclEntry_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the Acl_AclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetMatchedOctets retrieves the value of the leaf MatchedOctets from the Acl_AclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchedOctets is set, it can
// safely use t.GetMatchedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchedOctets == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry) GetMatchedOctets() uint64 {
	if t == nil || t.MatchedOctets == nil {
		return 0
	}
	return *t.MatchedOctets
}

// GetMatchedPackets retrieves the value of the leaf MatchedPackets from the Acl_AclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchedPackets is set, it can
// safely use t.GetMatchedPackets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchedPackets == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry) GetMatchedPackets() uint64 {
	if t == nil || t.MatchedPackets == nil {
		return 0
	}
	return *t.MatchedPackets
}

// GetSequenceId retrieves the value of the leaf SequenceId from the Acl_AclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// ΛListKeyMap returns the keys of the Acl_AclSet_AclEntry struct, which is a YANG list entry.
func (t *Acl_AclSet_AclEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry.
func (*Acl_AclSet_AclEntry) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry_Actions represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/actions YANG schema element.
type Acl_AclSet_AclEntry_Actions struct {
	ForwardingAction E_Acl_FORWARDING_ACTION `path:"config/forwarding-action" module:"openconfig-acl/openconfig-acl" shadow-path:"state/forwarding-action" shadow-module:"openconfig-acl/openconfig-acl"`
	LogAction        E_Acl_LOG_ACTION        `path:"config/log-action" module:"openconfig-acl/openconfig-acl" shadow-path:"state/log-action" shadow-module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry_Actions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry_Actions) IsYANGGoStruct() {}

// GetForwardingAction retrieves the value of the leaf ForwardingAction from the Acl_AclSet_AclEntry_Actions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingAction is set, it can
// safely use t.GetForwardingAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingAction == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Actions) GetForwardingAction() E_Acl_FORWARDING_ACTION {
	if t == nil || t.ForwardingAction == 0 {
		return 0
	}
	return t.ForwardingAction
}

// GetLogAction retrieves the value of the leaf LogAction from the Acl_AclSet_AclEntry_Actions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogAction is set, it can
// safely use t.GetLogAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogAction == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Actions) GetLogAction() E_Acl_LOG_ACTION {
	if t == nil || t.LogAction == 0 {
		return Acl_LOG_ACTION_LOG_NONE
	}
	return t.LogAction
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Actions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Actions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Actions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Actions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry_Actions.
func (*Acl_AclSet_AclEntry_Actions) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry_InputInterface represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/input-interface YANG schema element.
type Acl_AclSet_AclEntry_InputInterface struct {
	InterfaceRef *Acl_AclSet_AclEntry_InputInterface_InterfaceRef `path:"interface-ref" module:"openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry_InputInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry_InputInterface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Acl_AclSet_AclEntry_InputInterface) GetOrCreateInterfaceRef() *Acl_AclSet_AclEntry_InputInterface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Acl_AclSet_AclEntry_InputInterface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Acl_AclSet_AclEntry_InputInterface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_AclSet_AclEntry_InputInterface) GetInterfaceRef() *Acl_AclSet_AclEntry_InputInterface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_InputInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_InputInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_InputInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_InputInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry_InputInterface.
func (*Acl_AclSet_AclEntry_InputInterface) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry_InputInterface_InterfaceRef represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/input-interface/interface-ref YANG schema element.
type Acl_AclSet_AclEntry_InputInterface_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-acl/openconfig-acl" shadow-path:"state/interface" shadow-module:"openconfig-acl/openconfig-acl"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-acl/openconfig-acl" shadow-path:"state/subinterface" shadow-module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry_InputInterface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry_InputInterface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Acl_AclSet_AclEntry_InputInterface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_InputInterface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Acl_AclSet_AclEntry_InputInterface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_InputInterface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_InputInterface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_InputInterface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_InputInterface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_InputInterface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry_InputInterface_InterfaceRef.
func (*Acl_AclSet_AclEntry_InputInterface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry_Ipv4 represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/ipv4 YANG schema element.
type Acl_AclSet_AclEntry_Ipv4 struct {
	DestinationAddress *string                                 `path:"config/destination-address" module:"openconfig-acl/openconfig-acl" shadow-path:"state/destination-address" shadow-module:"openconfig-acl/openconfig-acl"`
	Dscp               *uint8                                  `path:"config/dscp" module:"openconfig-acl/openconfig-acl" shadow-path:"state/dscp" shadow-module:"openconfig-acl/openconfig-acl"`
	DscpSet            []uint8                                 `path:"config/dscp-set" module:"openconfig-acl/openconfig-acl" shadow-path:"state/dscp-set" shadow-module:"openconfig-acl/openconfig-acl"`
	HopLimit           *uint8                                  `path:"config/hop-limit" module:"openconfig-acl/openconfig-acl" shadow-path:"state/hop-limit" shadow-module:"openconfig-acl/openconfig-acl"`
	Protocol           Acl_AclSet_AclEntry_Ipv4_Protocol_Union `path:"config/protocol" module:"openconfig-acl/openconfig-acl" shadow-path:"state/protocol" shadow-module:"openconfig-acl/openconfig-acl"`
	SourceAddress      *string                                 `path:"config/source-address" module:"openconfig-acl/openconfig-acl" shadow-path:"state/source-address" shadow-module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry_Ipv4) IsYANGGoStruct() {}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the Acl_AclSet_AclEntry_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv4) GetDestinationAddress() string {
	if t == nil || t.DestinationAddress == nil {
		return ""
	}
	return *t.DestinationAddress
}

// GetDscp retrieves the value of the leaf Dscp from the Acl_AclSet_AclEntry_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv4) GetDscp() uint8 {
	if t == nil || t.Dscp == nil {
		return 0
	}
	return *t.Dscp
}

// GetDscpSet retrieves the value of the leaf DscpSet from the Acl_AclSet_AclEntry_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv4) GetDscpSet() []uint8 {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetHopLimit retrieves the value of the leaf HopLimit from the Acl_AclSet_AclEntry_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopLimit is set, it can
// safely use t.GetHopLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopLimit == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv4) GetHopLimit() uint8 {
	if t == nil || t.HopLimit == nil {
		return 0
	}
	return *t.HopLimit
}

// GetProtocol retrieves the value of the leaf Protocol from the Acl_AclSet_AclEntry_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv4) GetProtocol() Acl_AclSet_AclEntry_Ipv4_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the Acl_AclSet_AclEntry_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv4) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry_Ipv4.
func (*Acl_AclSet_AclEntry_Ipv4) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry_Ipv6 represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/ipv6 YANG schema element.
type Acl_AclSet_AclEntry_Ipv6 struct {
	DestinationAddress   *string                                 `path:"config/destination-address" module:"openconfig-acl/openconfig-acl" shadow-path:"state/destination-address" shadow-module:"openconfig-acl/openconfig-acl"`
	DestinationFlowLabel *uint32                                 `path:"config/destination-flow-label" module:"openconfig-acl/openconfig-acl" shadow-path:"state/destination-flow-label" shadow-module:"openconfig-acl/openconfig-acl"`
	Dscp                 *uint8                                  `path:"config/dscp" module:"openconfig-acl/openconfig-acl" shadow-path:"state/dscp" shadow-module:"openconfig-acl/openconfig-acl"`
	DscpSet              []uint8                                 `path:"config/dscp-set" module:"openconfig-acl/openconfig-acl" shadow-path:"state/dscp-set" shadow-module:"openconfig-acl/openconfig-acl"`
	HopLimit             *uint8                                  `path:"config/hop-limit" module:"openconfig-acl/openconfig-acl" shadow-path:"state/hop-limit" shadow-module:"openconfig-acl/openconfig-acl"`
	Protocol             Acl_AclSet_AclEntry_Ipv6_Protocol_Union `path:"config/protocol" module:"openconfig-acl/openconfig-acl" shadow-path:"state/protocol" shadow-module:"openconfig-acl/openconfig-acl"`
	SourceAddress        *string                                 `path:"config/source-address" module:"openconfig-acl/openconfig-acl" shadow-path:"state/source-address" shadow-module:"openconfig-acl/openconfig-acl"`
	SourceFlowLabel      *uint32                                 `path:"config/source-flow-label" module:"openconfig-acl/openconfig-acl" shadow-path:"state/source-flow-label" shadow-module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry_Ipv6) IsYANGGoStruct() {}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the Acl_AclSet_AclEntry_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv6) GetDestinationAddress() string {
	if t == nil || t.DestinationAddress == nil {
		return ""
	}
	return *t.DestinationAddress
}

// GetDestinationFlowLabel retrieves the value of the leaf DestinationFlowLabel from the Acl_AclSet_AclEntry_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationFlowLabel is set, it can
// safely use t.GetDestinationFlowLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationFlowLabel == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv6) GetDestinationFlowLabel() uint32 {
	if t == nil || t.DestinationFlowLabel == nil {
		return 0
	}
	return *t.DestinationFlowLabel
}

// GetDscp retrieves the value of the leaf Dscp from the Acl_AclSet_AclEntry_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv6) GetDscp() uint8 {
	if t == nil || t.Dscp == nil {
		return 0
	}
	return *t.Dscp
}

// GetDscpSet retrieves the value of the leaf DscpSet from the Acl_AclSet_AclEntry_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv6) GetDscpSet() []uint8 {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetHopLimit retrieves the value of the leaf HopLimit from the Acl_AclSet_AclEntry_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopLimit is set, it can
// safely use t.GetHopLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopLimit == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv6) GetHopLimit() uint8 {
	if t == nil || t.HopLimit == nil {
		return 0
	}
	return *t.HopLimit
}

// GetProtocol retrieves the value of the leaf Protocol from the Acl_AclSet_AclEntry_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv6) GetProtocol() Acl_AclSet_AclEntry_Ipv6_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the Acl_AclSet_AclEntry_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv6) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// GetSourceFlowLabel retrieves the value of the leaf SourceFlowLabel from the Acl_AclSet_AclEntry_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceFlowLabel is set, it can
// safely use t.GetSourceFlowLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceFlowLabel == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Ipv6) GetSourceFlowLabel() uint32 {
	if t == nil || t.SourceFlowLabel == nil {
		return 0
	}
	return *t.SourceFlowLabel
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry_Ipv6.
func (*Acl_AclSet_AclEntry_Ipv6) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry_L2 represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/l2 YANG schema element.
type Acl_AclSet_AclEntry_L2 struct {
	DestinationMac     *string                                `path:"config/destination-mac" module:"openconfig-acl/openconfig-acl" shadow-path:"state/destination-mac" shadow-module:"openconfig-acl/openconfig-acl"`
	DestinationMacMask *string                                `path:"config/destination-mac-mask" module:"openconfig-acl/openconfig-acl" shadow-path:"state/destination-mac-mask" shadow-module:"openconfig-acl/openconfig-acl"`
	Ethertype          Acl_AclSet_AclEntry_L2_Ethertype_Union `path:"config/ethertype" module:"openconfig-acl/openconfig-acl" shadow-path:"state/ethertype" shadow-module:"openconfig-acl/openconfig-acl"`
	SourceMac          *string                                `path:"config/source-mac" module:"openconfig-acl/openconfig-acl" shadow-path:"state/source-mac" shadow-module:"openconfig-acl/openconfig-acl"`
	SourceMacMask      *string                                `path:"config/source-mac-mask" module:"openconfig-acl/openconfig-acl" shadow-path:"state/source-mac-mask" shadow-module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry_L2 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry_L2) IsYANGGoStruct() {}

// GetDestinationMac retrieves the value of the leaf DestinationMac from the Acl_AclSet_AclEntry_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationMac is set, it can
// safely use t.GetDestinationMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationMac == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_L2) GetDestinationMac() string {
	if t == nil || t.DestinationMac == nil {
		return ""
	}
	return *t.DestinationMac
}

// GetDestinationMacMask retrieves the value of the leaf DestinationMacMask from the Acl_AclSet_AclEntry_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationMacMask is set, it can
// safely use t.GetDestinationMacMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationMacMask == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_L2) GetDestinationMacMask() string {
	if t == nil || t.DestinationMacMask == nil {
		return ""
	}
	return *t.DestinationMacMask
}

// GetEthertype retrieves the value of the leaf Ethertype from the Acl_AclSet_AclEntry_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ethertype is set, it can
// safely use t.GetEthertype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ethertype == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_L2) GetEthertype() Acl_AclSet_AclEntry_L2_Ethertype_Union {
	if t == nil || t.Ethertype == nil {
		return nil
	}
	return t.Ethertype
}

// GetSourceMac retrieves the value of the leaf SourceMac from the Acl_AclSet_AclEntry_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceMac is set, it can
// safely use t.GetSourceMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceMac == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_L2) GetSourceMac() string {
	if t == nil || t.SourceMac == nil {
		return ""
	}
	return *t.SourceMac
}

// GetSourceMacMask retrieves the value of the leaf SourceMacMask from the Acl_AclSet_AclEntry_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceMacMask is set, it can
// safely use t.GetSourceMacMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceMacMask == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_L2) GetSourceMacMask() string {
	if t == nil || t.SourceMacMask == nil {
		return ""
	}
	return *t.SourceMacMask
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_L2) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_L2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_L2) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_L2) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry_L2.
func (*Acl_AclSet_AclEntry_L2) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry_Mpls represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/mpls YANG schema element.
type Acl_AclSet_AclEntry_Mpls struct {
	EndLabelValue   Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union   `path:"config/end-label-value" module:"openconfig-acl/openconfig-acl" shadow-path:"state/end-label-value" shadow-module:"openconfig-acl/openconfig-acl"`
	StartLabelValue Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union `path:"config/start-label-value" module:"openconfig-acl/openconfig-acl" shadow-path:"state/start-label-value" shadow-module:"openconfig-acl/openconfig-acl"`
	TrafficClass    *uint8                                         `path:"config/traffic-class" module:"openconfig-acl/openconfig-acl" shadow-path:"state/traffic-class" shadow-module:"openconfig-acl/openconfig-acl"`
	TtlValue        *uint8                                         `path:"config/ttl-value" module:"openconfig-acl/openconfig-acl" shadow-path:"state/ttl-value" shadow-module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry_Mpls) IsYANGGoStruct() {}

// GetEndLabelValue retrieves the value of the leaf EndLabelValue from the Acl_AclSet_AclEntry_Mpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndLabelValue is set, it can
// safely use t.GetEndLabelValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndLabelValue == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Mpls) GetEndLabelValue() Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union {
	if t == nil || t.EndLabelValue == nil {
		return nil
	}
	return t.EndLabelValue
}

// GetStartLabelValue retrieves the value of the leaf StartLabelValue from the Acl_AclSet_AclEntry_Mpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartLabelValue is set, it can
// safely use t.GetStartLabelValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartLabelValue == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Mpls) GetStartLabelValue() Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union {
	if t == nil || t.StartLabelValue == nil {
		return nil
	}
	return t.StartLabelValue
}

// GetTrafficClass retrieves the value of the leaf TrafficClass from the Acl_AclSet_AclEntry_Mpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficClass is set, it can
// safely use t.GetTrafficClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficClass == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Mpls) GetTrafficClass() uint8 {
	if t == nil || t.TrafficClass == nil {
		return 0
	}
	return *t.TrafficClass
}

// GetTtlValue retrieves the value of the leaf TtlValue from the Acl_AclSet_AclEntry_Mpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TtlValue is set, it can
// safely use t.GetTtlValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TtlValue == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Mpls) GetTtlValue() uint8 {
	if t == nil || t.TtlValue == nil {
		return 0
	}
	return *t.TtlValue
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Mpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Mpls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry_Mpls.
func (*Acl_AclSet_AclEntry_Mpls) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_AclSet_AclEntry_Transport represents the /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/transport YANG schema element.
type Acl_AclSet_AclEntry_Transport struct {
	DestinationPort Acl_AclSet_AclEntry_Transport_DestinationPort_Union `path:"config/destination-port" module:"openconfig-acl/openconfig-acl" shadow-path:"state/destination-port" shadow-module:"openconfig-acl/openconfig-acl"`
	SourcePort      Acl_AclSet_AclEntry_Transport_SourcePort_Union      `path:"config/source-port" module:"openconfig-acl/openconfig-acl" shadow-path:"state/source-port" shadow-module:"openconfig-acl/openconfig-acl"`
	TcpFlags        []E_PacketMatchTypes_TCP_FLAGS                      `path:"config/tcp-flags" module:"openconfig-acl/openconfig-acl" shadow-path:"state/tcp-flags" shadow-module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_AclSet_AclEntry_Transport implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_AclSet_AclEntry_Transport) IsYANGGoStruct() {}

// GetDestinationPort retrieves the value of the leaf DestinationPort from the Acl_AclSet_AclEntry_Transport
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationPort is set, it can
// safely use t.GetDestinationPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationPort == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Transport) GetDestinationPort() Acl_AclSet_AclEntry_Transport_DestinationPort_Union {
	if t == nil || t.DestinationPort == nil {
		return nil
	}
	return t.DestinationPort
}

// GetSourcePort retrieves the value of the leaf SourcePort from the Acl_AclSet_AclEntry_Transport
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourcePort is set, it can
// safely use t.GetSourcePort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourcePort == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Transport) GetSourcePort() Acl_AclSet_AclEntry_Transport_SourcePort_Union {
	if t == nil || t.SourcePort == nil {
		return nil
	}
	return t.SourcePort
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the Acl_AclSet_AclEntry_Transport
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *Acl_AclSet_AclEntry_Transport) GetTcpFlags() []E_PacketMatchTypes_TCP_FLAGS {
	if t == nil || t.TcpFlags == nil {
		return nil
	}
	return t.TcpFlags
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Transport) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_AclSet_AclEntry_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_AclSet_AclEntry_Transport) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_AclSet_AclEntry_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_AclSet_AclEntry_Transport.
func (*Acl_AclSet_AclEntry_Transport) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_Interface represents the /openconfig-acl/acl/interfaces/interface YANG schema element.
type Acl_Interface struct {
	EgressAclSet  map[Acl_Interface_EgressAclSet_Key]*Acl_Interface_EgressAclSet   `path:"egress-acl-sets/egress-acl-set" module:"openconfig-acl/openconfig-acl"`
	Id            *string                                                          `path:"config/id|id" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"state/id|id" shadow-module:"openconfig-acl/openconfig-acl|openconfig-acl"`
	IngressAclSet map[Acl_Interface_IngressAclSet_Key]*Acl_Interface_IngressAclSet `path:"ingress-acl-sets/ingress-acl-set" module:"openconfig-acl/openconfig-acl"`
	InterfaceRef  *Acl_Interface_InterfaceRef                                      `path:"interface-ref" module:"openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_Interface) IsYANGGoStruct() {}

// Acl_Interface_EgressAclSet_Key represents the key for list EgressAclSet of element /openconfig-acl/acl/interfaces/interface.
type Acl_Interface_EgressAclSet_Key struct {
	SetName string         `path:"set-name"`
	Type    E_Acl_ACL_TYPE `path:"type"`
}

// Acl_Interface_IngressAclSet_Key represents the key for list IngressAclSet of element /openconfig-acl/acl/interfaces/interface.
type Acl_Interface_IngressAclSet_Key struct {
	SetName string         `path:"set-name"`
	Type    E_Acl_ACL_TYPE `path:"type"`
}

// NewEgressAclSet creates a new entry in the EgressAclSet list of the
// Acl_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_Interface) NewEgressAclSet(SetName string, Type E_Acl_ACL_TYPE) (*Acl_Interface_EgressAclSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EgressAclSet == nil {
		t.EgressAclSet = make(map[Acl_Interface_EgressAclSet_Key]*Acl_Interface_EgressAclSet)
	}

	key := Acl_Interface_EgressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EgressAclSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EgressAclSet", key)
	}

	t.EgressAclSet[key] = &Acl_Interface_EgressAclSet{
		SetName: &SetName,
		Type:    Type,
	}

	return t.EgressAclSet[key], nil
}

// RenameEgressAclSet renames an entry in the list EgressAclSet within
// the Acl_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_Interface) RenameEgressAclSet(oldK, newK Acl_Interface_EgressAclSet_Key) error {
	if _, ok := t.EgressAclSet[newK]; ok {
		return fmt.Errorf("key %v already exists in EgressAclSet", newK)
	}

	e, ok := t.EgressAclSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EgressAclSet", oldK)
	}
	e.SetName = &newK.SetName
	e.Type = newK.Type

	t.EgressAclSet[newK] = e
	delete(t.EgressAclSet, oldK)
	return nil
}

// GetOrCreateEgressAclSet retrieves the value with the specified keys from
// the receiver Acl_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_Interface) GetOrCreateEgressAclSet(SetName string, Type E_Acl_ACL_TYPE) *Acl_Interface_EgressAclSet {

	key := Acl_Interface_EgressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	if v, ok := t.EgressAclSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEgressAclSet(SetName, Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEgressAclSet got unexpected error: %v", err))
	}
	return v
}

// GetEgressAclSet retrieves the value with the specified key from
// the EgressAclSet map field of Acl_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_Interface) GetEgressAclSet(SetName string, Type E_Acl_ACL_TYPE) *Acl_Interface_EgressAclSet {

	if t == nil {
		return nil
	}

	key := Acl_Interface_EgressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	if lm, ok := t.EgressAclSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteEgressAclSet deletes the value with the specified keys from
// the receiver Acl_Interface. If there is no such element, the function
// is a no-op.
func (t *Acl_Interface) DeleteEgressAclSet(SetName string, Type E_Acl_ACL_TYPE) {
	key := Acl_Interface_EgressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	delete(t.EgressAclSet, key)
}

// AppendEgressAclSet appends the supplied Acl_Interface_EgressAclSet struct to the
// list EgressAclSet of Acl_Interface. If the key value(s) specified in
// the supplied Acl_Interface_EgressAclSet already exist in the list, an error is
// returned.
func (t *Acl_Interface) AppendEgressAclSet(v *Acl_Interface_EgressAclSet) error {
	if v.SetName == nil {
		return fmt.Errorf("invalid nil key for SetName")
	}

	key := Acl_Interface_EgressAclSet_Key{
		SetName: *v.SetName,
		Type:    v.Type,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EgressAclSet == nil {
		t.EgressAclSet = make(map[Acl_Interface_EgressAclSet_Key]*Acl_Interface_EgressAclSet)
	}

	if _, ok := t.EgressAclSet[key]; ok {
		return fmt.Errorf("duplicate key for list EgressAclSet %v", key)
	}

	t.EgressAclSet[key] = v
	return nil
}

// NewIngressAclSet creates a new entry in the IngressAclSet list of the
// Acl_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_Interface) NewIngressAclSet(SetName string, Type E_Acl_ACL_TYPE) (*Acl_Interface_IngressAclSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IngressAclSet == nil {
		t.IngressAclSet = make(map[Acl_Interface_IngressAclSet_Key]*Acl_Interface_IngressAclSet)
	}

	key := Acl_Interface_IngressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IngressAclSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IngressAclSet", key)
	}

	t.IngressAclSet[key] = &Acl_Interface_IngressAclSet{
		SetName: &SetName,
		Type:    Type,
	}

	return t.IngressAclSet[key], nil
}

// RenameIngressAclSet renames an entry in the list IngressAclSet within
// the Acl_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_Interface) RenameIngressAclSet(oldK, newK Acl_Interface_IngressAclSet_Key) error {
	if _, ok := t.IngressAclSet[newK]; ok {
		return fmt.Errorf("key %v already exists in IngressAclSet", newK)
	}

	e, ok := t.IngressAclSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IngressAclSet", oldK)
	}
	e.SetName = &newK.SetName
	e.Type = newK.Type

	t.IngressAclSet[newK] = e
	delete(t.IngressAclSet, oldK)
	return nil
}

// GetOrCreateIngressAclSet retrieves the value with the specified keys from
// the receiver Acl_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_Interface) GetOrCreateIngressAclSet(SetName string, Type E_Acl_ACL_TYPE) *Acl_Interface_IngressAclSet {

	key := Acl_Interface_IngressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	if v, ok := t.IngressAclSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIngressAclSet(SetName, Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIngressAclSet got unexpected error: %v", err))
	}
	return v
}

// GetIngressAclSet retrieves the value with the specified key from
// the IngressAclSet map field of Acl_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_Interface) GetIngressAclSet(SetName string, Type E_Acl_ACL_TYPE) *Acl_Interface_IngressAclSet {

	if t == nil {
		return nil
	}

	key := Acl_Interface_IngressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	if lm, ok := t.IngressAclSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteIngressAclSet deletes the value with the specified keys from
// the receiver Acl_Interface. If there is no such element, the function
// is a no-op.
func (t *Acl_Interface) DeleteIngressAclSet(SetName string, Type E_Acl_ACL_TYPE) {
	key := Acl_Interface_IngressAclSet_Key{
		SetName: SetName,
		Type:    Type,
	}

	delete(t.IngressAclSet, key)
}

// AppendIngressAclSet appends the supplied Acl_Interface_IngressAclSet struct to the
// list IngressAclSet of Acl_Interface. If the key value(s) specified in
// the supplied Acl_Interface_IngressAclSet already exist in the list, an error is
// returned.
func (t *Acl_Interface) AppendIngressAclSet(v *Acl_Interface_IngressAclSet) error {
	if v.SetName == nil {
		return fmt.Errorf("invalid nil key for SetName")
	}

	key := Acl_Interface_IngressAclSet_Key{
		SetName: *v.SetName,
		Type:    v.Type,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IngressAclSet == nil {
		t.IngressAclSet = make(map[Acl_Interface_IngressAclSet_Key]*Acl_Interface_IngressAclSet)
	}

	if _, ok := t.IngressAclSet[key]; ok {
		return fmt.Errorf("duplicate key for list IngressAclSet %v", key)
	}

	t.IngressAclSet[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Acl_Interface) GetOrCreateInterfaceRef() *Acl_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Acl_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Acl_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Acl_Interface) GetInterfaceRef() *Acl_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetId retrieves the value of the leaf Id from the Acl_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *Acl_Interface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// ΛListKeyMap returns the keys of the Acl_Interface struct, which is a YANG list entry.
func (t *Acl_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_Interface.
func (*Acl_Interface) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_Interface_EgressAclSet represents the /openconfig-acl/acl/interfaces/interface/egress-acl-sets/egress-acl-set YANG schema element.
type Acl_Interface_EgressAclSet struct {
	AclEntry map[uint32]*Acl_Interface_EgressAclSet_AclEntry `path:"acl-entries/acl-entry" module:"openconfig-acl/openconfig-acl"`
	SetName  *string                                         `path:"config/set-name|set-name" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"state/set-name|set-name" shadow-module:"openconfig-acl/openconfig-acl|openconfig-acl"`
	Type     E_Acl_ACL_TYPE                                  `path:"config/type|type" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"state/type|type" shadow-module:"openconfig-acl/openconfig-acl|openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_Interface_EgressAclSet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_Interface_EgressAclSet) IsYANGGoStruct() {}

// NewAclEntry creates a new entry in the AclEntry list of the
// Acl_Interface_EgressAclSet struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_Interface_EgressAclSet) NewAclEntry(SequenceId uint32) (*Acl_Interface_EgressAclSet_AclEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_Interface_EgressAclSet_AclEntry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AclEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AclEntry", key)
	}

	t.AclEntry[key] = &Acl_Interface_EgressAclSet_AclEntry{
		SequenceId: &SequenceId,
	}

	return t.AclEntry[key], nil
}

// RenameAclEntry renames an entry in the list AclEntry within
// the Acl_Interface_EgressAclSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_Interface_EgressAclSet) RenameAclEntry(oldK, newK uint32) error {
	if _, ok := t.AclEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in AclEntry", newK)
	}

	e, ok := t.AclEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AclEntry", oldK)
	}
	e.SequenceId = &newK

	t.AclEntry[newK] = e
	delete(t.AclEntry, oldK)
	return nil
}

// GetOrCreateAclEntry retrieves the value with the specified keys from
// the receiver Acl_Interface_EgressAclSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_Interface_EgressAclSet) GetOrCreateAclEntry(SequenceId uint32) *Acl_Interface_EgressAclSet_AclEntry {

	key := SequenceId

	if v, ok := t.AclEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAclEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAclEntry got unexpected error: %v", err))
	}
	return v
}

// GetAclEntry retrieves the value with the specified key from
// the AclEntry map field of Acl_Interface_EgressAclSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_Interface_EgressAclSet) GetAclEntry(SequenceId uint32) *Acl_Interface_EgressAclSet_AclEntry {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.AclEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteAclEntry deletes the value with the specified keys from
// the receiver Acl_Interface_EgressAclSet. If there is no such element, the function
// is a no-op.
func (t *Acl_Interface_EgressAclSet) DeleteAclEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.AclEntry, key)
}

// AppendAclEntry appends the supplied Acl_Interface_EgressAclSet_AclEntry struct to the
// list AclEntry of Acl_Interface_EgressAclSet. If the key value(s) specified in
// the supplied Acl_Interface_EgressAclSet_AclEntry already exist in the list, an error is
// returned.
func (t *Acl_Interface_EgressAclSet) AppendAclEntry(v *Acl_Interface_EgressAclSet_AclEntry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_Interface_EgressAclSet_AclEntry)
	}

	if _, ok := t.AclEntry[key]; ok {
		return fmt.Errorf("duplicate key for list AclEntry %v", key)
	}

	t.AclEntry[key] = v
	return nil
}

// GetSetName retrieves the value of the leaf SetName from the Acl_Interface_EgressAclSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetName is set, it can
// safely use t.GetSetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetName == nil' before retrieving the leaf's value.
func (t *Acl_Interface_EgressAclSet) GetSetName() string {
	if t == nil || t.SetName == nil {
		return ""
	}
	return *t.SetName
}

// GetType retrieves the value of the leaf Type from the Acl_Interface_EgressAclSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Acl_Interface_EgressAclSet) GetType() E_Acl_ACL_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the Acl_Interface_EgressAclSet struct, which is a YANG list entry.
func (t *Acl_Interface_EgressAclSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SetName == nil {
		return nil, fmt.Errorf("nil value for key SetName")
	}

	return map[string]interface{}{
		"set-name": *t.SetName,
		"type":     t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_EgressAclSet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_EgressAclSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_EgressAclSet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_EgressAclSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_Interface_EgressAclSet.
func (*Acl_Interface_EgressAclSet) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_Interface_EgressAclSet_AclEntry represents the /openconfig-acl/acl/interfaces/interface/egress-acl-sets/egress-acl-set/acl-entries/acl-entry YANG schema element.
type Acl_Interface_EgressAclSet_AclEntry struct {
	MatchedOctets  *uint64 `path:"state/matched-octets" module:"openconfig-acl/openconfig-acl"`
	MatchedPackets *uint64 `path:"state/matched-packets" module:"openconfig-acl/openconfig-acl"`
	SequenceId     *uint32 `path:"state/sequence-id|sequence-id" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"sequence-id" shadow-module:"openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_Interface_EgressAclSet_AclEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_Interface_EgressAclSet_AclEntry) IsYANGGoStruct() {}

// GetMatchedOctets retrieves the value of the leaf MatchedOctets from the Acl_Interface_EgressAclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchedOctets is set, it can
// safely use t.GetMatchedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchedOctets == nil' before retrieving the leaf's value.
func (t *Acl_Interface_EgressAclSet_AclEntry) GetMatchedOctets() uint64 {
	if t == nil || t.MatchedOctets == nil {
		return 0
	}
	return *t.MatchedOctets
}

// GetMatchedPackets retrieves the value of the leaf MatchedPackets from the Acl_Interface_EgressAclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchedPackets is set, it can
// safely use t.GetMatchedPackets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchedPackets == nil' before retrieving the leaf's value.
func (t *Acl_Interface_EgressAclSet_AclEntry) GetMatchedPackets() uint64 {
	if t == nil || t.MatchedPackets == nil {
		return 0
	}
	return *t.MatchedPackets
}

// GetSequenceId retrieves the value of the leaf SequenceId from the Acl_Interface_EgressAclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *Acl_Interface_EgressAclSet_AclEntry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// ΛListKeyMap returns the keys of the Acl_Interface_EgressAclSet_AclEntry struct, which is a YANG list entry.
func (t *Acl_Interface_EgressAclSet_AclEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_EgressAclSet_AclEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_EgressAclSet_AclEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_EgressAclSet_AclEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_EgressAclSet_AclEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_Interface_EgressAclSet_AclEntry.
func (*Acl_Interface_EgressAclSet_AclEntry) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_Interface_IngressAclSet represents the /openconfig-acl/acl/interfaces/interface/ingress-acl-sets/ingress-acl-set YANG schema element.
type Acl_Interface_IngressAclSet struct {
	AclEntry map[uint32]*Acl_Interface_IngressAclSet_AclEntry `path:"acl-entries/acl-entry" module:"openconfig-acl/openconfig-acl"`
	SetName  *string                                          `path:"config/set-name|set-name" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"state/set-name|set-name" shadow-module:"openconfig-acl/openconfig-acl|openconfig-acl"`
	Type     E_Acl_ACL_TYPE                                   `path:"config/type|type" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"state/type|type" shadow-module:"openconfig-acl/openconfig-acl|openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_Interface_IngressAclSet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_Interface_IngressAclSet) IsYANGGoStruct() {}

// NewAclEntry creates a new entry in the AclEntry list of the
// Acl_Interface_IngressAclSet struct. The keys of the list are populated from the input
// arguments.
func (t *Acl_Interface_IngressAclSet) NewAclEntry(SequenceId uint32) (*Acl_Interface_IngressAclSet_AclEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_Interface_IngressAclSet_AclEntry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AclEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AclEntry", key)
	}

	t.AclEntry[key] = &Acl_Interface_IngressAclSet_AclEntry{
		SequenceId: &SequenceId,
	}

	return t.AclEntry[key], nil
}

// RenameAclEntry renames an entry in the list AclEntry within
// the Acl_Interface_IngressAclSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Acl_Interface_IngressAclSet) RenameAclEntry(oldK, newK uint32) error {
	if _, ok := t.AclEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in AclEntry", newK)
	}

	e, ok := t.AclEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AclEntry", oldK)
	}
	e.SequenceId = &newK

	t.AclEntry[newK] = e
	delete(t.AclEntry, oldK)
	return nil
}

// GetOrCreateAclEntry retrieves the value with the specified keys from
// the receiver Acl_Interface_IngressAclSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Acl_Interface_IngressAclSet) GetOrCreateAclEntry(SequenceId uint32) *Acl_Interface_IngressAclSet_AclEntry {

	key := SequenceId

	if v, ok := t.AclEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAclEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAclEntry got unexpected error: %v", err))
	}
	return v
}

// GetAclEntry retrieves the value with the specified key from
// the AclEntry map field of Acl_Interface_IngressAclSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Acl_Interface_IngressAclSet) GetAclEntry(SequenceId uint32) *Acl_Interface_IngressAclSet_AclEntry {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.AclEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteAclEntry deletes the value with the specified keys from
// the receiver Acl_Interface_IngressAclSet. If there is no such element, the function
// is a no-op.
func (t *Acl_Interface_IngressAclSet) DeleteAclEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.AclEntry, key)
}

// AppendAclEntry appends the supplied Acl_Interface_IngressAclSet_AclEntry struct to the
// list AclEntry of Acl_Interface_IngressAclSet. If the key value(s) specified in
// the supplied Acl_Interface_IngressAclSet_AclEntry already exist in the list, an error is
// returned.
func (t *Acl_Interface_IngressAclSet) AppendAclEntry(v *Acl_Interface_IngressAclSet_AclEntry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AclEntry == nil {
		t.AclEntry = make(map[uint32]*Acl_Interface_IngressAclSet_AclEntry)
	}

	if _, ok := t.AclEntry[key]; ok {
		return fmt.Errorf("duplicate key for list AclEntry %v", key)
	}

	t.AclEntry[key] = v
	return nil
}

// GetSetName retrieves the value of the leaf SetName from the Acl_Interface_IngressAclSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetName is set, it can
// safely use t.GetSetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetName == nil' before retrieving the leaf's value.
func (t *Acl_Interface_IngressAclSet) GetSetName() string {
	if t == nil || t.SetName == nil {
		return ""
	}
	return *t.SetName
}

// GetType retrieves the value of the leaf Type from the Acl_Interface_IngressAclSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Acl_Interface_IngressAclSet) GetType() E_Acl_ACL_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the Acl_Interface_IngressAclSet struct, which is a YANG list entry.
func (t *Acl_Interface_IngressAclSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SetName == nil {
		return nil, fmt.Errorf("nil value for key SetName")
	}

	return map[string]interface{}{
		"set-name": *t.SetName,
		"type":     t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_IngressAclSet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_IngressAclSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_IngressAclSet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_IngressAclSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_Interface_IngressAclSet.
func (*Acl_Interface_IngressAclSet) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_Interface_IngressAclSet_AclEntry represents the /openconfig-acl/acl/interfaces/interface/ingress-acl-sets/ingress-acl-set/acl-entries/acl-entry YANG schema element.
type Acl_Interface_IngressAclSet_AclEntry struct {
	MatchedOctets  *uint64 `path:"state/matched-octets" module:"openconfig-acl/openconfig-acl"`
	MatchedPackets *uint64 `path:"state/matched-packets" module:"openconfig-acl/openconfig-acl"`
	SequenceId     *uint32 `path:"state/sequence-id|sequence-id" module:"openconfig-acl/openconfig-acl|openconfig-acl" shadow-path:"sequence-id" shadow-module:"openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_Interface_IngressAclSet_AclEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_Interface_IngressAclSet_AclEntry) IsYANGGoStruct() {}

// GetMatchedOctets retrieves the value of the leaf MatchedOctets from the Acl_Interface_IngressAclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchedOctets is set, it can
// safely use t.GetMatchedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchedOctets == nil' before retrieving the leaf's value.
func (t *Acl_Interface_IngressAclSet_AclEntry) GetMatchedOctets() uint64 {
	if t == nil || t.MatchedOctets == nil {
		return 0
	}
	return *t.MatchedOctets
}

// GetMatchedPackets retrieves the value of the leaf MatchedPackets from the Acl_Interface_IngressAclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchedPackets is set, it can
// safely use t.GetMatchedPackets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchedPackets == nil' before retrieving the leaf's value.
func (t *Acl_Interface_IngressAclSet_AclEntry) GetMatchedPackets() uint64 {
	if t == nil || t.MatchedPackets == nil {
		return 0
	}
	return *t.MatchedPackets
}

// GetSequenceId retrieves the value of the leaf SequenceId from the Acl_Interface_IngressAclSet_AclEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *Acl_Interface_IngressAclSet_AclEntry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// ΛListKeyMap returns the keys of the Acl_Interface_IngressAclSet_AclEntry struct, which is a YANG list entry.
func (t *Acl_Interface_IngressAclSet_AclEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_IngressAclSet_AclEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_IngressAclSet_AclEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_IngressAclSet_AclEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_IngressAclSet_AclEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_Interface_IngressAclSet_AclEntry.
func (*Acl_Interface_IngressAclSet_AclEntry) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Acl_Interface_InterfaceRef represents the /openconfig-acl/acl/interfaces/interface/interface-ref YANG schema element.
type Acl_Interface_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-acl/openconfig-acl" shadow-path:"state/interface" shadow-module:"openconfig-acl/openconfig-acl"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-acl/openconfig-acl" shadow-path:"state/subinterface" shadow-module:"openconfig-acl/openconfig-acl"`
}

// IsYANGGoStruct ensures that Acl_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Acl_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Acl_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Acl_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Acl_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Acl_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Acl_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Acl_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Acl_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Acl_Interface_InterfaceRef.
func (*Acl_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-acl"
}

// Component represents the /openconfig-platform/components/component YANG schema element.
type Component struct {
	AllocatedPower       *uint32                                 `path:"state/allocated-power" module:"openconfig-platform/openconfig-platform"`
	Backplane            *Component_Backplane                    `path:"backplane" module:"openconfig-platform"`
	Chassis              *Component_Chassis                      `path:"chassis" module:"openconfig-platform"`
	Cpu                  *Component_Cpu                          `path:"cpu" module:"openconfig-platform"`
	Description          *string                                 `path:"state/description" module:"openconfig-platform/openconfig-platform"`
	Empty                *bool                                   `path:"state/empty" module:"openconfig-platform/openconfig-platform"`
	EquipmentFailure     *bool                                   `path:"state/equipment-failure" module:"openconfig-platform/openconfig-alarms"`
	EquipmentMismatch    *bool                                   `path:"state/equipment-mismatch" module:"openconfig-platform/openconfig-alarms"`
	Fabric               *Component_Fabric                       `path:"fabric" module:"openconfig-platform"`
	Fan                  *Component_Fan                          `path:"fan" module:"openconfig-platform"`
	FirmwareVersion      *string                                 `path:"state/firmware-version" module:"openconfig-platform/openconfig-platform"`
	HardwareVersion      *string                                 `path:"state/hardware-version" module:"openconfig-platform/openconfig-platform"`
	Id                   *string                                 `path:"state/id" module:"openconfig-platform/openconfig-platform"`
	IntegratedCircuit    *Component_IntegratedCircuit            `path:"integrated-circuit" module:"openconfig-platform"`
	LastRebootReason     E_PlatformTypes_COMPONENT_REBOOT_REASON `path:"state/last-reboot-reason" module:"openconfig-platform/openconfig-platform"`
	LastRebootTime       *uint64                                 `path:"state/last-reboot-time" module:"openconfig-platform/openconfig-platform"`
	LastSwitchoverReason *Component_LastSwitchoverReason         `path:"state/last-switchover-reason" module:"openconfig-platform/openconfig-platform"`
	LastSwitchoverTime   *uint64                                 `path:"state/last-switchover-time" module:"openconfig-platform/openconfig-platform"`
	Location             *string                                 `path:"state/location" module:"openconfig-platform/openconfig-platform"`
	Memory               *Component_Memory                       `path:"state/memory" module:"openconfig-platform/openconfig-platform"`
	MfgDate              *string                                 `path:"state/mfg-date" module:"openconfig-platform/openconfig-platform"`
	MfgName              *string                                 `path:"state/mfg-name" module:"openconfig-platform/openconfig-platform"`
	Name                 *string                                 `path:"config/name|name" module:"openconfig-platform/openconfig-platform|openconfig-platform" shadow-path:"state/name|name" shadow-module:"openconfig-platform/openconfig-platform|openconfig-platform"`
	OperStatus           E_PlatformTypes_COMPONENT_OPER_STATUS   `path:"state/oper-status" module:"openconfig-platform/openconfig-platform"`
	Parent               *string                                 `path:"state/parent" module:"openconfig-platform/openconfig-platform"`
	PartNo               *string                                 `path:"state/part-no" module:"openconfig-platform/openconfig-platform"`
	Pcie                 *Component_Pcie                         `path:"state/pcie" module:"openconfig-platform/openconfig-platform"`
	Port                 *Component_Port                         `path:"port" module:"openconfig-platform"`
	PowerSupply          *Component_PowerSupply                  `path:"power-supply" module:"openconfig-platform"`
	Property             map[string]*Component_Property          `path:"properties/property" module:"openconfig-platform/openconfig-platform"`
	RedundantRole        E_PlatformTypes_ComponentRedundantRole  `path:"state/redundant-role" module:"openconfig-platform/openconfig-platform"`
	Removable            *bool                                   `path:"state/removable" module:"openconfig-platform/openconfig-platform"`
	SerialNo             *string                                 `path:"state/serial-no" module:"openconfig-platform/openconfig-platform"`
	SoftwareModule       *Component_SoftwareModule               `path:"software-module" module:"openconfig-platform"`
	SoftwareVersion      *string                                 `path:"state/software-version" module:"openconfig-platform/openconfig-platform"`
	Storage              *Component_Storage                      `path:"storage" module:"openconfig-platform"`
	Subcomponent         map[string]*Component_Subcomponent      `path:"subcomponents/subcomponent" module:"openconfig-platform/openconfig-platform"`
	Temperature          *Component_Temperature                  `path:"state/temperature" module:"openconfig-platform/openconfig-platform"`
	Type                 Component_Type_Union                    `path:"state/type" module:"openconfig-platform/openconfig-platform"`
	UsedPower            *uint32                                 `path:"state/used-power" module:"openconfig-platform/openconfig-platform"`
}

// IsYANGGoStruct ensures that Component implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component) IsYANGGoStruct() {}

// NewProperty creates a new entry in the Property list of the
// Component struct. The keys of the list are populated from the input
// arguments.
func (t *Component) NewProperty(Name string) (*Component_Property, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Property == nil {
		t.Property = make(map[string]*Component_Property)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Property[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Property", key)
	}

	t.Property[key] = &Component_Property{
		Name: &Name,
	}

	return t.Property[key], nil
}

// RenameProperty renames an entry in the list Property within
// the Component struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component) RenameProperty(oldK, newK string) error {
	if _, ok := t.Property[newK]; ok {
		return fmt.Errorf("key %v already exists in Property", newK)
	}

	e, ok := t.Property[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Property", oldK)
	}
	e.Name = &newK

	t.Property[newK] = e
	delete(t.Property, oldK)
	return nil
}

// GetOrCreateProperty retrieves the value with the specified keys from
// the receiver Component. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component) GetOrCreateProperty(Name string) *Component_Property {

	key := Name

	if v, ok := t.Property[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProperty(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProperty got unexpected error: %v", err))
	}
	return v
}

// GetProperty retrieves the value with the specified key from
// the Property map field of Component. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component) GetProperty(Name string) *Component_Property {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Property[key]; ok {
		return lm
	}
	return nil
}

// DeleteProperty deletes the value with the specified keys from
// the receiver Component. If there is no such element, the function
// is a no-op.
func (t *Component) DeleteProperty(Name string) {
	key := Name

	delete(t.Property, key)
}

// AppendProperty appends the supplied Component_Property struct to the
// list Property of Component. If the key value(s) specified in
// the supplied Component_Property already exist in the list, an error is
// returned.
func (t *Component) AppendProperty(v *Component_Property) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Property == nil {
		t.Property = make(map[string]*Component_Property)
	}

	if _, ok := t.Property[key]; ok {
		return fmt.Errorf("duplicate key for list Property %v", key)
	}

	t.Property[key] = v
	return nil
}

// NewSubcomponent creates a new entry in the Subcomponent list of the
// Component struct. The keys of the list are populated from the input
// arguments.
func (t *Component) NewSubcomponent(Name string) (*Component_Subcomponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subcomponent == nil {
		t.Subcomponent = make(map[string]*Component_Subcomponent)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subcomponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subcomponent", key)
	}

	t.Subcomponent[key] = &Component_Subcomponent{
		Name: &Name,
	}

	return t.Subcomponent[key], nil
}

// RenameSubcomponent renames an entry in the list Subcomponent within
// the Component struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component) RenameSubcomponent(oldK, newK string) error {
	if _, ok := t.Subcomponent[newK]; ok {
		return fmt.Errorf("key %v already exists in Subcomponent", newK)
	}

	e, ok := t.Subcomponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subcomponent", oldK)
	}
	e.Name = &newK

	t.Subcomponent[newK] = e
	delete(t.Subcomponent, oldK)
	return nil
}

// GetOrCreateSubcomponent retrieves the value with the specified keys from
// the receiver Component. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component) GetOrCreateSubcomponent(Name string) *Component_Subcomponent {

	key := Name

	if v, ok := t.Subcomponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubcomponent(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubcomponent got unexpected error: %v", err))
	}
	return v
}

// GetSubcomponent retrieves the value with the specified key from
// the Subcomponent map field of Component. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component) GetSubcomponent(Name string) *Component_Subcomponent {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Subcomponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubcomponent deletes the value with the specified keys from
// the receiver Component. If there is no such element, the function
// is a no-op.
func (t *Component) DeleteSubcomponent(Name string) {
	key := Name

	delete(t.Subcomponent, key)
}

// AppendSubcomponent appends the supplied Component_Subcomponent struct to the
// list Subcomponent of Component. If the key value(s) specified in
// the supplied Component_Subcomponent already exist in the list, an error is
// returned.
func (t *Component) AppendSubcomponent(v *Component_Subcomponent) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subcomponent == nil {
		t.Subcomponent = make(map[string]*Component_Subcomponent)
	}

	if _, ok := t.Subcomponent[key]; ok {
		return fmt.Errorf("duplicate key for list Subcomponent %v", key)
	}

	t.Subcomponent[key] = v
	return nil
}

// GetOrCreateBackplane retrieves the value of the Backplane field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateBackplane() *Component_Backplane {
	if t.Backplane != nil {
		return t.Backplane
	}
	t.Backplane = &Component_Backplane{}
	return t.Backplane
}

// GetOrCreateChassis retrieves the value of the Chassis field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateChassis() *Component_Chassis {
	if t.Chassis != nil {
		return t.Chassis
	}
	t.Chassis = &Component_Chassis{}
	return t.Chassis
}

// GetOrCreateCpu retrieves the value of the Cpu field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateCpu() *Component_Cpu {
	if t.Cpu != nil {
		return t.Cpu
	}
	t.Cpu = &Component_Cpu{}
	return t.Cpu
}

// GetOrCreateFabric retrieves the value of the Fabric field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateFabric() *Component_Fabric {
	if t.Fabric != nil {
		return t.Fabric
	}
	t.Fabric = &Component_Fabric{}
	return t.Fabric
}

// GetOrCreateFan retrieves the value of the Fan field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateFan() *Component_Fan {
	if t.Fan != nil {
		return t.Fan
	}
	t.Fan = &Component_Fan{}
	return t.Fan
}

// GetOrCreateIntegratedCircuit retrieves the value of the IntegratedCircuit field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateIntegratedCircuit() *Component_IntegratedCircuit {
	if t.IntegratedCircuit != nil {
		return t.IntegratedCircuit
	}
	t.IntegratedCircuit = &Component_IntegratedCircuit{}
	return t.IntegratedCircuit
}

// GetOrCreateLastSwitchoverReason retrieves the value of the LastSwitchoverReason field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateLastSwitchoverReason() *Component_LastSwitchoverReason {
	if t.LastSwitchoverReason != nil {
		return t.LastSwitchoverReason
	}
	t.LastSwitchoverReason = &Component_LastSwitchoverReason{}
	return t.LastSwitchoverReason
}

// GetOrCreateMemory retrieves the value of the Memory field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateMemory() *Component_Memory {
	if t.Memory != nil {
		return t.Memory
	}
	t.Memory = &Component_Memory{}
	return t.Memory
}

// GetOrCreatePcie retrieves the value of the Pcie field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreatePcie() *Component_Pcie {
	if t.Pcie != nil {
		return t.Pcie
	}
	t.Pcie = &Component_Pcie{}
	return t.Pcie
}

// GetOrCreatePort retrieves the value of the Port field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreatePort() *Component_Port {
	if t.Port != nil {
		return t.Port
	}
	t.Port = &Component_Port{}
	return t.Port
}

// GetOrCreatePowerSupply retrieves the value of the PowerSupply field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreatePowerSupply() *Component_PowerSupply {
	if t.PowerSupply != nil {
		return t.PowerSupply
	}
	t.PowerSupply = &Component_PowerSupply{}
	return t.PowerSupply
}

// GetOrCreateSoftwareModule retrieves the value of the SoftwareModule field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateSoftwareModule() *Component_SoftwareModule {
	if t.SoftwareModule != nil {
		return t.SoftwareModule
	}
	t.SoftwareModule = &Component_SoftwareModule{}
	return t.SoftwareModule
}

// GetOrCreateStorage retrieves the value of the Storage field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateStorage() *Component_Storage {
	if t.Storage != nil {
		return t.Storage
	}
	t.Storage = &Component_Storage{}
	return t.Storage
}

// GetOrCreateTemperature retrieves the value of the Temperature field
// or returns the existing field if it already exists.
func (t *Component) GetOrCreateTemperature() *Component_Temperature {
	if t.Temperature != nil {
		return t.Temperature
	}
	t.Temperature = &Component_Temperature{}
	return t.Temperature
}

// GetBackplane returns the value of the Backplane struct pointer
// from Component. If the receiver or the field Backplane is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetBackplane() *Component_Backplane {
	if t != nil && t.Backplane != nil {
		return t.Backplane
	}
	return nil
}

// GetChassis returns the value of the Chassis struct pointer
// from Component. If the receiver or the field Chassis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetChassis() *Component_Chassis {
	if t != nil && t.Chassis != nil {
		return t.Chassis
	}
	return nil
}

// GetCpu returns the value of the Cpu struct pointer
// from Component. If the receiver or the field Cpu is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetCpu() *Component_Cpu {
	if t != nil && t.Cpu != nil {
		return t.Cpu
	}
	return nil
}

// GetFabric returns the value of the Fabric struct pointer
// from Component. If the receiver or the field Fabric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetFabric() *Component_Fabric {
	if t != nil && t.Fabric != nil {
		return t.Fabric
	}
	return nil
}

// GetFan returns the value of the Fan struct pointer
// from Component. If the receiver or the field Fan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetFan() *Component_Fan {
	if t != nil && t.Fan != nil {
		return t.Fan
	}
	return nil
}

// GetIntegratedCircuit returns the value of the IntegratedCircuit struct pointer
// from Component. If the receiver or the field IntegratedCircuit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetIntegratedCircuit() *Component_IntegratedCircuit {
	if t != nil && t.IntegratedCircuit != nil {
		return t.IntegratedCircuit
	}
	return nil
}

// GetLastSwitchoverReason returns the value of the LastSwitchoverReason struct pointer
// from Component. If the receiver or the field LastSwitchoverReason is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetLastSwitchoverReason() *Component_LastSwitchoverReason {
	if t != nil && t.LastSwitchoverReason != nil {
		return t.LastSwitchoverReason
	}
	return nil
}

// GetMemory returns the value of the Memory struct pointer
// from Component. If the receiver or the field Memory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetMemory() *Component_Memory {
	if t != nil && t.Memory != nil {
		return t.Memory
	}
	return nil
}

// GetPcie returns the value of the Pcie struct pointer
// from Component. If the receiver or the field Pcie is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetPcie() *Component_Pcie {
	if t != nil && t.Pcie != nil {
		return t.Pcie
	}
	return nil
}

// GetPort returns the value of the Port struct pointer
// from Component. If the receiver or the field Port is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetPort() *Component_Port {
	if t != nil && t.Port != nil {
		return t.Port
	}
	return nil
}

// GetPowerSupply returns the value of the PowerSupply struct pointer
// from Component. If the receiver or the field PowerSupply is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetPowerSupply() *Component_PowerSupply {
	if t != nil && t.PowerSupply != nil {
		return t.PowerSupply
	}
	return nil
}

// GetSoftwareModule returns the value of the SoftwareModule struct pointer
// from Component. If the receiver or the field SoftwareModule is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetSoftwareModule() *Component_SoftwareModule {
	if t != nil && t.SoftwareModule != nil {
		return t.SoftwareModule
	}
	return nil
}

// GetStorage returns the value of the Storage struct pointer
// from Component. If the receiver or the field Storage is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetStorage() *Component_Storage {
	if t != nil && t.Storage != nil {
		return t.Storage
	}
	return nil
}

// GetTemperature returns the value of the Temperature struct pointer
// from Component. If the receiver or the field Temperature is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component) GetTemperature() *Component_Temperature {
	if t != nil && t.Temperature != nil {
		return t.Temperature
	}
	return nil
}

// GetAllocatedPower retrieves the value of the leaf AllocatedPower from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllocatedPower is set, it can
// safely use t.GetAllocatedPower() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllocatedPower == nil' before retrieving the leaf's value.
func (t *Component) GetAllocatedPower() uint32 {
	if t == nil || t.AllocatedPower == nil {
		return 0
	}
	return *t.AllocatedPower
}

// GetDescription retrieves the value of the leaf Description from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *Component) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEmpty retrieves the value of the leaf Empty from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Empty is set, it can
// safely use t.GetEmpty() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Empty == nil' before retrieving the leaf's value.
func (t *Component) GetEmpty() bool {
	if t == nil || t.Empty == nil {
		return false
	}
	return *t.Empty
}

// GetEquipmentFailure retrieves the value of the leaf EquipmentFailure from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EquipmentFailure is set, it can
// safely use t.GetEquipmentFailure() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EquipmentFailure == nil' before retrieving the leaf's value.
func (t *Component) GetEquipmentFailure() bool {
	if t == nil || t.EquipmentFailure == nil {
		return false
	}
	return *t.EquipmentFailure
}

// GetEquipmentMismatch retrieves the value of the leaf EquipmentMismatch from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EquipmentMismatch is set, it can
// safely use t.GetEquipmentMismatch() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EquipmentMismatch == nil' before retrieving the leaf's value.
func (t *Component) GetEquipmentMismatch() bool {
	if t == nil || t.EquipmentMismatch == nil {
		return false
	}
	return *t.EquipmentMismatch
}

// GetFirmwareVersion retrieves the value of the leaf FirmwareVersion from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FirmwareVersion is set, it can
// safely use t.GetFirmwareVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FirmwareVersion == nil' before retrieving the leaf's value.
func (t *Component) GetFirmwareVersion() string {
	if t == nil || t.FirmwareVersion == nil {
		return ""
	}
	return *t.FirmwareVersion
}

// GetHardwareVersion retrieves the value of the leaf HardwareVersion from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HardwareVersion is set, it can
// safely use t.GetHardwareVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HardwareVersion == nil' before retrieving the leaf's value.
func (t *Component) GetHardwareVersion() string {
	if t == nil || t.HardwareVersion == nil {
		return ""
	}
	return *t.HardwareVersion
}

// GetId retrieves the value of the leaf Id from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *Component) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetLastRebootReason retrieves the value of the leaf LastRebootReason from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastRebootReason is set, it can
// safely use t.GetLastRebootReason() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastRebootReason == nil' before retrieving the leaf's value.
func (t *Component) GetLastRebootReason() E_PlatformTypes_COMPONENT_REBOOT_REASON {
	if t == nil || t.LastRebootReason == 0 {
		return 0
	}
	return t.LastRebootReason
}

// GetLastRebootTime retrieves the value of the leaf LastRebootTime from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastRebootTime is set, it can
// safely use t.GetLastRebootTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastRebootTime == nil' before retrieving the leaf's value.
func (t *Component) GetLastRebootTime() uint64 {
	if t == nil || t.LastRebootTime == nil {
		return 0
	}
	return *t.LastRebootTime
}

// GetLastSwitchoverTime retrieves the value of the leaf LastSwitchoverTime from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastSwitchoverTime is set, it can
// safely use t.GetLastSwitchoverTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastSwitchoverTime == nil' before retrieving the leaf's value.
func (t *Component) GetLastSwitchoverTime() uint64 {
	if t == nil || t.LastSwitchoverTime == nil {
		return 0
	}
	return *t.LastSwitchoverTime
}

// GetLocation retrieves the value of the leaf Location from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Location is set, it can
// safely use t.GetLocation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Location == nil' before retrieving the leaf's value.
func (t *Component) GetLocation() string {
	if t == nil || t.Location == nil {
		return ""
	}
	return *t.Location
}

// GetMfgDate retrieves the value of the leaf MfgDate from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MfgDate is set, it can
// safely use t.GetMfgDate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MfgDate == nil' before retrieving the leaf's value.
func (t *Component) GetMfgDate() string {
	if t == nil || t.MfgDate == nil {
		return ""
	}
	return *t.MfgDate
}

// GetMfgName retrieves the value of the leaf MfgName from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MfgName is set, it can
// safely use t.GetMfgName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MfgName == nil' before retrieving the leaf's value.
func (t *Component) GetMfgName() string {
	if t == nil || t.MfgName == nil {
		return ""
	}
	return *t.MfgName
}

// GetName retrieves the value of the leaf Name from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Component) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *Component) GetOperStatus() E_PlatformTypes_COMPONENT_OPER_STATUS {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// GetParent retrieves the value of the leaf Parent from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Parent is set, it can
// safely use t.GetParent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Parent == nil' before retrieving the leaf's value.
func (t *Component) GetParent() string {
	if t == nil || t.Parent == nil {
		return ""
	}
	return *t.Parent
}

// GetPartNo retrieves the value of the leaf PartNo from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartNo is set, it can
// safely use t.GetPartNo() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartNo == nil' before retrieving the leaf's value.
func (t *Component) GetPartNo() string {
	if t == nil || t.PartNo == nil {
		return ""
	}
	return *t.PartNo
}

// GetRedundantRole retrieves the value of the leaf RedundantRole from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedundantRole is set, it can
// safely use t.GetRedundantRole() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedundantRole == nil' before retrieving the leaf's value.
func (t *Component) GetRedundantRole() E_PlatformTypes_ComponentRedundantRole {
	if t == nil || t.RedundantRole == 0 {
		return 0
	}
	return t.RedundantRole
}

// GetRemovable retrieves the value of the leaf Removable from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Removable is set, it can
// safely use t.GetRemovable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Removable == nil' before retrieving the leaf's value.
func (t *Component) GetRemovable() bool {
	if t == nil || t.Removable == nil {
		return false
	}
	return *t.Removable
}

// GetSerialNo retrieves the value of the leaf SerialNo from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SerialNo is set, it can
// safely use t.GetSerialNo() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SerialNo == nil' before retrieving the leaf's value.
func (t *Component) GetSerialNo() string {
	if t == nil || t.SerialNo == nil {
		return ""
	}
	return *t.SerialNo
}

// GetSoftwareVersion retrieves the value of the leaf SoftwareVersion from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SoftwareVersion is set, it can
// safely use t.GetSoftwareVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SoftwareVersion == nil' before retrieving the leaf's value.
func (t *Component) GetSoftwareVersion() string {
	if t == nil || t.SoftwareVersion == nil {
		return ""
	}
	return *t.SoftwareVersion
}

// GetType retrieves the value of the leaf Type from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Component) GetType() Component_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// GetUsedPower retrieves the value of the leaf UsedPower from the Component
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UsedPower is set, it can
// safely use t.GetUsedPower() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UsedPower == nil' before retrieving the leaf's value.
func (t *Component) GetUsedPower() uint32 {
	if t == nil || t.UsedPower == nil {
		return 0
	}
	return *t.UsedPower
}

// ΛListKeyMap returns the keys of the Component struct, which is a YANG list entry.
func (t *Component) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component.
func (*Component) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Backplane represents the /openconfig-platform/components/component/backplane YANG schema element.
type Component_Backplane struct {
}

// IsYANGGoStruct ensures that Component_Backplane implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Backplane) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Backplane) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Backplane"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Backplane) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Backplane) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Backplane.
func (*Component_Backplane) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Chassis represents the /openconfig-platform/components/component/chassis YANG schema element.
type Component_Chassis struct {
	Utilization *Component_Chassis_Utilization `path:"utilization" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Chassis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Chassis) IsYANGGoStruct() {}

// GetOrCreateUtilization retrieves the value of the Utilization field
// or returns the existing field if it already exists.
func (t *Component_Chassis) GetOrCreateUtilization() *Component_Chassis_Utilization {
	if t.Utilization != nil {
		return t.Utilization
	}
	t.Utilization = &Component_Chassis_Utilization{}
	return t.Utilization
}

// GetUtilization returns the value of the Utilization struct pointer
// from Component_Chassis. If the receiver or the field Utilization is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Chassis) GetUtilization() *Component_Chassis_Utilization {
	if t != nil && t.Utilization != nil {
		return t.Utilization
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Chassis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Chassis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Chassis) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Chassis) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Chassis.
func (*Component_Chassis) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Chassis_Utilization represents the /openconfig-platform/components/component/chassis/utilization YANG schema element.
type Component_Chassis_Utilization struct {
	Resource map[string]*Component_Chassis_Utilization_Resource `path:"resources/resource" module:"openconfig-platform/openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Chassis_Utilization implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Chassis_Utilization) IsYANGGoStruct() {}

// NewResource creates a new entry in the Resource list of the
// Component_Chassis_Utilization struct. The keys of the list are populated from the input
// arguments.
func (t *Component_Chassis_Utilization) NewResource(Name string) (*Component_Chassis_Utilization_Resource, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[string]*Component_Chassis_Utilization_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &Component_Chassis_Utilization_Resource{
		Name: &Name,
	}

	return t.Resource[key], nil
}

// RenameResource renames an entry in the list Resource within
// the Component_Chassis_Utilization struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component_Chassis_Utilization) RenameResource(oldK, newK string) error {
	if _, ok := t.Resource[newK]; ok {
		return fmt.Errorf("key %v already exists in Resource", newK)
	}

	e, ok := t.Resource[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Resource", oldK)
	}
	e.Name = &newK

	t.Resource[newK] = e
	delete(t.Resource, oldK)
	return nil
}

// GetOrCreateResource retrieves the value with the specified keys from
// the receiver Component_Chassis_Utilization. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component_Chassis_Utilization) GetOrCreateResource(Name string) *Component_Chassis_Utilization_Resource {

	key := Name

	if v, ok := t.Resource[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResource(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResource got unexpected error: %v", err))
	}
	return v
}

// GetResource retrieves the value with the specified key from
// the Resource map field of Component_Chassis_Utilization. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component_Chassis_Utilization) GetResource(Name string) *Component_Chassis_Utilization_Resource {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Resource[key]; ok {
		return lm
	}
	return nil
}

// DeleteResource deletes the value with the specified keys from
// the receiver Component_Chassis_Utilization. If there is no such element, the function
// is a no-op.
func (t *Component_Chassis_Utilization) DeleteResource(Name string) {
	key := Name

	delete(t.Resource, key)
}

// AppendResource appends the supplied Component_Chassis_Utilization_Resource struct to the
// list Resource of Component_Chassis_Utilization. If the key value(s) specified in
// the supplied Component_Chassis_Utilization_Resource already exist in the list, an error is
// returned.
func (t *Component_Chassis_Utilization) AppendResource(v *Component_Chassis_Utilization_Resource) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[string]*Component_Chassis_Utilization_Resource)
	}

	if _, ok := t.Resource[key]; ok {
		return fmt.Errorf("duplicate key for list Resource %v", key)
	}

	t.Resource[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Chassis_Utilization) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Chassis_Utilization"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Chassis_Utilization) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Chassis_Utilization) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Chassis_Utilization.
func (*Component_Chassis_Utilization) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Chassis_Utilization_Resource represents the /openconfig-platform/components/component/chassis/utilization/resources/resource YANG schema element.
type Component_Chassis_Utilization_Resource struct {
	Committed         *uint64 `path:"state/committed" module:"openconfig-platform/openconfig-platform"`
	Free              *uint64 `path:"state/free" module:"openconfig-platform/openconfig-platform"`
	HighWatermark     *uint64 `path:"state/high-watermark" module:"openconfig-platform/openconfig-platform"`
	LastHighWatermark *uint64 `path:"state/last-high-watermark" module:"openconfig-platform/openconfig-platform"`
	MaxLimit          *uint64 `path:"state/max-limit" module:"openconfig-platform/openconfig-platform"`
	Name              *string `path:"config/name|name" module:"openconfig-platform/openconfig-platform|openconfig-platform" shadow-path:"state/name|name" shadow-module:"openconfig-platform/openconfig-platform|openconfig-platform"`
	Used              *uint64 `path:"state/used" module:"openconfig-platform/openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Chassis_Utilization_Resource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Chassis_Utilization_Resource) IsYANGGoStruct() {}

// GetCommitted retrieves the value of the leaf Committed from the Component_Chassis_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Committed is set, it can
// safely use t.GetCommitted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Committed == nil' before retrieving the leaf's value.
func (t *Component_Chassis_Utilization_Resource) GetCommitted() uint64 {
	if t == nil || t.Committed == nil {
		return 0
	}
	return *t.Committed
}

// GetFree retrieves the value of the leaf Free from the Component_Chassis_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Free is set, it can
// safely use t.GetFree() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Free == nil' before retrieving the leaf's value.
func (t *Component_Chassis_Utilization_Resource) GetFree() uint64 {
	if t == nil || t.Free == nil {
		return 0
	}
	return *t.Free
}

// GetHighWatermark retrieves the value of the leaf HighWatermark from the Component_Chassis_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighWatermark is set, it can
// safely use t.GetHighWatermark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighWatermark == nil' before retrieving the leaf's value.
func (t *Component_Chassis_Utilization_Resource) GetHighWatermark() uint64 {
	if t == nil || t.HighWatermark == nil {
		return 0
	}
	return *t.HighWatermark
}

// GetLastHighWatermark retrieves the value of the leaf LastHighWatermark from the Component_Chassis_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastHighWatermark is set, it can
// safely use t.GetLastHighWatermark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastHighWatermark == nil' before retrieving the leaf's value.
func (t *Component_Chassis_Utilization_Resource) GetLastHighWatermark() uint64 {
	if t == nil || t.LastHighWatermark == nil {
		return 0
	}
	return *t.LastHighWatermark
}

// GetMaxLimit retrieves the value of the leaf MaxLimit from the Component_Chassis_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxLimit is set, it can
// safely use t.GetMaxLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxLimit == nil' before retrieving the leaf's value.
func (t *Component_Chassis_Utilization_Resource) GetMaxLimit() uint64 {
	if t == nil || t.MaxLimit == nil {
		return 0
	}
	return *t.MaxLimit
}

// GetName retrieves the value of the leaf Name from the Component_Chassis_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Component_Chassis_Utilization_Resource) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetUsed retrieves the value of the leaf Used from the Component_Chassis_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Used is set, it can
// safely use t.GetUsed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Used == nil' before retrieving the leaf's value.
func (t *Component_Chassis_Utilization_Resource) GetUsed() uint64 {
	if t == nil || t.Used == nil {
		return 0
	}
	return *t.Used
}

// ΛListKeyMap returns the keys of the Component_Chassis_Utilization_Resource struct, which is a YANG list entry.
func (t *Component_Chassis_Utilization_Resource) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Chassis_Utilization_Resource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Chassis_Utilization_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Chassis_Utilization_Resource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Chassis_Utilization_Resource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Chassis_Utilization_Resource.
func (*Component_Chassis_Utilization_Resource) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Cpu represents the /openconfig-platform/components/component/cpu YANG schema element.
type Component_Cpu struct {
}

// IsYANGGoStruct ensures that Component_Cpu implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Cpu) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Cpu) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Cpu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Cpu) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Cpu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Cpu.
func (*Component_Cpu) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Fabric represents the /openconfig-platform/components/component/fabric YANG schema element.
type Component_Fabric struct {
}

// IsYANGGoStruct ensures that Component_Fabric implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Fabric) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Fabric) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Fabric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Fabric) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Fabric) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Fabric.
func (*Component_Fabric) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Fan represents the /openconfig-platform/components/component/fan YANG schema element.
type Component_Fan struct {
}

// IsYANGGoStruct ensures that Component_Fan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Fan) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Fan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Fan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Fan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Fan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Fan.
func (*Component_Fan) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_IntegratedCircuit represents the /openconfig-platform/components/component/integrated-circuit YANG schema element.
type Component_IntegratedCircuit struct {
	NodeId      *uint64                                  `path:"config/node-id" module:"openconfig-platform/openconfig-p4rt" shadow-path:"state/node-id" shadow-module:"openconfig-platform/openconfig-p4rt"`
	Utilization *Component_IntegratedCircuit_Utilization `path:"utilization" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_IntegratedCircuit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_IntegratedCircuit) IsYANGGoStruct() {}

// GetOrCreateUtilization retrieves the value of the Utilization field
// or returns the existing field if it already exists.
func (t *Component_IntegratedCircuit) GetOrCreateUtilization() *Component_IntegratedCircuit_Utilization {
	if t.Utilization != nil {
		return t.Utilization
	}
	t.Utilization = &Component_IntegratedCircuit_Utilization{}
	return t.Utilization
}

// GetUtilization returns the value of the Utilization struct pointer
// from Component_IntegratedCircuit. If the receiver or the field Utilization is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_IntegratedCircuit) GetUtilization() *Component_IntegratedCircuit_Utilization {
	if t != nil && t.Utilization != nil {
		return t.Utilization
	}
	return nil
}

// GetNodeId retrieves the value of the leaf NodeId from the Component_IntegratedCircuit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NodeId is set, it can
// safely use t.GetNodeId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NodeId == nil' before retrieving the leaf's value.
func (t *Component_IntegratedCircuit) GetNodeId() uint64 {
	if t == nil || t.NodeId == nil {
		return 0
	}
	return *t.NodeId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_IntegratedCircuit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_IntegratedCircuit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_IntegratedCircuit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_IntegratedCircuit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_IntegratedCircuit.
func (*Component_IntegratedCircuit) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_IntegratedCircuit_Utilization represents the /openconfig-platform/components/component/integrated-circuit/utilization YANG schema element.
type Component_IntegratedCircuit_Utilization struct {
	Resource map[string]*Component_IntegratedCircuit_Utilization_Resource `path:"resources/resource" module:"openconfig-platform/openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_IntegratedCircuit_Utilization implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_IntegratedCircuit_Utilization) IsYANGGoStruct() {}

// NewResource creates a new entry in the Resource list of the
// Component_IntegratedCircuit_Utilization struct. The keys of the list are populated from the input
// arguments.
func (t *Component_IntegratedCircuit_Utilization) NewResource(Name string) (*Component_IntegratedCircuit_Utilization_Resource, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[string]*Component_IntegratedCircuit_Utilization_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &Component_IntegratedCircuit_Utilization_Resource{
		Name: &Name,
	}

	return t.Resource[key], nil
}

// RenameResource renames an entry in the list Resource within
// the Component_IntegratedCircuit_Utilization struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component_IntegratedCircuit_Utilization) RenameResource(oldK, newK string) error {
	if _, ok := t.Resource[newK]; ok {
		return fmt.Errorf("key %v already exists in Resource", newK)
	}

	e, ok := t.Resource[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Resource", oldK)
	}
	e.Name = &newK

	t.Resource[newK] = e
	delete(t.Resource, oldK)
	return nil
}

// GetOrCreateResource retrieves the value with the specified keys from
// the receiver Component_IntegratedCircuit_Utilization. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component_IntegratedCircuit_Utilization) GetOrCreateResource(Name string) *Component_IntegratedCircuit_Utilization_Resource {

	key := Name

	if v, ok := t.Resource[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResource(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResource got unexpected error: %v", err))
	}
	return v
}

// GetResource retrieves the value with the specified key from
// the Resource map field of Component_IntegratedCircuit_Utilization. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component_IntegratedCircuit_Utilization) GetResource(Name string) *Component_IntegratedCircuit_Utilization_Resource {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Resource[key]; ok {
		return lm
	}
	return nil
}

// DeleteResource deletes the value with the specified keys from
// the receiver Component_IntegratedCircuit_Utilization. If there is no such element, the function
// is a no-op.
func (t *Component_IntegratedCircuit_Utilization) DeleteResource(Name string) {
	key := Name

	delete(t.Resource, key)
}

// AppendResource appends the supplied Component_IntegratedCircuit_Utilization_Resource struct to the
// list Resource of Component_IntegratedCircuit_Utilization. If the key value(s) specified in
// the supplied Component_IntegratedCircuit_Utilization_Resource already exist in the list, an error is
// returned.
func (t *Component_IntegratedCircuit_Utilization) AppendResource(v *Component_IntegratedCircuit_Utilization_Resource) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[string]*Component_IntegratedCircuit_Utilization_Resource)
	}

	if _, ok := t.Resource[key]; ok {
		return fmt.Errorf("duplicate key for list Resource %v", key)
	}

	t.Resource[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_IntegratedCircuit_Utilization) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_IntegratedCircuit_Utilization"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_IntegratedCircuit_Utilization) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_IntegratedCircuit_Utilization) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_IntegratedCircuit_Utilization.
func (*Component_IntegratedCircuit_Utilization) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_IntegratedCircuit_Utilization_Resource represents the /openconfig-platform/components/component/integrated-circuit/utilization/resources/resource YANG schema element.
type Component_IntegratedCircuit_Utilization_Resource struct {
	Committed         *uint64 `path:"state/committed" module:"openconfig-platform/openconfig-platform"`
	Free              *uint64 `path:"state/free" module:"openconfig-platform/openconfig-platform"`
	HighWatermark     *uint64 `path:"state/high-watermark" module:"openconfig-platform/openconfig-platform"`
	LastHighWatermark *uint64 `path:"state/last-high-watermark" module:"openconfig-platform/openconfig-platform"`
	MaxLimit          *uint64 `path:"state/max-limit" module:"openconfig-platform/openconfig-platform"`
	Name              *string `path:"config/name|name" module:"openconfig-platform/openconfig-platform|openconfig-platform" shadow-path:"state/name|name" shadow-module:"openconfig-platform/openconfig-platform|openconfig-platform"`
	Used              *uint64 `path:"state/used" module:"openconfig-platform/openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_IntegratedCircuit_Utilization_Resource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_IntegratedCircuit_Utilization_Resource) IsYANGGoStruct() {}

// GetCommitted retrieves the value of the leaf Committed from the Component_IntegratedCircuit_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Committed is set, it can
// safely use t.GetCommitted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Committed == nil' before retrieving the leaf's value.
func (t *Component_IntegratedCircuit_Utilization_Resource) GetCommitted() uint64 {
	if t == nil || t.Committed == nil {
		return 0
	}
	return *t.Committed
}

// GetFree retrieves the value of the leaf Free from the Component_IntegratedCircuit_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Free is set, it can
// safely use t.GetFree() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Free == nil' before retrieving the leaf's value.
func (t *Component_IntegratedCircuit_Utilization_Resource) GetFree() uint64 {
	if t == nil || t.Free == nil {
		return 0
	}
	return *t.Free
}

// GetHighWatermark retrieves the value of the leaf HighWatermark from the Component_IntegratedCircuit_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighWatermark is set, it can
// safely use t.GetHighWatermark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighWatermark == nil' before retrieving the leaf's value.
func (t *Component_IntegratedCircuit_Utilization_Resource) GetHighWatermark() uint64 {
	if t == nil || t.HighWatermark == nil {
		return 0
	}
	return *t.HighWatermark
}

// GetLastHighWatermark retrieves the value of the leaf LastHighWatermark from the Component_IntegratedCircuit_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastHighWatermark is set, it can
// safely use t.GetLastHighWatermark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastHighWatermark == nil' before retrieving the leaf's value.
func (t *Component_IntegratedCircuit_Utilization_Resource) GetLastHighWatermark() uint64 {
	if t == nil || t.LastHighWatermark == nil {
		return 0
	}
	return *t.LastHighWatermark
}

// GetMaxLimit retrieves the value of the leaf MaxLimit from the Component_IntegratedCircuit_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxLimit is set, it can
// safely use t.GetMaxLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxLimit == nil' before retrieving the leaf's value.
func (t *Component_IntegratedCircuit_Utilization_Resource) GetMaxLimit() uint64 {
	if t == nil || t.MaxLimit == nil {
		return 0
	}
	return *t.MaxLimit
}

// GetName retrieves the value of the leaf Name from the Component_IntegratedCircuit_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Component_IntegratedCircuit_Utilization_Resource) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetUsed retrieves the value of the leaf Used from the Component_IntegratedCircuit_Utilization_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Used is set, it can
// safely use t.GetUsed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Used == nil' before retrieving the leaf's value.
func (t *Component_IntegratedCircuit_Utilization_Resource) GetUsed() uint64 {
	if t == nil || t.Used == nil {
		return 0
	}
	return *t.Used
}

// ΛListKeyMap returns the keys of the Component_IntegratedCircuit_Utilization_Resource struct, which is a YANG list entry.
func (t *Component_IntegratedCircuit_Utilization_Resource) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_IntegratedCircuit_Utilization_Resource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_IntegratedCircuit_Utilization_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_IntegratedCircuit_Utilization_Resource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_IntegratedCircuit_Utilization_Resource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_IntegratedCircuit_Utilization_Resource.
func (*Component_IntegratedCircuit_Utilization_Resource) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_LastSwitchoverReason represents the /openconfig-platform/components/component/state/last-switchover-reason YANG schema element.
type Component_LastSwitchoverReason struct {
	Details *string                                                       `path:"details" module:"openconfig-platform"`
	Trigger E_PlatformTypes_ComponentRedundantRoleSwitchoverReasonTrigger `path:"trigger" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_LastSwitchoverReason implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_LastSwitchoverReason) IsYANGGoStruct() {}

// GetDetails retrieves the value of the leaf Details from the Component_LastSwitchoverReason
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Details is set, it can
// safely use t.GetDetails() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Details == nil' before retrieving the leaf's value.
func (t *Component_LastSwitchoverReason) GetDetails() string {
	if t == nil || t.Details == nil {
		return ""
	}
	return *t.Details
}

// GetTrigger retrieves the value of the leaf Trigger from the Component_LastSwitchoverReason
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trigger is set, it can
// safely use t.GetTrigger() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trigger == nil' before retrieving the leaf's value.
func (t *Component_LastSwitchoverReason) GetTrigger() E_PlatformTypes_ComponentRedundantRoleSwitchoverReasonTrigger {
	if t == nil || t.Trigger == 0 {
		return 0
	}
	return t.Trigger
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_LastSwitchoverReason) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_LastSwitchoverReason"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_LastSwitchoverReason) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_LastSwitchoverReason) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_LastSwitchoverReason.
func (*Component_LastSwitchoverReason) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Memory represents the /openconfig-platform/components/component/state/memory YANG schema element.
type Component_Memory struct {
	Available *uint64 `path:"available" module:"openconfig-platform"`
	Utilized  *uint64 `path:"utilized" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Memory implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Memory) IsYANGGoStruct() {}

// GetAvailable retrieves the value of the leaf Available from the Component_Memory
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Available is set, it can
// safely use t.GetAvailable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Available == nil' before retrieving the leaf's value.
func (t *Component_Memory) GetAvailable() uint64 {
	if t == nil || t.Available == nil {
		return 0
	}
	return *t.Available
}

// GetUtilized retrieves the value of the leaf Utilized from the Component_Memory
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Utilized is set, it can
// safely use t.GetUtilized() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Utilized == nil' before retrieving the leaf's value.
func (t *Component_Memory) GetUtilized() uint64 {
	if t == nil || t.Utilized == nil {
		return 0
	}
	return *t.Utilized
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Memory) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Memory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Memory) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Memory) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Memory.
func (*Component_Memory) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Pcie represents the /openconfig-platform/components/component/state/pcie YANG schema element.
type Component_Pcie struct {
	CorrectableErrors *Component_Pcie_CorrectableErrors `path:"correctable-errors" module:"openconfig-platform"`
	FatalErrors       *Component_Pcie_FatalErrors       `path:"fatal-errors" module:"openconfig-platform"`
	NonFatalErrors    *Component_Pcie_NonFatalErrors    `path:"non-fatal-errors" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Pcie implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Pcie) IsYANGGoStruct() {}

// GetOrCreateCorrectableErrors retrieves the value of the CorrectableErrors field
// or returns the existing field if it already exists.
func (t *Component_Pcie) GetOrCreateCorrectableErrors() *Component_Pcie_CorrectableErrors {
	if t.CorrectableErrors != nil {
		return t.CorrectableErrors
	}
	t.CorrectableErrors = &Component_Pcie_CorrectableErrors{}
	return t.CorrectableErrors
}

// GetOrCreateFatalErrors retrieves the value of the FatalErrors field
// or returns the existing field if it already exists.
func (t *Component_Pcie) GetOrCreateFatalErrors() *Component_Pcie_FatalErrors {
	if t.FatalErrors != nil {
		return t.FatalErrors
	}
	t.FatalErrors = &Component_Pcie_FatalErrors{}
	return t.FatalErrors
}

// GetOrCreateNonFatalErrors retrieves the value of the NonFatalErrors field
// or returns the existing field if it already exists.
func (t *Component_Pcie) GetOrCreateNonFatalErrors() *Component_Pcie_NonFatalErrors {
	if t.NonFatalErrors != nil {
		return t.NonFatalErrors
	}
	t.NonFatalErrors = &Component_Pcie_NonFatalErrors{}
	return t.NonFatalErrors
}

// GetCorrectableErrors returns the value of the CorrectableErrors struct pointer
// from Component_Pcie. If the receiver or the field CorrectableErrors is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Pcie) GetCorrectableErrors() *Component_Pcie_CorrectableErrors {
	if t != nil && t.CorrectableErrors != nil {
		return t.CorrectableErrors
	}
	return nil
}

// GetFatalErrors returns the value of the FatalErrors struct pointer
// from Component_Pcie. If the receiver or the field FatalErrors is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Pcie) GetFatalErrors() *Component_Pcie_FatalErrors {
	if t != nil && t.FatalErrors != nil {
		return t.FatalErrors
	}
	return nil
}

// GetNonFatalErrors returns the value of the NonFatalErrors struct pointer
// from Component_Pcie. If the receiver or the field NonFatalErrors is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Pcie) GetNonFatalErrors() *Component_Pcie_NonFatalErrors {
	if t != nil && t.NonFatalErrors != nil {
		return t.NonFatalErrors
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Pcie) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Pcie"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Pcie) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Pcie) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Pcie.
func (*Component_Pcie) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Pcie_CorrectableErrors represents the /openconfig-platform/components/component/state/pcie/correctable-errors YANG schema element.
type Component_Pcie_CorrectableErrors struct {
	AdvisoryNonFatalErrors *uint64 `path:"advisory-non-fatal-errors" module:"openconfig-platform"`
	BadDllpErrors          *uint64 `path:"bad-dllp-errors" module:"openconfig-platform"`
	BadTlpErrors           *uint64 `path:"bad-tlp-errors" module:"openconfig-platform"`
	HdrLogOverflowErrors   *uint64 `path:"hdr-log-overflow-errors" module:"openconfig-platform"`
	InternalErrors         *uint64 `path:"internal-errors" module:"openconfig-platform"`
	ReceiverErrors         *uint64 `path:"receiver-errors" module:"openconfig-platform"`
	RelayRolloverErrors    *uint64 `path:"relay-rollover-errors" module:"openconfig-platform"`
	ReplayTimeoutErrors    *uint64 `path:"replay-timeout-errors" module:"openconfig-platform"`
	TotalErrors            *uint64 `path:"total-errors" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Pcie_CorrectableErrors implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Pcie_CorrectableErrors) IsYANGGoStruct() {}

// GetAdvisoryNonFatalErrors retrieves the value of the leaf AdvisoryNonFatalErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvisoryNonFatalErrors is set, it can
// safely use t.GetAdvisoryNonFatalErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvisoryNonFatalErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetAdvisoryNonFatalErrors() uint64 {
	if t == nil || t.AdvisoryNonFatalErrors == nil {
		return 0
	}
	return *t.AdvisoryNonFatalErrors
}

// GetBadDllpErrors retrieves the value of the leaf BadDllpErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BadDllpErrors is set, it can
// safely use t.GetBadDllpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BadDllpErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetBadDllpErrors() uint64 {
	if t == nil || t.BadDllpErrors == nil {
		return 0
	}
	return *t.BadDllpErrors
}

// GetBadTlpErrors retrieves the value of the leaf BadTlpErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BadTlpErrors is set, it can
// safely use t.GetBadTlpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BadTlpErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetBadTlpErrors() uint64 {
	if t == nil || t.BadTlpErrors == nil {
		return 0
	}
	return *t.BadTlpErrors
}

// GetHdrLogOverflowErrors retrieves the value of the leaf HdrLogOverflowErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HdrLogOverflowErrors is set, it can
// safely use t.GetHdrLogOverflowErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HdrLogOverflowErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetHdrLogOverflowErrors() uint64 {
	if t == nil || t.HdrLogOverflowErrors == nil {
		return 0
	}
	return *t.HdrLogOverflowErrors
}

// GetInternalErrors retrieves the value of the leaf InternalErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InternalErrors is set, it can
// safely use t.GetInternalErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InternalErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetInternalErrors() uint64 {
	if t == nil || t.InternalErrors == nil {
		return 0
	}
	return *t.InternalErrors
}

// GetReceiverErrors retrieves the value of the leaf ReceiverErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReceiverErrors is set, it can
// safely use t.GetReceiverErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReceiverErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetReceiverErrors() uint64 {
	if t == nil || t.ReceiverErrors == nil {
		return 0
	}
	return *t.ReceiverErrors
}

// GetRelayRolloverErrors retrieves the value of the leaf RelayRolloverErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RelayRolloverErrors is set, it can
// safely use t.GetRelayRolloverErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RelayRolloverErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetRelayRolloverErrors() uint64 {
	if t == nil || t.RelayRolloverErrors == nil {
		return 0
	}
	return *t.RelayRolloverErrors
}

// GetReplayTimeoutErrors retrieves the value of the leaf ReplayTimeoutErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplayTimeoutErrors is set, it can
// safely use t.GetReplayTimeoutErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplayTimeoutErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetReplayTimeoutErrors() uint64 {
	if t == nil || t.ReplayTimeoutErrors == nil {
		return 0
	}
	return *t.ReplayTimeoutErrors
}

// GetTotalErrors retrieves the value of the leaf TotalErrors from the Component_Pcie_CorrectableErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalErrors is set, it can
// safely use t.GetTotalErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_CorrectableErrors) GetTotalErrors() uint64 {
	if t == nil || t.TotalErrors == nil {
		return 0
	}
	return *t.TotalErrors
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Pcie_CorrectableErrors) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Pcie_CorrectableErrors"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Pcie_CorrectableErrors) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Pcie_CorrectableErrors) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Pcie_CorrectableErrors.
func (*Component_Pcie_CorrectableErrors) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Pcie_FatalErrors represents the /openconfig-platform/components/component/state/pcie/fatal-errors YANG schema element.
type Component_Pcie_FatalErrors struct {
	AcsViolationErrors         *uint64 `path:"acs-violation-errors" module:"openconfig-platform"`
	AtomicOpBlockedErrors      *uint64 `path:"atomic-op-blocked-errors" module:"openconfig-platform"`
	BlockedTlpErrors           *uint64 `path:"blocked-tlp-errors" module:"openconfig-platform"`
	CompletionAbortErrors      *uint64 `path:"completion-abort-errors" module:"openconfig-platform"`
	CompletionTimeoutErrors    *uint64 `path:"completion-timeout-errors" module:"openconfig-platform"`
	DataLinkErrors             *uint64 `path:"data-link-errors" module:"openconfig-platform"`
	EcrcErrors                 *uint64 `path:"ecrc-errors" module:"openconfig-platform"`
	FlowControlProtocolErrors  *uint64 `path:"flow-control-protocol-errors" module:"openconfig-platform"`
	InternalErrors             *uint64 `path:"internal-errors" module:"openconfig-platform"`
	MalformedTlpErrors         *uint64 `path:"malformed-tlp-errors" module:"openconfig-platform"`
	PoisonedTlpErrors          *uint64 `path:"poisoned-tlp-errors" module:"openconfig-platform"`
	ReceiverOverflowErrors     *uint64 `path:"receiver-overflow-errors" module:"openconfig-platform"`
	SurpriseDownErrors         *uint64 `path:"surprise-down-errors" module:"openconfig-platform"`
	TlpPrefixBlockedErrors     *uint64 `path:"tlp-prefix-blocked-errors" module:"openconfig-platform"`
	TotalErrors                *uint64 `path:"total-errors" module:"openconfig-platform"`
	UndefinedErrors            *uint64 `path:"undefined-errors" module:"openconfig-platform"`
	UnexpectedCompletionErrors *uint64 `path:"unexpected-completion-errors" module:"openconfig-platform"`
	UnsupportedRequestErrors   *uint64 `path:"unsupported-request-errors" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Pcie_FatalErrors implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Pcie_FatalErrors) IsYANGGoStruct() {}

// GetAcsViolationErrors retrieves the value of the leaf AcsViolationErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcsViolationErrors is set, it can
// safely use t.GetAcsViolationErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcsViolationErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetAcsViolationErrors() uint64 {
	if t == nil || t.AcsViolationErrors == nil {
		return 0
	}
	return *t.AcsViolationErrors
}

// GetAtomicOpBlockedErrors retrieves the value of the leaf AtomicOpBlockedErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AtomicOpBlockedErrors is set, it can
// safely use t.GetAtomicOpBlockedErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AtomicOpBlockedErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetAtomicOpBlockedErrors() uint64 {
	if t == nil || t.AtomicOpBlockedErrors == nil {
		return 0
	}
	return *t.AtomicOpBlockedErrors
}

// GetBlockedTlpErrors retrieves the value of the leaf BlockedTlpErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BlockedTlpErrors is set, it can
// safely use t.GetBlockedTlpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BlockedTlpErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetBlockedTlpErrors() uint64 {
	if t == nil || t.BlockedTlpErrors == nil {
		return 0
	}
	return *t.BlockedTlpErrors
}

// GetCompletionAbortErrors retrieves the value of the leaf CompletionAbortErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CompletionAbortErrors is set, it can
// safely use t.GetCompletionAbortErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CompletionAbortErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetCompletionAbortErrors() uint64 {
	if t == nil || t.CompletionAbortErrors == nil {
		return 0
	}
	return *t.CompletionAbortErrors
}

// GetCompletionTimeoutErrors retrieves the value of the leaf CompletionTimeoutErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CompletionTimeoutErrors is set, it can
// safely use t.GetCompletionTimeoutErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CompletionTimeoutErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetCompletionTimeoutErrors() uint64 {
	if t == nil || t.CompletionTimeoutErrors == nil {
		return 0
	}
	return *t.CompletionTimeoutErrors
}

// GetDataLinkErrors retrieves the value of the leaf DataLinkErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DataLinkErrors is set, it can
// safely use t.GetDataLinkErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DataLinkErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetDataLinkErrors() uint64 {
	if t == nil || t.DataLinkErrors == nil {
		return 0
	}
	return *t.DataLinkErrors
}

// GetEcrcErrors retrieves the value of the leaf EcrcErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EcrcErrors is set, it can
// safely use t.GetEcrcErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EcrcErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetEcrcErrors() uint64 {
	if t == nil || t.EcrcErrors == nil {
		return 0
	}
	return *t.EcrcErrors
}

// GetFlowControlProtocolErrors retrieves the value of the leaf FlowControlProtocolErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowControlProtocolErrors is set, it can
// safely use t.GetFlowControlProtocolErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowControlProtocolErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetFlowControlProtocolErrors() uint64 {
	if t == nil || t.FlowControlProtocolErrors == nil {
		return 0
	}
	return *t.FlowControlProtocolErrors
}

// GetInternalErrors retrieves the value of the leaf InternalErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InternalErrors is set, it can
// safely use t.GetInternalErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InternalErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetInternalErrors() uint64 {
	if t == nil || t.InternalErrors == nil {
		return 0
	}
	return *t.InternalErrors
}

// GetMalformedTlpErrors retrieves the value of the leaf MalformedTlpErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MalformedTlpErrors is set, it can
// safely use t.GetMalformedTlpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MalformedTlpErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetMalformedTlpErrors() uint64 {
	if t == nil || t.MalformedTlpErrors == nil {
		return 0
	}
	return *t.MalformedTlpErrors
}

// GetPoisonedTlpErrors retrieves the value of the leaf PoisonedTlpErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PoisonedTlpErrors is set, it can
// safely use t.GetPoisonedTlpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PoisonedTlpErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetPoisonedTlpErrors() uint64 {
	if t == nil || t.PoisonedTlpErrors == nil {
		return 0
	}
	return *t.PoisonedTlpErrors
}

// GetReceiverOverflowErrors retrieves the value of the leaf ReceiverOverflowErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReceiverOverflowErrors is set, it can
// safely use t.GetReceiverOverflowErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReceiverOverflowErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetReceiverOverflowErrors() uint64 {
	if t == nil || t.ReceiverOverflowErrors == nil {
		return 0
	}
	return *t.ReceiverOverflowErrors
}

// GetSurpriseDownErrors retrieves the value of the leaf SurpriseDownErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SurpriseDownErrors is set, it can
// safely use t.GetSurpriseDownErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SurpriseDownErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetSurpriseDownErrors() uint64 {
	if t == nil || t.SurpriseDownErrors == nil {
		return 0
	}
	return *t.SurpriseDownErrors
}

// GetTlpPrefixBlockedErrors retrieves the value of the leaf TlpPrefixBlockedErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlpPrefixBlockedErrors is set, it can
// safely use t.GetTlpPrefixBlockedErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlpPrefixBlockedErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetTlpPrefixBlockedErrors() uint64 {
	if t == nil || t.TlpPrefixBlockedErrors == nil {
		return 0
	}
	return *t.TlpPrefixBlockedErrors
}

// GetTotalErrors retrieves the value of the leaf TotalErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalErrors is set, it can
// safely use t.GetTotalErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetTotalErrors() uint64 {
	if t == nil || t.TotalErrors == nil {
		return 0
	}
	return *t.TotalErrors
}

// GetUndefinedErrors retrieves the value of the leaf UndefinedErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UndefinedErrors is set, it can
// safely use t.GetUndefinedErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UndefinedErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetUndefinedErrors() uint64 {
	if t == nil || t.UndefinedErrors == nil {
		return 0
	}
	return *t.UndefinedErrors
}

// GetUnexpectedCompletionErrors retrieves the value of the leaf UnexpectedCompletionErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnexpectedCompletionErrors is set, it can
// safely use t.GetUnexpectedCompletionErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnexpectedCompletionErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetUnexpectedCompletionErrors() uint64 {
	if t == nil || t.UnexpectedCompletionErrors == nil {
		return 0
	}
	return *t.UnexpectedCompletionErrors
}

// GetUnsupportedRequestErrors retrieves the value of the leaf UnsupportedRequestErrors from the Component_Pcie_FatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnsupportedRequestErrors is set, it can
// safely use t.GetUnsupportedRequestErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnsupportedRequestErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_FatalErrors) GetUnsupportedRequestErrors() uint64 {
	if t == nil || t.UnsupportedRequestErrors == nil {
		return 0
	}
	return *t.UnsupportedRequestErrors
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Pcie_FatalErrors) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Pcie_FatalErrors"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Pcie_FatalErrors) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Pcie_FatalErrors) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Pcie_FatalErrors.
func (*Component_Pcie_FatalErrors) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Pcie_NonFatalErrors represents the /openconfig-platform/components/component/state/pcie/non-fatal-errors YANG schema element.
type Component_Pcie_NonFatalErrors struct {
	AcsViolationErrors         *uint64 `path:"acs-violation-errors" module:"openconfig-platform"`
	AtomicOpBlockedErrors      *uint64 `path:"atomic-op-blocked-errors" module:"openconfig-platform"`
	BlockedTlpErrors           *uint64 `path:"blocked-tlp-errors" module:"openconfig-platform"`
	CompletionAbortErrors      *uint64 `path:"completion-abort-errors" module:"openconfig-platform"`
	CompletionTimeoutErrors    *uint64 `path:"completion-timeout-errors" module:"openconfig-platform"`
	DataLinkErrors             *uint64 `path:"data-link-errors" module:"openconfig-platform"`
	EcrcErrors                 *uint64 `path:"ecrc-errors" module:"openconfig-platform"`
	FlowControlProtocolErrors  *uint64 `path:"flow-control-protocol-errors" module:"openconfig-platform"`
	InternalErrors             *uint64 `path:"internal-errors" module:"openconfig-platform"`
	MalformedTlpErrors         *uint64 `path:"malformed-tlp-errors" module:"openconfig-platform"`
	PoisonedTlpErrors          *uint64 `path:"poisoned-tlp-errors" module:"openconfig-platform"`
	ReceiverOverflowErrors     *uint64 `path:"receiver-overflow-errors" module:"openconfig-platform"`
	SurpriseDownErrors         *uint64 `path:"surprise-down-errors" module:"openconfig-platform"`
	TlpPrefixBlockedErrors     *uint64 `path:"tlp-prefix-blocked-errors" module:"openconfig-platform"`
	TotalErrors                *uint64 `path:"total-errors" module:"openconfig-platform"`
	UndefinedErrors            *uint64 `path:"undefined-errors" module:"openconfig-platform"`
	UnexpectedCompletionErrors *uint64 `path:"unexpected-completion-errors" module:"openconfig-platform"`
	UnsupportedRequestErrors   *uint64 `path:"unsupported-request-errors" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Pcie_NonFatalErrors implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Pcie_NonFatalErrors) IsYANGGoStruct() {}

// GetAcsViolationErrors retrieves the value of the leaf AcsViolationErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcsViolationErrors is set, it can
// safely use t.GetAcsViolationErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcsViolationErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetAcsViolationErrors() uint64 {
	if t == nil || t.AcsViolationErrors == nil {
		return 0
	}
	return *t.AcsViolationErrors
}

// GetAtomicOpBlockedErrors retrieves the value of the leaf AtomicOpBlockedErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AtomicOpBlockedErrors is set, it can
// safely use t.GetAtomicOpBlockedErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AtomicOpBlockedErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetAtomicOpBlockedErrors() uint64 {
	if t == nil || t.AtomicOpBlockedErrors == nil {
		return 0
	}
	return *t.AtomicOpBlockedErrors
}

// GetBlockedTlpErrors retrieves the value of the leaf BlockedTlpErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BlockedTlpErrors is set, it can
// safely use t.GetBlockedTlpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BlockedTlpErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetBlockedTlpErrors() uint64 {
	if t == nil || t.BlockedTlpErrors == nil {
		return 0
	}
	return *t.BlockedTlpErrors
}

// GetCompletionAbortErrors retrieves the value of the leaf CompletionAbortErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CompletionAbortErrors is set, it can
// safely use t.GetCompletionAbortErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CompletionAbortErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetCompletionAbortErrors() uint64 {
	if t == nil || t.CompletionAbortErrors == nil {
		return 0
	}
	return *t.CompletionAbortErrors
}

// GetCompletionTimeoutErrors retrieves the value of the leaf CompletionTimeoutErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CompletionTimeoutErrors is set, it can
// safely use t.GetCompletionTimeoutErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CompletionTimeoutErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetCompletionTimeoutErrors() uint64 {
	if t == nil || t.CompletionTimeoutErrors == nil {
		return 0
	}
	return *t.CompletionTimeoutErrors
}

// GetDataLinkErrors retrieves the value of the leaf DataLinkErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DataLinkErrors is set, it can
// safely use t.GetDataLinkErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DataLinkErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetDataLinkErrors() uint64 {
	if t == nil || t.DataLinkErrors == nil {
		return 0
	}
	return *t.DataLinkErrors
}

// GetEcrcErrors retrieves the value of the leaf EcrcErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EcrcErrors is set, it can
// safely use t.GetEcrcErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EcrcErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetEcrcErrors() uint64 {
	if t == nil || t.EcrcErrors == nil {
		return 0
	}
	return *t.EcrcErrors
}

// GetFlowControlProtocolErrors retrieves the value of the leaf FlowControlProtocolErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowControlProtocolErrors is set, it can
// safely use t.GetFlowControlProtocolErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowControlProtocolErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetFlowControlProtocolErrors() uint64 {
	if t == nil || t.FlowControlProtocolErrors == nil {
		return 0
	}
	return *t.FlowControlProtocolErrors
}

// GetInternalErrors retrieves the value of the leaf InternalErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InternalErrors is set, it can
// safely use t.GetInternalErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InternalErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetInternalErrors() uint64 {
	if t == nil || t.InternalErrors == nil {
		return 0
	}
	return *t.InternalErrors
}

// GetMalformedTlpErrors retrieves the value of the leaf MalformedTlpErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MalformedTlpErrors is set, it can
// safely use t.GetMalformedTlpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MalformedTlpErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetMalformedTlpErrors() uint64 {
	if t == nil || t.MalformedTlpErrors == nil {
		return 0
	}
	return *t.MalformedTlpErrors
}

// GetPoisonedTlpErrors retrieves the value of the leaf PoisonedTlpErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PoisonedTlpErrors is set, it can
// safely use t.GetPoisonedTlpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PoisonedTlpErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetPoisonedTlpErrors() uint64 {
	if t == nil || t.PoisonedTlpErrors == nil {
		return 0
	}
	return *t.PoisonedTlpErrors
}

// GetReceiverOverflowErrors retrieves the value of the leaf ReceiverOverflowErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReceiverOverflowErrors is set, it can
// safely use t.GetReceiverOverflowErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReceiverOverflowErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetReceiverOverflowErrors() uint64 {
	if t == nil || t.ReceiverOverflowErrors == nil {
		return 0
	}
	return *t.ReceiverOverflowErrors
}

// GetSurpriseDownErrors retrieves the value of the leaf SurpriseDownErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SurpriseDownErrors is set, it can
// safely use t.GetSurpriseDownErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SurpriseDownErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetSurpriseDownErrors() uint64 {
	if t == nil || t.SurpriseDownErrors == nil {
		return 0
	}
	return *t.SurpriseDownErrors
}

// GetTlpPrefixBlockedErrors retrieves the value of the leaf TlpPrefixBlockedErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlpPrefixBlockedErrors is set, it can
// safely use t.GetTlpPrefixBlockedErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlpPrefixBlockedErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetTlpPrefixBlockedErrors() uint64 {
	if t == nil || t.TlpPrefixBlockedErrors == nil {
		return 0
	}
	return *t.TlpPrefixBlockedErrors
}

// GetTotalErrors retrieves the value of the leaf TotalErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalErrors is set, it can
// safely use t.GetTotalErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetTotalErrors() uint64 {
	if t == nil || t.TotalErrors == nil {
		return 0
	}
	return *t.TotalErrors
}

// GetUndefinedErrors retrieves the value of the leaf UndefinedErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UndefinedErrors is set, it can
// safely use t.GetUndefinedErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UndefinedErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetUndefinedErrors() uint64 {
	if t == nil || t.UndefinedErrors == nil {
		return 0
	}
	return *t.UndefinedErrors
}

// GetUnexpectedCompletionErrors retrieves the value of the leaf UnexpectedCompletionErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnexpectedCompletionErrors is set, it can
// safely use t.GetUnexpectedCompletionErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnexpectedCompletionErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetUnexpectedCompletionErrors() uint64 {
	if t == nil || t.UnexpectedCompletionErrors == nil {
		return 0
	}
	return *t.UnexpectedCompletionErrors
}

// GetUnsupportedRequestErrors retrieves the value of the leaf UnsupportedRequestErrors from the Component_Pcie_NonFatalErrors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnsupportedRequestErrors is set, it can
// safely use t.GetUnsupportedRequestErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnsupportedRequestErrors == nil' before retrieving the leaf's value.
func (t *Component_Pcie_NonFatalErrors) GetUnsupportedRequestErrors() uint64 {
	if t == nil || t.UnsupportedRequestErrors == nil {
		return 0
	}
	return *t.UnsupportedRequestErrors
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Pcie_NonFatalErrors) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Pcie_NonFatalErrors"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Pcie_NonFatalErrors) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Pcie_NonFatalErrors) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Pcie_NonFatalErrors.
func (*Component_Pcie_NonFatalErrors) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Port represents the /openconfig-platform/components/component/port YANG schema element.
type Component_Port struct {
	BreakoutMode *Component_Port_BreakoutMode `path:"breakout-mode" module:"openconfig-platform-port"`
}

// IsYANGGoStruct ensures that Component_Port implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Port) IsYANGGoStruct() {}

// GetOrCreateBreakoutMode retrieves the value of the BreakoutMode field
// or returns the existing field if it already exists.
func (t *Component_Port) GetOrCreateBreakoutMode() *Component_Port_BreakoutMode {
	if t.BreakoutMode != nil {
		return t.BreakoutMode
	}
	t.BreakoutMode = &Component_Port_BreakoutMode{}
	return t.BreakoutMode
}

// GetBreakoutMode returns the value of the BreakoutMode struct pointer
// from Component_Port. If the receiver or the field BreakoutMode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Component_Port) GetBreakoutMode() *Component_Port_BreakoutMode {
	if t != nil && t.BreakoutMode != nil {
		return t.BreakoutMode
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Port) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Port"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Port) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Port) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Port.
func (*Component_Port) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Port_BreakoutMode represents the /openconfig-platform/components/component/port/breakout-mode YANG schema element.
type Component_Port_BreakoutMode struct {
	Group map[uint8]*Component_Port_BreakoutMode_Group `path:"groups/group" module:"openconfig-platform-port/openconfig-platform-port"`
}

// IsYANGGoStruct ensures that Component_Port_BreakoutMode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Port_BreakoutMode) IsYANGGoStruct() {}

// NewGroup creates a new entry in the Group list of the
// Component_Port_BreakoutMode struct. The keys of the list are populated from the input
// arguments.
func (t *Component_Port_BreakoutMode) NewGroup(Index uint8) (*Component_Port_BreakoutMode_Group, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[uint8]*Component_Port_BreakoutMode_Group)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &Component_Port_BreakoutMode_Group{
		Index: &Index,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the Component_Port_BreakoutMode struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component_Port_BreakoutMode) RenameGroup(oldK, newK uint8) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Index = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver Component_Port_BreakoutMode. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component_Port_BreakoutMode) GetOrCreateGroup(Index uint8) *Component_Port_BreakoutMode_Group {

	key := Index

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of Component_Port_BreakoutMode. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component_Port_BreakoutMode) GetGroup(Index uint8) *Component_Port_BreakoutMode_Group {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Group[key]; ok {
		return lm
	}
	return nil
}

// DeleteGroup deletes the value with the specified keys from
// the receiver Component_Port_BreakoutMode. If there is no such element, the function
// is a no-op.
func (t *Component_Port_BreakoutMode) DeleteGroup(Index uint8) {
	key := Index

	delete(t.Group, key)
}

// AppendGroup appends the supplied Component_Port_BreakoutMode_Group struct to the
// list Group of Component_Port_BreakoutMode. If the key value(s) specified in
// the supplied Component_Port_BreakoutMode_Group already exist in the list, an error is
// returned.
func (t *Component_Port_BreakoutMode) AppendGroup(v *Component_Port_BreakoutMode_Group) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[uint8]*Component_Port_BreakoutMode_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Port_BreakoutMode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Port_BreakoutMode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Port_BreakoutMode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Port_BreakoutMode) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Port_BreakoutMode.
func (*Component_Port_BreakoutMode) ΛBelongingModule() string {
	return "openconfig-platform-port"
}

// Component_Port_BreakoutMode_Group represents the /openconfig-platform/components/component/port/breakout-mode/groups/group YANG schema element.
type Component_Port_BreakoutMode_Group struct {
	BreakoutSpeed       E_IfEthernet_ETHERNET_SPEED `path:"config/breakout-speed" module:"openconfig-platform-port/openconfig-platform-port" shadow-path:"state/breakout-speed" shadow-module:"openconfig-platform-port/openconfig-platform-port"`
	Index               *uint8                      `path:"config/index|index" module:"openconfig-platform-port/openconfig-platform-port|openconfig-platform-port" shadow-path:"state/index|index" shadow-module:"openconfig-platform-port/openconfig-platform-port|openconfig-platform-port"`
	NumBreakouts        *uint8                      `path:"config/num-breakouts" module:"openconfig-platform-port/openconfig-platform-port" shadow-path:"state/num-breakouts" shadow-module:"openconfig-platform-port/openconfig-platform-port"`
	NumPhysicalChannels *uint8                      `path:"config/num-physical-channels" module:"openconfig-platform-port/openconfig-platform-port" shadow-path:"state/num-physical-channels" shadow-module:"openconfig-platform-port/openconfig-platform-port"`
}

// IsYANGGoStruct ensures that Component_Port_BreakoutMode_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Port_BreakoutMode_Group) IsYANGGoStruct() {}

// GetBreakoutSpeed retrieves the value of the leaf BreakoutSpeed from the Component_Port_BreakoutMode_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BreakoutSpeed is set, it can
// safely use t.GetBreakoutSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BreakoutSpeed == nil' before retrieving the leaf's value.
func (t *Component_Port_BreakoutMode_Group) GetBreakoutSpeed() E_IfEthernet_ETHERNET_SPEED {
	if t == nil || t.BreakoutSpeed == 0 {
		return 0
	}
	return t.BreakoutSpeed
}

// GetIndex retrieves the value of the leaf Index from the Component_Port_BreakoutMode_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *Component_Port_BreakoutMode_Group) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetNumBreakouts retrieves the value of the leaf NumBreakouts from the Component_Port_BreakoutMode_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NumBreakouts is set, it can
// safely use t.GetNumBreakouts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NumBreakouts == nil' before retrieving the leaf's value.
func (t *Component_Port_BreakoutMode_Group) GetNumBreakouts() uint8 {
	if t == nil || t.NumBreakouts == nil {
		return 0
	}
	return *t.NumBreakouts
}

// GetNumPhysicalChannels retrieves the value of the leaf NumPhysicalChannels from the Component_Port_BreakoutMode_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NumPhysicalChannels is set, it can
// safely use t.GetNumPhysicalChannels() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NumPhysicalChannels == nil' before retrieving the leaf's value.
func (t *Component_Port_BreakoutMode_Group) GetNumPhysicalChannels() uint8 {
	if t == nil || t.NumPhysicalChannels == nil {
		return 0
	}
	return *t.NumPhysicalChannels
}

// ΛListKeyMap returns the keys of the Component_Port_BreakoutMode_Group struct, which is a YANG list entry.
func (t *Component_Port_BreakoutMode_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Port_BreakoutMode_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Port_BreakoutMode_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Port_BreakoutMode_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Port_BreakoutMode_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Port_BreakoutMode_Group.
func (*Component_Port_BreakoutMode_Group) ΛBelongingModule() string {
	return "openconfig-platform-port"
}

// Component_PowerSupply represents the /openconfig-platform/components/component/power-supply YANG schema element.
type Component_PowerSupply struct {
}

// IsYANGGoStruct ensures that Component_PowerSupply implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_PowerSupply) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_PowerSupply) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_PowerSupply"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_PowerSupply) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_PowerSupply) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_PowerSupply.
func (*Component_PowerSupply) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Property represents the /openconfig-platform/components/component/properties/property YANG schema element.
type Component_Property struct {
	Configurable *bool                          `path:"state/configurable" module:"openconfig-platform/openconfig-platform"`
	Name         *string                        `path:"config/name|name" module:"openconfig-platform/openconfig-platform|openconfig-platform" shadow-path:"state/name|name" shadow-module:"openconfig-platform/openconfig-platform|openconfig-platform"`
	Value        Component_Property_Value_Union `path:"config/value" module:"openconfig-platform/openconfig-platform" shadow-path:"state/value" shadow-module:"openconfig-platform/openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Property implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Property) IsYANGGoStruct() {}

// GetConfigurable retrieves the value of the leaf Configurable from the Component_Property
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Configurable is set, it can
// safely use t.GetConfigurable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Configurable == nil' before retrieving the leaf's value.
func (t *Component_Property) GetConfigurable() bool {
	if t == nil || t.Configurable == nil {
		return false
	}
	return *t.Configurable
}

// GetName retrieves the value of the leaf Name from the Component_Property
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Component_Property) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetValue retrieves the value of the leaf Value from the Component_Property
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *Component_Property) GetValue() Component_Property_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// ΛListKeyMap returns the keys of the Component_Property struct, which is a YANG list entry.
func (t *Component_Property) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Property) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Property"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Property) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Property) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Property.
func (*Component_Property) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_SoftwareModule represents the /openconfig-platform/components/component/software-module YANG schema element.
type Component_SoftwareModule struct {
}

// IsYANGGoStruct ensures that Component_SoftwareModule implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_SoftwareModule) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_SoftwareModule) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_SoftwareModule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_SoftwareModule) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_SoftwareModule) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_SoftwareModule.
func (*Component_SoftwareModule) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Storage represents the /openconfig-platform/components/component/storage YANG schema element.
type Component_Storage struct {
}

// IsYANGGoStruct ensures that Component_Storage implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Storage) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Storage) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Storage"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Storage) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Storage) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Storage.
func (*Component_Storage) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Subcomponent represents the /openconfig-platform/components/component/subcomponents/subcomponent YANG schema element.
type Component_Subcomponent struct {
	Name *string `path:"config/name|name" module:"openconfig-platform/openconfig-platform|openconfig-platform" shadow-path:"state/name|name" shadow-module:"openconfig-platform/openconfig-platform|openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Subcomponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Subcomponent) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the Component_Subcomponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Component_Subcomponent) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the Component_Subcomponent struct, which is a YANG list entry.
func (t *Component_Subcomponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Subcomponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Subcomponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Subcomponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Subcomponent) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Subcomponent.
func (*Component_Subcomponent) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Component_Temperature represents the /openconfig-platform/components/component/state/temperature YANG schema element.
type Component_Temperature struct {
	AlarmSeverity  E_AlarmTypes_OPENCONFIG_ALARM_SEVERITY `path:"alarm-severity" module:"openconfig-platform"`
	AlarmStatus    *bool                                  `path:"alarm-status" module:"openconfig-platform"`
	AlarmThreshold *uint32                                `path:"alarm-threshold" module:"openconfig-platform"`
	Avg            *float64                               `path:"avg" module:"openconfig-platform"`
	Instant        *float64                               `path:"instant" module:"openconfig-platform"`
	Interval       *uint64                                `path:"interval" module:"openconfig-platform"`
	Max            *float64                               `path:"max" module:"openconfig-platform"`
	MaxTime        *uint64                                `path:"max-time" module:"openconfig-platform"`
	Min            *float64                               `path:"min" module:"openconfig-platform"`
	MinTime        *uint64                                `path:"min-time" module:"openconfig-platform"`
}

// IsYANGGoStruct ensures that Component_Temperature implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Component_Temperature) IsYANGGoStruct() {}

// GetAlarmSeverity retrieves the value of the leaf AlarmSeverity from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AlarmSeverity is set, it can
// safely use t.GetAlarmSeverity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AlarmSeverity == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetAlarmSeverity() E_AlarmTypes_OPENCONFIG_ALARM_SEVERITY {
	if t == nil || t.AlarmSeverity == 0 {
		return 0
	}
	return t.AlarmSeverity
}

// GetAlarmStatus retrieves the value of the leaf AlarmStatus from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AlarmStatus is set, it can
// safely use t.GetAlarmStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AlarmStatus == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetAlarmStatus() bool {
	if t == nil || t.AlarmStatus == nil {
		return false
	}
	return *t.AlarmStatus
}

// GetAlarmThreshold retrieves the value of the leaf AlarmThreshold from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AlarmThreshold is set, it can
// safely use t.GetAlarmThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AlarmThreshold == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetAlarmThreshold() uint32 {
	if t == nil || t.AlarmThreshold == nil {
		return 0
	}
	return *t.AlarmThreshold
}

// GetAvg retrieves the value of the leaf Avg from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Avg is set, it can
// safely use t.GetAvg() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Avg == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetAvg() float64 {
	if t == nil || t.Avg == nil {
		return 0.0
	}
	return *t.Avg
}

// GetInstant retrieves the value of the leaf Instant from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Instant is set, it can
// safely use t.GetInstant() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Instant == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetInstant() float64 {
	if t == nil || t.Instant == nil {
		return 0.0
	}
	return *t.Instant
}

// GetInterval retrieves the value of the leaf Interval from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetInterval() uint64 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetMax retrieves the value of the leaf Max from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Max is set, it can
// safely use t.GetMax() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Max == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetMax() float64 {
	if t == nil || t.Max == nil {
		return 0.0
	}
	return *t.Max
}

// GetMaxTime retrieves the value of the leaf MaxTime from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxTime is set, it can
// safely use t.GetMaxTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxTime == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetMaxTime() uint64 {
	if t == nil || t.MaxTime == nil {
		return 0
	}
	return *t.MaxTime
}

// GetMin retrieves the value of the leaf Min from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Min is set, it can
// safely use t.GetMin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Min == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetMin() float64 {
	if t == nil || t.Min == nil {
		return 0.0
	}
	return *t.Min
}

// GetMinTime retrieves the value of the leaf MinTime from the Component_Temperature
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinTime is set, it can
// safely use t.GetMinTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinTime == nil' before retrieving the leaf's value.
func (t *Component_Temperature) GetMinTime() uint64 {
	if t == nil || t.MinTime == nil {
		return 0
	}
	return *t.MinTime
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Temperature) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Temperature"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Component_Temperature) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Temperature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Component_Temperature.
func (*Component_Temperature) ΛBelongingModule() string {
	return "openconfig-platform"
}

// Device represents the /device YANG schema element.
type Device struct {
	Acl             *Acl                        `path:"acl" module:"openconfig-acl"`
	Component       map[string]*Component       `path:"components/component" module:"openconfig-platform/openconfig-platform"`
	Interface       map[string]*Interface       `path:"interfaces/interface" module:"openconfig-interfaces/openconfig-interfaces"`
	Keychain        map[string]*Keychain        `path:"keychains/keychain" module:"openconfig-keychain/openconfig-keychain"`
	Lacp            *Lacp                       `path:"lacp" module:"openconfig-lacp"`
	Lldp            *Lldp                       `path:"lldp" module:"openconfig-lldp"`
	Macsec          *Macsec                     `path:"macsec" module:"openconfig-macsec"`
	NetworkInstance map[string]*NetworkInstance `path:"network-instances/network-instance" module:"openconfig-network-instance/openconfig-network-instance"`
	Qos             *Qos                        `path:"qos" module:"openconfig-qos"`
	RelayAgent      *RelayAgent                 `path:"relay-agent" module:"openconfig-relay-agent"`
	RoutingPolicy   *RoutingPolicy              `path:"routing-policy" module:"openconfig-routing-policy"`
	Sampling        *Sampling                   `path:"sampling" module:"openconfig-sampling"`
	Stp             *Stp                        `path:"stp" module:"openconfig-spanning-tree"`
	System          *System                     `path:"system" module:"openconfig-system"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// NewComponent creates a new entry in the Component list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewComponent(Name string) (*Component, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Component == nil {
		t.Component = make(map[string]*Component)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Component[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Component", key)
	}

	t.Component[key] = &Component{
		Name: &Name,
	}

	return t.Component[key], nil
}

// RenameComponent renames an entry in the list Component within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameComponent(oldK, newK string) error {
	if _, ok := t.Component[newK]; ok {
		return fmt.Errorf("key %v already exists in Component", newK)
	}

	e, ok := t.Component[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Component", oldK)
	}
	e.Name = &newK

	t.Component[newK] = e
	delete(t.Component, oldK)
	return nil
}

// GetOrCreateComponent retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateComponent(Name string) *Component {

	key := Name

	if v, ok := t.Component[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewComponent(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateComponent got unexpected error: %v", err))
	}
	return v
}

// GetComponent retrieves the value with the specified key from
// the Component map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetComponent(Name string) *Component {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Component[key]; ok {
		return lm
	}
	return nil
}

// DeleteComponent deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteComponent(Name string) {
	key := Name

	delete(t.Component, key)
}

// AppendComponent appends the supplied Component struct to the
// list Component of Device. If the key value(s) specified in
// the supplied Component already exist in the list, an error is
// returned.
func (t *Device) AppendComponent(v *Component) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Component == nil {
		t.Component = make(map[string]*Component)
	}

	if _, ok := t.Component[key]; ok {
		return fmt.Errorf("duplicate key for list Component %v", key)
	}

	t.Component[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewInterface(Name string) (*Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateInterface(Name string) *Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetInterface(Name string) *Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Interface struct to the
// list Interface of Device. If the key value(s) specified in
// the supplied Interface already exist in the list, an error is
// returned.
func (t *Device) AppendInterface(v *Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewKeychain creates a new entry in the Keychain list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewKeychain(Name string) (*Keychain, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Keychain == nil {
		t.Keychain = make(map[string]*Keychain)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Keychain[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Keychain", key)
	}

	t.Keychain[key] = &Keychain{
		Name: &Name,
	}

	return t.Keychain[key], nil
}

// RenameKeychain renames an entry in the list Keychain within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameKeychain(oldK, newK string) error {
	if _, ok := t.Keychain[newK]; ok {
		return fmt.Errorf("key %v already exists in Keychain", newK)
	}

	e, ok := t.Keychain[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Keychain", oldK)
	}
	e.Name = &newK

	t.Keychain[newK] = e
	delete(t.Keychain, oldK)
	return nil
}

// GetOrCreateKeychain retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateKeychain(Name string) *Keychain {

	key := Name

	if v, ok := t.Keychain[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewKeychain(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateKeychain got unexpected error: %v", err))
	}
	return v
}

// GetKeychain retrieves the value with the specified key from
// the Keychain map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetKeychain(Name string) *Keychain {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Keychain[key]; ok {
		return lm
	}
	return nil
}

// DeleteKeychain deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteKeychain(Name string) {
	key := Name

	delete(t.Keychain, key)
}

// AppendKeychain appends the supplied Keychain struct to the
// list Keychain of Device. If the key value(s) specified in
// the supplied Keychain already exist in the list, an error is
// returned.
func (t *Device) AppendKeychain(v *Keychain) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Keychain == nil {
		t.Keychain = make(map[string]*Keychain)
	}

	if _, ok := t.Keychain[key]; ok {
		return fmt.Errorf("duplicate key for list Keychain %v", key)
	}

	t.Keychain[key] = v
	return nil
}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewNetworkInstance(Name string) (*NetworkInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateNetworkInstance(Name string) *NetworkInstance {

	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetNetworkInstance(Name string) *NetworkInstance {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied NetworkInstance struct to the
// list NetworkInstance of Device. If the key value(s) specified in
// the supplied NetworkInstance already exist in the list, an error is
// returned.
func (t *Device) AppendNetworkInstance(v *NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateAcl() *Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &Acl{}
	return t.Acl
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateLacp() *Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &Lacp{}
	return t.Lacp
}

// GetOrCreateLldp retrieves the value of the Lldp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateLldp() *Lldp {
	if t.Lldp != nil {
		return t.Lldp
	}
	t.Lldp = &Lldp{}
	return t.Lldp
}

// GetOrCreateMacsec retrieves the value of the Macsec field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateMacsec() *Macsec {
	if t.Macsec != nil {
		return t.Macsec
	}
	t.Macsec = &Macsec{}
	return t.Macsec
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateQos() *Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &Qos{}
	return t.Qos
}

// GetOrCreateRelayAgent retrieves the value of the RelayAgent field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateRelayAgent() *RelayAgent {
	if t.RelayAgent != nil {
		return t.RelayAgent
	}
	t.RelayAgent = &RelayAgent{}
	return t.RelayAgent
}

// GetOrCreateRoutingPolicy retrieves the value of the RoutingPolicy field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateRoutingPolicy() *RoutingPolicy {
	if t.RoutingPolicy != nil {
		return t.RoutingPolicy
	}
	t.RoutingPolicy = &RoutingPolicy{}
	return t.RoutingPolicy
}

// GetOrCreateSampling retrieves the value of the Sampling field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateSampling() *Sampling {
	if t.Sampling != nil {
		return t.Sampling
	}
	t.Sampling = &Sampling{}
	return t.Sampling
}

// GetOrCreateStp retrieves the value of the Stp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateStp() *Stp {
	if t.Stp != nil {
		return t.Stp
	}
	t.Stp = &Stp{}
	return t.Stp
}

// GetOrCreateSystem retrieves the value of the System field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateSystem() *System {
	if t.System != nil {
		return t.System
	}
	t.System = &System{}
	return t.System
}

// GetAcl returns the value of the Acl struct pointer
// from Device. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetAcl() *Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetLacp returns the value of the Lacp struct pointer
// from Device. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetLacp() *Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// GetLldp returns the value of the Lldp struct pointer
// from Device. If the receiver or the field Lldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetLldp() *Lldp {
	if t != nil && t.Lldp != nil {
		return t.Lldp
	}
	return nil
}

// GetMacsec returns the value of the Macsec struct pointer
// from Device. If the receiver or the field Macsec is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetMacsec() *Macsec {
	if t != nil && t.Macsec != nil {
		return t.Macsec
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from Device. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetQos() *Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetRelayAgent returns the value of the RelayAgent struct pointer
// from Device. If the receiver or the field RelayAgent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetRelayAgent() *RelayAgent {
	if t != nil && t.RelayAgent != nil {
		return t.RelayAgent
	}
	return nil
}

// GetRoutingPolicy returns the value of the RoutingPolicy struct pointer
// from Device. If the receiver or the field RoutingPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetRoutingPolicy() *RoutingPolicy {
	if t != nil && t.RoutingPolicy != nil {
		return t.RoutingPolicy
	}
	return nil
}

// GetSampling returns the value of the Sampling struct pointer
// from Device. If the receiver or the field Sampling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetSampling() *Sampling {
	if t != nil && t.Sampling != nil {
		return t.Sampling
	}
	return nil
}

// GetStp returns the value of the Stp struct pointer
// from Device. If the receiver or the field Stp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetStp() *Stp {
	if t != nil && t.Stp != nil {
		return t.Stp
	}
	return nil
}

// GetSystem returns the value of the System struct pointer
// from Device. If the receiver or the field System is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetSystem() *System {
	if t != nil && t.System != nil {
		return t.System
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Device.
func (*Device) ΛBelongingModule() string {
	return ""
}

// Interface represents the /openconfig-interfaces/interfaces/interface YANG schema element.
type Interface struct {
	AdminStatus      E_Interfaces_Interface_AdminStatus `path:"state/admin-status" module:"openconfig-interfaces/openconfig-interfaces"`
	Aggregation      *Interface_Aggregation             `path:"aggregation" module:"openconfig-if-aggregate"`
	Counters         *Interface_Counters                `path:"state/counters" module:"openconfig-interfaces/openconfig-interfaces"`
	Cpu              *bool                              `path:"state/cpu" module:"openconfig-interfaces/openconfig-interfaces"`
	Description      *string                            `path:"config/description" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/description" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Enabled          *bool                              `path:"config/enabled" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/enabled" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Ethernet         *Interface_Ethernet                `path:"ethernet" module:"openconfig-if-ethernet"`
	ForwardingViable *bool                              `path:"config/forwarding-viable" module:"openconfig-interfaces/openconfig-if-sdn-ext" shadow-path:"state/forwarding-viable" shadow-module:"openconfig-interfaces/openconfig-if-sdn-ext"`
	HardwarePort     *string                            `path:"state/hardware-port" module:"openconfig-interfaces/openconfig-platform-port"`
	HoldTime         *Interface_HoldTime                `path:"hold-time" module:"openconfig-interfaces"`
	Id               *uint32                            `path:"config/id" module:"openconfig-interfaces/openconfig-p4rt" shadow-path:"state/id" shadow-module:"openconfig-interfaces/openconfig-p4rt"`
	Ifindex          *uint32                            `path:"state/ifindex" module:"openconfig-interfaces/openconfig-interfaces"`
	LastChange       *uint64                            `path:"state/last-change" module:"openconfig-interfaces/openconfig-interfaces"`
	Logical          *bool                              `path:"state/logical" module:"openconfig-interfaces/openconfig-interfaces"`
	LoopbackMode     *bool                              `path:"config/loopback-mode" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/loopback-mode" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Management       *bool                              `path:"state/management" module:"openconfig-interfaces/openconfig-interfaces"`
	Mtu              *uint16                            `path:"config/mtu" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/mtu" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Name             *string                            `path:"config/name|name" module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces" shadow-path:"state/name|name" shadow-module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces"`
	OperStatus       E_Interfaces_Interface_OperStatus  `path:"state/oper-status" module:"openconfig-interfaces/openconfig-interfaces"`
	RoutedVlan       *Interface_RoutedVlan              `path:"routed-vlan" module:"openconfig-vlan"`
	Subinterface     map[uint32]*Interface_Subinterface `path:"subinterfaces/subinterface" module:"openconfig-interfaces/openconfig-interfaces"`
	Tpid             E_VlanTypes_TPID_TYPES             `path:"config/tpid" module:"openconfig-interfaces/openconfig-vlan" shadow-path:"state/tpid" shadow-module:"openconfig-interfaces/openconfig-vlan"`
	Tunnel           *Interface_Tunnel                  `path:"tunnel" module:"openconfig-if-tunnel"`
	Type             E_IETFInterfaces_InterfaceType     `path:"config/type" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/type" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface) IsYANGGoStruct() {}

// NewSubinterface creates a new entry in the Subinterface list of the
// Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Interface) NewSubinterface(Index uint32) (*Interface_Subinterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &Interface_Subinterface{
		Index: &Index,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface) RenameSubinterface(oldK, newK uint32) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Index = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface) GetOrCreateSubinterface(Index uint32) *Interface_Subinterface {

	key := Index

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface) GetSubinterface(Index uint32) *Interface_Subinterface {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubinterface deletes the value with the specified keys from
// the receiver Interface. If there is no such element, the function
// is a no-op.
func (t *Interface) DeleteSubinterface(Index uint32) {
	key := Index

	delete(t.Subinterface, key)
}

// AppendSubinterface appends the supplied Interface_Subinterface struct to the
// list Subinterface of Interface. If the key value(s) specified in
// the supplied Interface_Subinterface already exist in the list, an error is
// returned.
func (t *Interface) AppendSubinterface(v *Interface_Subinterface) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateAggregation retrieves the value of the Aggregation field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateAggregation() *Interface_Aggregation {
	if t.Aggregation != nil {
		return t.Aggregation
	}
	t.Aggregation = &Interface_Aggregation{}
	return t.Aggregation
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateCounters() *Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Counters{}
	return t.Counters
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateEthernet() *Interface_Ethernet {
	if t.Ethernet != nil {
		return t.Ethernet
	}
	t.Ethernet = &Interface_Ethernet{}
	return t.Ethernet
}

// GetOrCreateHoldTime retrieves the value of the HoldTime field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateHoldTime() *Interface_HoldTime {
	if t.HoldTime != nil {
		return t.HoldTime
	}
	t.HoldTime = &Interface_HoldTime{}
	return t.HoldTime
}

// GetOrCreateRoutedVlan retrieves the value of the RoutedVlan field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateRoutedVlan() *Interface_RoutedVlan {
	if t.RoutedVlan != nil {
		return t.RoutedVlan
	}
	t.RoutedVlan = &Interface_RoutedVlan{}
	return t.RoutedVlan
}

// GetOrCreateTunnel retrieves the value of the Tunnel field
// or returns the existing field if it already exists.
func (t *Interface) GetOrCreateTunnel() *Interface_Tunnel {
	if t.Tunnel != nil {
		return t.Tunnel
	}
	t.Tunnel = &Interface_Tunnel{}
	return t.Tunnel
}

// GetAggregation returns the value of the Aggregation struct pointer
// from Interface. If the receiver or the field Aggregation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetAggregation() *Interface_Aggregation {
	if t != nil && t.Aggregation != nil {
		return t.Aggregation
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetCounters() *Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEthernet returns the value of the Ethernet struct pointer
// from Interface. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetEthernet() *Interface_Ethernet {
	if t != nil && t.Ethernet != nil {
		return t.Ethernet
	}
	return nil
}

// GetHoldTime returns the value of the HoldTime struct pointer
// from Interface. If the receiver or the field HoldTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetHoldTime() *Interface_HoldTime {
	if t != nil && t.HoldTime != nil {
		return t.HoldTime
	}
	return nil
}

// GetRoutedVlan returns the value of the RoutedVlan struct pointer
// from Interface. If the receiver or the field RoutedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetRoutedVlan() *Interface_RoutedVlan {
	if t != nil && t.RoutedVlan != nil {
		return t.RoutedVlan
	}
	return nil
}

// GetTunnel returns the value of the Tunnel struct pointer
// from Interface. If the receiver or the field Tunnel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface) GetTunnel() *Interface_Tunnel {
	if t != nil && t.Tunnel != nil {
		return t.Tunnel
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *Interface) GetAdminStatus() E_Interfaces_Interface_AdminStatus {
	if t == nil || t.AdminStatus == 0 {
		return 0
	}
	return t.AdminStatus
}

// GetCpu retrieves the value of the leaf Cpu from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cpu is set, it can
// safely use t.GetCpu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cpu == nil' before retrieving the leaf's value.
func (t *Interface) GetCpu() bool {
	if t == nil || t.Cpu == nil {
		return false
	}
	return *t.Cpu
}

// GetDescription retrieves the value of the leaf Description from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *Interface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetForwardingViable retrieves the value of the leaf ForwardingViable from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingViable is set, it can
// safely use t.GetForwardingViable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingViable == nil' before retrieving the leaf's value.
func (t *Interface) GetForwardingViable() bool {
	if t == nil || t.ForwardingViable == nil {
		return true
	}
	return *t.ForwardingViable
}

// GetHardwarePort retrieves the value of the leaf HardwarePort from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HardwarePort is set, it can
// safely use t.GetHardwarePort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HardwarePort == nil' before retrieving the leaf's value.
func (t *Interface) GetHardwarePort() string {
	if t == nil || t.HardwarePort == nil {
		return ""
	}
	return *t.HardwarePort
}

// GetId retrieves the value of the leaf Id from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *Interface) GetId() uint32 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetIfindex retrieves the value of the leaf Ifindex from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ifindex is set, it can
// safely use t.GetIfindex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ifindex == nil' before retrieving the leaf's value.
func (t *Interface) GetIfindex() uint32 {
	if t == nil || t.Ifindex == nil {
		return 0
	}
	return *t.Ifindex
}

// GetLastChange retrieves the value of the leaf LastChange from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Interface) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetLogical retrieves the value of the leaf Logical from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Logical is set, it can
// safely use t.GetLogical() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Logical == nil' before retrieving the leaf's value.
func (t *Interface) GetLogical() bool {
	if t == nil || t.Logical == nil {
		return false
	}
	return *t.Logical
}

// GetLoopbackMode retrieves the value of the leaf LoopbackMode from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LoopbackMode is set, it can
// safely use t.GetLoopbackMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LoopbackMode == nil' before retrieving the leaf's value.
func (t *Interface) GetLoopbackMode() bool {
	if t == nil || t.LoopbackMode == nil {
		return false
	}
	return *t.LoopbackMode
}

// GetManagement retrieves the value of the leaf Management from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Management is set, it can
// safely use t.GetManagement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Management == nil' before retrieving the leaf's value.
func (t *Interface) GetManagement() bool {
	if t == nil || t.Management == nil {
		return false
	}
	return *t.Management
}

// GetMtu retrieves the value of the leaf Mtu from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// GetName retrieves the value of the leaf Name from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *Interface) GetOperStatus() E_Interfaces_Interface_OperStatus {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// GetTpid retrieves the value of the leaf Tpid from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return VlanTypes_TPID_TYPES_TPID_0X8100
	}
	return t.Tpid
}

// GetType retrieves the value of the leaf Type from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface) GetType() E_IETFInterfaces_InterfaceType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the Interface struct, which is a YANG list entry.
func (t *Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface.
func (*Interface) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Aggregation represents the /openconfig-interfaces/interfaces/interface/aggregation YANG schema element.
type Interface_Aggregation struct {
	LagSpeed     *uint32                             `path:"state/lag-speed" module:"openconfig-if-aggregate/openconfig-if-aggregate"`
	LagType      E_IfAggregate_AggregationType       `path:"config/lag-type" module:"openconfig-if-aggregate/openconfig-if-aggregate" shadow-path:"state/lag-type" shadow-module:"openconfig-if-aggregate/openconfig-if-aggregate"`
	Member       []string                            `path:"state/member" module:"openconfig-if-aggregate/openconfig-if-aggregate"`
	MinLinks     *uint16                             `path:"config/min-links" module:"openconfig-if-aggregate/openconfig-if-aggregate" shadow-path:"state/min-links" shadow-module:"openconfig-if-aggregate/openconfig-if-aggregate"`
	SwitchedVlan *Interface_Aggregation_SwitchedVlan `path:"switched-vlan" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Aggregation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Aggregation) IsYANGGoStruct() {}

// GetOrCreateSwitchedVlan retrieves the value of the SwitchedVlan field
// or returns the existing field if it already exists.
func (t *Interface_Aggregation) GetOrCreateSwitchedVlan() *Interface_Aggregation_SwitchedVlan {
	if t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	t.SwitchedVlan = &Interface_Aggregation_SwitchedVlan{}
	return t.SwitchedVlan
}

// GetSwitchedVlan returns the value of the SwitchedVlan struct pointer
// from Interface_Aggregation. If the receiver or the field SwitchedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Aggregation) GetSwitchedVlan() *Interface_Aggregation_SwitchedVlan {
	if t != nil && t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	return nil
}

// GetLagSpeed retrieves the value of the leaf LagSpeed from the Interface_Aggregation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LagSpeed is set, it can
// safely use t.GetLagSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LagSpeed == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation) GetLagSpeed() uint32 {
	if t == nil || t.LagSpeed == nil {
		return 0
	}
	return *t.LagSpeed
}

// GetLagType retrieves the value of the leaf LagType from the Interface_Aggregation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LagType is set, it can
// safely use t.GetLagType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LagType == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation) GetLagType() E_IfAggregate_AggregationType {
	if t == nil || t.LagType == 0 {
		return 0
	}
	return t.LagType
}

// GetMember retrieves the value of the leaf Member from the Interface_Aggregation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Member is set, it can
// safely use t.GetMember() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Member == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation) GetMember() []string {
	if t == nil || t.Member == nil {
		return nil
	}
	return t.Member
}

// GetMinLinks retrieves the value of the leaf MinLinks from the Interface_Aggregation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinLinks is set, it can
// safely use t.GetMinLinks() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinLinks == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation) GetMinLinks() uint16 {
	if t == nil || t.MinLinks == nil {
		return 0
	}
	return *t.MinLinks
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Aggregation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Aggregation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Aggregation.
func (*Interface_Aggregation) ΛBelongingModule() string {
	return "openconfig-if-aggregate"
}

// Interface_Aggregation_SwitchedVlan represents the /openconfig-interfaces/interfaces/interface/aggregation/switched-vlan YANG schema element.
type Interface_Aggregation_SwitchedVlan struct {
	AccessVlan    *uint16                                               `path:"config/access-vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/access-vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InterfaceMode E_VlanTypes_VlanModeType                              `path:"config/interface-mode" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/interface-mode" shadow-module:"openconfig-vlan/openconfig-vlan"`
	NativeVlan    *uint16                                               `path:"config/native-vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/native-vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
	TrunkVlans    []Interface_Aggregation_SwitchedVlan_TrunkVlans_Union `path:"config/trunk-vlans" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/trunk-vlans" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Aggregation_SwitchedVlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Aggregation_SwitchedVlan) IsYANGGoStruct() {}

// GetAccessVlan retrieves the value of the leaf AccessVlan from the Interface_Aggregation_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AccessVlan is set, it can
// safely use t.GetAccessVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AccessVlan == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation_SwitchedVlan) GetAccessVlan() uint16 {
	if t == nil || t.AccessVlan == nil {
		return 0
	}
	return *t.AccessVlan
}

// GetInterfaceMode retrieves the value of the leaf InterfaceMode from the Interface_Aggregation_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceMode is set, it can
// safely use t.GetInterfaceMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceMode == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation_SwitchedVlan) GetInterfaceMode() E_VlanTypes_VlanModeType {
	if t == nil || t.InterfaceMode == 0 {
		return 0
	}
	return t.InterfaceMode
}

// GetNativeVlan retrieves the value of the leaf NativeVlan from the Interface_Aggregation_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NativeVlan is set, it can
// safely use t.GetNativeVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NativeVlan == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation_SwitchedVlan) GetNativeVlan() uint16 {
	if t == nil || t.NativeVlan == nil {
		return 0
	}
	return *t.NativeVlan
}

// GetTrunkVlans retrieves the value of the leaf TrunkVlans from the Interface_Aggregation_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrunkVlans is set, it can
// safely use t.GetTrunkVlans() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrunkVlans == nil' before retrieving the leaf's value.
func (t *Interface_Aggregation_SwitchedVlan) GetTrunkVlans() []Interface_Aggregation_SwitchedVlan_TrunkVlans_Union {
	if t == nil || t.TrunkVlans == nil {
		return nil
	}
	return t.TrunkVlans
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation_SwitchedVlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Aggregation_SwitchedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Aggregation_SwitchedVlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Aggregation_SwitchedVlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Aggregation_SwitchedVlan.
func (*Interface_Aggregation_SwitchedVlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Counters represents the /openconfig-interfaces/interfaces/interface/state/counters YANG schema element.
type Interface_Counters struct {
	CarrierTransitions *uint64 `path:"carrier-transitions" module:"openconfig-interfaces"`
	InBroadcastPkts    *uint64 `path:"in-broadcast-pkts" module:"openconfig-interfaces"`
	InDiscards         *uint64 `path:"in-discards" module:"openconfig-interfaces"`
	InErrors           *uint64 `path:"in-errors" module:"openconfig-interfaces"`
	InFcsErrors        *uint64 `path:"in-fcs-errors" module:"openconfig-interfaces"`
	InMulticastPkts    *uint64 `path:"in-multicast-pkts" module:"openconfig-interfaces"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-interfaces"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-interfaces"`
	InUnicastPkts      *uint64 `path:"in-unicast-pkts" module:"openconfig-interfaces"`
	InUnknownProtos    *uint64 `path:"in-unknown-protos" module:"openconfig-interfaces"`
	LastClear          *uint64 `path:"last-clear" module:"openconfig-interfaces"`
	OutBroadcastPkts   *uint64 `path:"out-broadcast-pkts" module:"openconfig-interfaces"`
	OutDiscards        *uint64 `path:"out-discards" module:"openconfig-interfaces"`
	OutErrors          *uint64 `path:"out-errors" module:"openconfig-interfaces"`
	OutMulticastPkts   *uint64 `path:"out-multicast-pkts" module:"openconfig-interfaces"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-interfaces"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-interfaces"`
	OutUnicastPkts     *uint64 `path:"out-unicast-pkts" module:"openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Counters) IsYANGGoStruct() {}

// GetCarrierTransitions retrieves the value of the leaf CarrierTransitions from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CarrierTransitions is set, it can
// safely use t.GetCarrierTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CarrierTransitions == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetCarrierTransitions() uint64 {
	if t == nil || t.CarrierTransitions == nil {
		return 0
	}
	return *t.CarrierTransitions
}

// GetInBroadcastPkts retrieves the value of the leaf InBroadcastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBroadcastPkts is set, it can
// safely use t.GetInBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInBroadcastPkts() uint64 {
	if t == nil || t.InBroadcastPkts == nil {
		return 0
	}
	return *t.InBroadcastPkts
}

// GetInDiscards retrieves the value of the leaf InDiscards from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscards is set, it can
// safely use t.GetInDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInDiscards() uint64 {
	if t == nil || t.InDiscards == nil {
		return 0
	}
	return *t.InDiscards
}

// GetInErrors retrieves the value of the leaf InErrors from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrors is set, it can
// safely use t.GetInErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrors == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInErrors() uint64 {
	if t == nil || t.InErrors == nil {
		return 0
	}
	return *t.InErrors
}

// GetInFcsErrors retrieves the value of the leaf InFcsErrors from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFcsErrors is set, it can
// safely use t.GetInFcsErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFcsErrors == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInFcsErrors() uint64 {
	if t == nil || t.InFcsErrors == nil {
		return 0
	}
	return *t.InFcsErrors
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetInUnicastPkts retrieves the value of the leaf InUnicastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnicastPkts is set, it can
// safely use t.GetInUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInUnicastPkts() uint64 {
	if t == nil || t.InUnicastPkts == nil {
		return 0
	}
	return *t.InUnicastPkts
}

// GetInUnknownProtos retrieves the value of the leaf InUnknownProtos from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnknownProtos is set, it can
// safely use t.GetInUnknownProtos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnknownProtos == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetInUnknownProtos() uint64 {
	if t == nil || t.InUnknownProtos == nil {
		return 0
	}
	return *t.InUnknownProtos
}

// GetLastClear retrieves the value of the leaf LastClear from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetLastClear() uint64 {
	if t == nil || t.LastClear == nil {
		return 0
	}
	return *t.LastClear
}

// GetOutBroadcastPkts retrieves the value of the leaf OutBroadcastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutBroadcastPkts is set, it can
// safely use t.GetOutBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutBroadcastPkts() uint64 {
	if t == nil || t.OutBroadcastPkts == nil {
		return 0
	}
	return *t.OutBroadcastPkts
}

// GetOutDiscards retrieves the value of the leaf OutDiscards from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscards is set, it can
// safely use t.GetOutDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutDiscards() uint64 {
	if t == nil || t.OutDiscards == nil {
		return 0
	}
	return *t.OutDiscards
}

// GetOutErrors retrieves the value of the leaf OutErrors from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrors is set, it can
// safely use t.GetOutErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrors == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutErrors() uint64 {
	if t == nil || t.OutErrors == nil {
		return 0
	}
	return *t.OutErrors
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// GetOutUnicastPkts retrieves the value of the leaf OutUnicastPkts from the Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutUnicastPkts is set, it can
// safely use t.GetOutUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Counters) GetOutUnicastPkts() uint64 {
	if t == nil || t.OutUnicastPkts == nil {
		return 0
	}
	return *t.OutUnicastPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Counters.
func (*Interface_Counters) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Ethernet represents the /openconfig-interfaces/interfaces/interface/ethernet YANG schema element.
type Interface_Ethernet struct {
	AggregateId            *string                                    `path:"config/aggregate-id" module:"openconfig-if-ethernet/openconfig-if-aggregate" shadow-path:"state/aggregate-id" shadow-module:"openconfig-if-ethernet/openconfig-if-aggregate"`
	AutoNegotiate          *bool                                      `path:"config/auto-negotiate" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/auto-negotiate" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	Counters               *Interface_Ethernet_Counters               `path:"state/counters" module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	DuplexMode             E_IfEthernet_Ethernet_DuplexMode           `path:"config/duplex-mode" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/duplex-mode" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	EnableFlowControl      *bool                                      `path:"config/enable-flow-control" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/enable-flow-control" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	FecMode                E_IfEthernet_INTERFACE_FEC                 `path:"config/fec-mode" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/fec-mode" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	HwMacAddress           *string                                    `path:"state/hw-mac-address" module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	MacAddress             *string                                    `path:"config/mac-address" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/mac-address" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	NegotiatedDuplexMode   E_IfEthernet_Ethernet_NegotiatedDuplexMode `path:"state/negotiated-duplex-mode" module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	NegotiatedPortSpeed    E_IfEthernet_ETHERNET_SPEED                `path:"state/negotiated-port-speed" module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	PortSpeed              E_IfEthernet_ETHERNET_SPEED                `path:"config/port-speed" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/port-speed" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	StandaloneLinkTraining *bool                                      `path:"config/standalone-link-training" module:"openconfig-if-ethernet/openconfig-if-ethernet" shadow-path:"state/standalone-link-training" shadow-module:"openconfig-if-ethernet/openconfig-if-ethernet"`
	SwitchedVlan           *Interface_Ethernet_SwitchedVlan           `path:"switched-vlan" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Ethernet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ethernet) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Ethernet) GetOrCreateCounters() *Interface_Ethernet_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Ethernet_Counters{}
	return t.Counters
}

// GetOrCreateSwitchedVlan retrieves the value of the SwitchedVlan field
// or returns the existing field if it already exists.
func (t *Interface_Ethernet) GetOrCreateSwitchedVlan() *Interface_Ethernet_SwitchedVlan {
	if t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	t.SwitchedVlan = &Interface_Ethernet_SwitchedVlan{}
	return t.SwitchedVlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Ethernet. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Ethernet) GetCounters() *Interface_Ethernet_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetSwitchedVlan returns the value of the SwitchedVlan struct pointer
// from Interface_Ethernet. If the receiver or the field SwitchedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Ethernet) GetSwitchedVlan() *Interface_Ethernet_SwitchedVlan {
	if t != nil && t.SwitchedVlan != nil {
		return t.SwitchedVlan
	}
	return nil
}

// GetAggregateId retrieves the value of the leaf AggregateId from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AggregateId is set, it can
// safely use t.GetAggregateId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AggregateId == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetAggregateId() string {
	if t == nil || t.AggregateId == nil {
		return ""
	}
	return *t.AggregateId
}

// GetAutoNegotiate retrieves the value of the leaf AutoNegotiate from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoNegotiate is set, it can
// safely use t.GetAutoNegotiate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoNegotiate == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetAutoNegotiate() bool {
	if t == nil || t.AutoNegotiate == nil {
		return true
	}
	return *t.AutoNegotiate
}

// GetDuplexMode retrieves the value of the leaf DuplexMode from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplexMode is set, it can
// safely use t.GetDuplexMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplexMode == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetDuplexMode() E_IfEthernet_Ethernet_DuplexMode {
	if t == nil || t.DuplexMode == 0 {
		return 0
	}
	return t.DuplexMode
}

// GetEnableFlowControl retrieves the value of the leaf EnableFlowControl from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableFlowControl is set, it can
// safely use t.GetEnableFlowControl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableFlowControl == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetEnableFlowControl() bool {
	if t == nil || t.EnableFlowControl == nil {
		return false
	}
	return *t.EnableFlowControl
}

// GetFecMode retrieves the value of the leaf FecMode from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FecMode is set, it can
// safely use t.GetFecMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FecMode == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetFecMode() E_IfEthernet_INTERFACE_FEC {
	if t == nil || t.FecMode == 0 {
		return 0
	}
	return t.FecMode
}

// GetHwMacAddress retrieves the value of the leaf HwMacAddress from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HwMacAddress is set, it can
// safely use t.GetHwMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HwMacAddress == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetHwMacAddress() string {
	if t == nil || t.HwMacAddress == nil {
		return ""
	}
	return *t.HwMacAddress
}

// GetMacAddress retrieves the value of the leaf MacAddress from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetNegotiatedDuplexMode retrieves the value of the leaf NegotiatedDuplexMode from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NegotiatedDuplexMode is set, it can
// safely use t.GetNegotiatedDuplexMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NegotiatedDuplexMode == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetNegotiatedDuplexMode() E_IfEthernet_Ethernet_NegotiatedDuplexMode {
	if t == nil || t.NegotiatedDuplexMode == 0 {
		return 0
	}
	return t.NegotiatedDuplexMode
}

// GetNegotiatedPortSpeed retrieves the value of the leaf NegotiatedPortSpeed from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NegotiatedPortSpeed is set, it can
// safely use t.GetNegotiatedPortSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NegotiatedPortSpeed == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetNegotiatedPortSpeed() E_IfEthernet_ETHERNET_SPEED {
	if t == nil || t.NegotiatedPortSpeed == 0 {
		return 0
	}
	return t.NegotiatedPortSpeed
}

// GetPortSpeed retrieves the value of the leaf PortSpeed from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortSpeed is set, it can
// safely use t.GetPortSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortSpeed == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetPortSpeed() E_IfEthernet_ETHERNET_SPEED {
	if t == nil || t.PortSpeed == 0 {
		return 0
	}
	return t.PortSpeed
}

// GetStandaloneLinkTraining retrieves the value of the leaf StandaloneLinkTraining from the Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StandaloneLinkTraining is set, it can
// safely use t.GetStandaloneLinkTraining() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StandaloneLinkTraining == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet) GetStandaloneLinkTraining() bool {
	if t == nil || t.StandaloneLinkTraining == nil {
		return false
	}
	return *t.StandaloneLinkTraining
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ethernet.
func (*Interface_Ethernet) ΛBelongingModule() string {
	return "openconfig-if-ethernet"
}

// Interface_Ethernet_Counters represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters YANG schema element.
type Interface_Ethernet_Counters struct {
	In_8021QFrames      *uint64 `path:"in-8021q-frames" module:"openconfig-if-ethernet"`
	InBlockErrors       *uint64 `path:"in-block-errors" module:"openconfig-if-ethernet"`
	InCarrierErrors     *uint64 `path:"in-carrier-errors" module:"openconfig-if-ethernet"`
	InCrcErrors         *uint64 `path:"in-crc-errors" module:"openconfig-if-ethernet"`
	InFragmentFrames    *uint64 `path:"in-fragment-frames" module:"openconfig-if-ethernet"`
	InInterruptedTx     *uint64 `path:"in-interrupted-tx" module:"openconfig-if-ethernet"`
	InJabberFrames      *uint64 `path:"in-jabber-frames" module:"openconfig-if-ethernet"`
	InLateCollision     *uint64 `path:"in-late-collision" module:"openconfig-if-ethernet"`
	InMacControlFrames  *uint64 `path:"in-mac-control-frames" module:"openconfig-if-ethernet"`
	InMacErrorsRx       *uint64 `path:"in-mac-errors-rx" module:"openconfig-if-ethernet"`
	InMacPauseFrames    *uint64 `path:"in-mac-pause-frames" module:"openconfig-if-ethernet"`
	InMaxsizeExceeded   *uint64 `path:"in-maxsize-exceeded" module:"openconfig-if-ethernet"`
	InOversizeFrames    *uint64 `path:"in-oversize-frames" module:"openconfig-if-ethernet"`
	InSingleCollision   *uint64 `path:"in-single-collision" module:"openconfig-if-ethernet"`
	InSymbolError       *uint64 `path:"in-symbol-error" module:"openconfig-if-ethernet"`
	InUndersizeFrames   *uint64 `path:"in-undersize-frames" module:"openconfig-if-ethernet"`
	Out_8021QFrames     *uint64 `path:"out-8021q-frames" module:"openconfig-if-ethernet"`
	OutMacControlFrames *uint64 `path:"out-mac-control-frames" module:"openconfig-if-ethernet"`
	OutMacErrorsTx      *uint64 `path:"out-mac-errors-tx" module:"openconfig-if-ethernet"`
	OutMacPauseFrames   *uint64 `path:"out-mac-pause-frames" module:"openconfig-if-ethernet"`
}

// IsYANGGoStruct ensures that Interface_Ethernet_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ethernet_Counters) IsYANGGoStruct() {}

// GetIn_8021QFrames retrieves the value of the leaf In_8021QFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if In_8021QFrames is set, it can
// safely use t.GetIn_8021QFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.In_8021QFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetIn_8021QFrames() uint64 {
	if t == nil || t.In_8021QFrames == nil {
		return 0
	}
	return *t.In_8021QFrames
}

// GetInBlockErrors retrieves the value of the leaf InBlockErrors from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBlockErrors is set, it can
// safely use t.GetInBlockErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBlockErrors == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInBlockErrors() uint64 {
	if t == nil || t.InBlockErrors == nil {
		return 0
	}
	return *t.InBlockErrors
}

// GetInCarrierErrors retrieves the value of the leaf InCarrierErrors from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InCarrierErrors is set, it can
// safely use t.GetInCarrierErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InCarrierErrors == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInCarrierErrors() uint64 {
	if t == nil || t.InCarrierErrors == nil {
		return 0
	}
	return *t.InCarrierErrors
}

// GetInCrcErrors retrieves the value of the leaf InCrcErrors from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InCrcErrors is set, it can
// safely use t.GetInCrcErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InCrcErrors == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInCrcErrors() uint64 {
	if t == nil || t.InCrcErrors == nil {
		return 0
	}
	return *t.InCrcErrors
}

// GetInFragmentFrames retrieves the value of the leaf InFragmentFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFragmentFrames is set, it can
// safely use t.GetInFragmentFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFragmentFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInFragmentFrames() uint64 {
	if t == nil || t.InFragmentFrames == nil {
		return 0
	}
	return *t.InFragmentFrames
}

// GetInInterruptedTx retrieves the value of the leaf InInterruptedTx from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InInterruptedTx is set, it can
// safely use t.GetInInterruptedTx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InInterruptedTx == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInInterruptedTx() uint64 {
	if t == nil || t.InInterruptedTx == nil {
		return 0
	}
	return *t.InInterruptedTx
}

// GetInJabberFrames retrieves the value of the leaf InJabberFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InJabberFrames is set, it can
// safely use t.GetInJabberFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InJabberFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInJabberFrames() uint64 {
	if t == nil || t.InJabberFrames == nil {
		return 0
	}
	return *t.InJabberFrames
}

// GetInLateCollision retrieves the value of the leaf InLateCollision from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InLateCollision is set, it can
// safely use t.GetInLateCollision() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InLateCollision == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInLateCollision() uint64 {
	if t == nil || t.InLateCollision == nil {
		return 0
	}
	return *t.InLateCollision
}

// GetInMacControlFrames retrieves the value of the leaf InMacControlFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMacControlFrames is set, it can
// safely use t.GetInMacControlFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMacControlFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInMacControlFrames() uint64 {
	if t == nil || t.InMacControlFrames == nil {
		return 0
	}
	return *t.InMacControlFrames
}

// GetInMacErrorsRx retrieves the value of the leaf InMacErrorsRx from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMacErrorsRx is set, it can
// safely use t.GetInMacErrorsRx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMacErrorsRx == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInMacErrorsRx() uint64 {
	if t == nil || t.InMacErrorsRx == nil {
		return 0
	}
	return *t.InMacErrorsRx
}

// GetInMacPauseFrames retrieves the value of the leaf InMacPauseFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMacPauseFrames is set, it can
// safely use t.GetInMacPauseFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMacPauseFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInMacPauseFrames() uint64 {
	if t == nil || t.InMacPauseFrames == nil {
		return 0
	}
	return *t.InMacPauseFrames
}

// GetInMaxsizeExceeded retrieves the value of the leaf InMaxsizeExceeded from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMaxsizeExceeded is set, it can
// safely use t.GetInMaxsizeExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMaxsizeExceeded == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInMaxsizeExceeded() uint64 {
	if t == nil || t.InMaxsizeExceeded == nil {
		return 0
	}
	return *t.InMaxsizeExceeded
}

// GetInOversizeFrames retrieves the value of the leaf InOversizeFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOversizeFrames is set, it can
// safely use t.GetInOversizeFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOversizeFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInOversizeFrames() uint64 {
	if t == nil || t.InOversizeFrames == nil {
		return 0
	}
	return *t.InOversizeFrames
}

// GetInSingleCollision retrieves the value of the leaf InSingleCollision from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InSingleCollision is set, it can
// safely use t.GetInSingleCollision() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InSingleCollision == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInSingleCollision() uint64 {
	if t == nil || t.InSingleCollision == nil {
		return 0
	}
	return *t.InSingleCollision
}

// GetInSymbolError retrieves the value of the leaf InSymbolError from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InSymbolError is set, it can
// safely use t.GetInSymbolError() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InSymbolError == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInSymbolError() uint64 {
	if t == nil || t.InSymbolError == nil {
		return 0
	}
	return *t.InSymbolError
}

// GetInUndersizeFrames retrieves the value of the leaf InUndersizeFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUndersizeFrames is set, it can
// safely use t.GetInUndersizeFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUndersizeFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetInUndersizeFrames() uint64 {
	if t == nil || t.InUndersizeFrames == nil {
		return 0
	}
	return *t.InUndersizeFrames
}

// GetOut_8021QFrames retrieves the value of the leaf Out_8021QFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Out_8021QFrames is set, it can
// safely use t.GetOut_8021QFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Out_8021QFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetOut_8021QFrames() uint64 {
	if t == nil || t.Out_8021QFrames == nil {
		return 0
	}
	return *t.Out_8021QFrames
}

// GetOutMacControlFrames retrieves the value of the leaf OutMacControlFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMacControlFrames is set, it can
// safely use t.GetOutMacControlFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMacControlFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetOutMacControlFrames() uint64 {
	if t == nil || t.OutMacControlFrames == nil {
		return 0
	}
	return *t.OutMacControlFrames
}

// GetOutMacErrorsTx retrieves the value of the leaf OutMacErrorsTx from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMacErrorsTx is set, it can
// safely use t.GetOutMacErrorsTx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMacErrorsTx == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetOutMacErrorsTx() uint64 {
	if t == nil || t.OutMacErrorsTx == nil {
		return 0
	}
	return *t.OutMacErrorsTx
}

// GetOutMacPauseFrames retrieves the value of the leaf OutMacPauseFrames from the Interface_Ethernet_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMacPauseFrames is set, it can
// safely use t.GetOutMacPauseFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMacPauseFrames == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_Counters) GetOutMacPauseFrames() uint64 {
	if t == nil || t.OutMacPauseFrames == nil {
		return 0
	}
	return *t.OutMacPauseFrames
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ethernet_Counters.
func (*Interface_Ethernet_Counters) ΛBelongingModule() string {
	return "openconfig-if-ethernet"
}

// Interface_Ethernet_SwitchedVlan represents the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan YANG schema element.
type Interface_Ethernet_SwitchedVlan struct {
	AccessVlan    *uint16                                            `path:"config/access-vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/access-vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InterfaceMode E_VlanTypes_VlanModeType                           `path:"config/interface-mode" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/interface-mode" shadow-module:"openconfig-vlan/openconfig-vlan"`
	NativeVlan    *uint16                                            `path:"config/native-vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/native-vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
	TrunkVlans    []Interface_Ethernet_SwitchedVlan_TrunkVlans_Union `path:"config/trunk-vlans" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/trunk-vlans" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Ethernet_SwitchedVlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ethernet_SwitchedVlan) IsYANGGoStruct() {}

// GetAccessVlan retrieves the value of the leaf AccessVlan from the Interface_Ethernet_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AccessVlan is set, it can
// safely use t.GetAccessVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AccessVlan == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_SwitchedVlan) GetAccessVlan() uint16 {
	if t == nil || t.AccessVlan == nil {
		return 0
	}
	return *t.AccessVlan
}

// GetInterfaceMode retrieves the value of the leaf InterfaceMode from the Interface_Ethernet_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceMode is set, it can
// safely use t.GetInterfaceMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceMode == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_SwitchedVlan) GetInterfaceMode() E_VlanTypes_VlanModeType {
	if t == nil || t.InterfaceMode == 0 {
		return 0
	}
	return t.InterfaceMode
}

// GetNativeVlan retrieves the value of the leaf NativeVlan from the Interface_Ethernet_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NativeVlan is set, it can
// safely use t.GetNativeVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NativeVlan == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_SwitchedVlan) GetNativeVlan() uint16 {
	if t == nil || t.NativeVlan == nil {
		return 0
	}
	return *t.NativeVlan
}

// GetTrunkVlans retrieves the value of the leaf TrunkVlans from the Interface_Ethernet_SwitchedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrunkVlans is set, it can
// safely use t.GetTrunkVlans() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrunkVlans == nil' before retrieving the leaf's value.
func (t *Interface_Ethernet_SwitchedVlan) GetTrunkVlans() []Interface_Ethernet_SwitchedVlan_TrunkVlans_Union {
	if t == nil || t.TrunkVlans == nil {
		return nil
	}
	return t.TrunkVlans
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_SwitchedVlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet_SwitchedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ethernet_SwitchedVlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet_SwitchedVlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ethernet_SwitchedVlan.
func (*Interface_Ethernet_SwitchedVlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_HoldTime represents the /openconfig-interfaces/interfaces/interface/hold-time YANG schema element.
type Interface_HoldTime struct {
	Down *uint32 `path:"config/down" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/down" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Up   *uint32 `path:"config/up" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/up" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface_HoldTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_HoldTime) IsYANGGoStruct() {}

// GetDown retrieves the value of the leaf Down from the Interface_HoldTime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Down is set, it can
// safely use t.GetDown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Down == nil' before retrieving the leaf's value.
func (t *Interface_HoldTime) GetDown() uint32 {
	if t == nil || t.Down == nil {
		return 0
	}
	return *t.Down
}

// GetUp retrieves the value of the leaf Up from the Interface_HoldTime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Up is set, it can
// safely use t.GetUp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Up == nil' before retrieving the leaf's value.
func (t *Interface_HoldTime) GetUp() uint32 {
	if t == nil || t.Up == nil {
		return 0
	}
	return *t.Up
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_HoldTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_HoldTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_HoldTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_HoldTime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_HoldTime.
func (*Interface_HoldTime) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_RoutedVlan represents the /openconfig-interfaces/interfaces/interface/routed-vlan YANG schema element.
type Interface_RoutedVlan struct {
	Ipv4 *Interface_RoutedVlan_Ipv4      `path:"ipv4" module:"openconfig-if-ip"`
	Ipv6 *Interface_RoutedVlan_Ipv6      `path:"ipv6" module:"openconfig-if-ip"`
	Vlan Interface_RoutedVlan_Vlan_Union `path:"config/vlan" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan) IsYANGGoStruct() {}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan) GetOrCreateIpv4() *Interface_RoutedVlan_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_RoutedVlan_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan) GetOrCreateIpv6() *Interface_RoutedVlan_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_RoutedVlan_Ipv6{}
	return t.Ipv6
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan) GetIpv4() *Interface_RoutedVlan_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan) GetIpv6() *Interface_RoutedVlan_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetVlan retrieves the value of the leaf Vlan from the Interface_RoutedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan) GetVlan() Interface_RoutedVlan_Vlan_Union {
	if t == nil || t.Vlan == nil {
		return nil
	}
	return t.Vlan
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan.
func (*Interface_RoutedVlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_RoutedVlan_Ipv4 represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4 YANG schema element.
type Interface_RoutedVlan_Ipv4 struct {
	Address    map[string]*Interface_RoutedVlan_Ipv4_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	Counters   *Interface_RoutedVlan_Ipv4_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	DhcpClient *bool                                          `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Enabled    *bool                                          `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mtu        *uint16                                        `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mtu" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Neighbor   map[string]*Interface_RoutedVlan_Ipv4_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	ProxyArp   *Interface_RoutedVlan_Ipv4_ProxyArp            `path:"proxy-arp" module:"openconfig-if-ip"`
	Unnumbered *Interface_RoutedVlan_Ipv4_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv4_Address struct to the
// list Address of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendAddress(v *Interface_RoutedVlan_Ipv4_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv4_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendNeighbor(v *Interface_RoutedVlan_Ipv4_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_RoutedVlan_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_RoutedVlan_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_RoutedVlan_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4.
func (*Interface_RoutedVlan_Ipv4) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address YANG schema element.
type Interface_RoutedVlan_Ipv4_Address struct {
	Ip           *string                                                `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	Origin       E_IfIp_IpAddressOrigin                                 `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	PrefixLength *uint8                                                 `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VrrpGroup    map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address.
func (*Interface_RoutedVlan_Ipv4_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct {
	AcceptMode            *bool                                                          `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                        `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                         `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                          `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                        `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                         `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                       `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                         `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address_VrrpGroup.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Counters represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/counters YANG schema element.
type Interface_RoutedVlan_Ipv4_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Counters.
func (*Interface_RoutedVlan_Ipv4_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Neighbor represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor YANG schema element.
type Interface_RoutedVlan_Ipv4_Neighbor struct {
	Ip               *string               `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	LinkLayerAddress *string               `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Neighbor.
func (*Interface_RoutedVlan_Ipv4_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_ProxyArp represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/proxy-arp YANG schema element.
type Interface_RoutedVlan_Ipv4_ProxyArp struct {
	Mode E_IfIp_ProxyArp_Mode `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_ProxyArp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_ProxyArp) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the Interface_RoutedVlan_Ipv4_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) GetMode() E_IfIp_ProxyArp_Mode {
	if t == nil || t.Mode == 0 {
		return IfIp_ProxyArp_Mode_DISABLE
	}
	return t.Mode
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_ProxyArp.
func (*Interface_RoutedVlan_Ipv4_ProxyArp) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Unnumbered represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/unnumbered YANG schema element.
type Interface_RoutedVlan_Ipv4_Unnumbered struct {
	Enabled      *bool                                              `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Unnumbered.
func (*Interface_RoutedVlan_Ipv4_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/unnumbered/interface-ref YANG schema element.
type Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef.
func (*Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6 represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6 YANG schema element.
type Interface_RoutedVlan_Ipv6 struct {
	Address                map[string]*Interface_RoutedVlan_Ipv6_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	Counters               *Interface_RoutedVlan_Ipv6_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	DhcpClient             *bool                                          `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	DupAddrDetectTransmits *uint32                                        `path:"config/dup-addr-detect-transmits" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dup-addr-detect-transmits" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Enabled                *bool                                          `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mtu                    *uint32                                        `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mtu" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Neighbor               map[string]*Interface_RoutedVlan_Ipv6_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	RouterAdvertisement    *Interface_RoutedVlan_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"openconfig-if-ip"`
	Unnumbered             *Interface_RoutedVlan_Ipv6_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv6_Address struct to the
// list Address of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendAddress(v *Interface_RoutedVlan_Ipv6_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv6_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendNeighbor(v *Interface_RoutedVlan_Ipv6_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_RoutedVlan_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_RoutedVlan_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_RoutedVlan_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetDupAddrDetectTransmits retrieves the value of the leaf DupAddrDetectTransmits from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DupAddrDetectTransmits is set, it can
// safely use t.GetDupAddrDetectTransmits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DupAddrDetectTransmits == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetDupAddrDetectTransmits() uint32 {
	if t == nil || t.DupAddrDetectTransmits == nil {
		return 1
	}
	return *t.DupAddrDetectTransmits
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6.
func (*Interface_RoutedVlan_Ipv6) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address YANG schema element.
type Interface_RoutedVlan_Ipv6_Address struct {
	Ip           *string                                                `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	Origin       E_IfIp_IpAddressOrigin                                 `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	PrefixLength *uint8                                                 `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Status       E_IfIp_Address_Status                                  `path:"state/status" module:"openconfig-if-ip/openconfig-if-ip"`
	VrrpGroup    map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetStatus retrieves the value of the leaf Status from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Status is set, it can
// safely use t.GetStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Status == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetStatus() E_IfIp_Address_Status {
	if t == nil || t.Status == 0 {
		return 0
	}
	return t.Status
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address.
func (*Interface_RoutedVlan_Ipv6_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct {
	AcceptMode            *bool                                                          `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                        `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                         `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                          `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                        `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                         `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                       `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualLinkLocal      *string                                                        `path:"config/virtual-link-local" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-link-local" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                         `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualLinkLocal retrieves the value of the leaf VirtualLinkLocal from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualLinkLocal is set, it can
// safely use t.GetVirtualLinkLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualLinkLocal == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualLinkLocal() string {
	if t == nil || t.VirtualLinkLocal == nil {
		return ""
	}
	return *t.VirtualLinkLocal
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address_VrrpGroup.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Counters represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/state/counters YANG schema element.
type Interface_RoutedVlan_Ipv6_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Counters.
func (*Interface_RoutedVlan_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Neighbor represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/neighbors/neighbor YANG schema element.
type Interface_RoutedVlan_Ipv6_Neighbor struct {
	Ip               *string                       `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	IsRouter         *bool                         `path:"state/is-router" module:"openconfig-if-ip/openconfig-if-ip"`
	LinkLayerAddress *string                       `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	NeighborState    E_IfIp_Neighbor_NeighborState `path:"state/neighbor-state" module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin         `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetIsRouter retrieves the value of the leaf IsRouter from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsRouter is set, it can
// safely use t.GetIsRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsRouter == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetIsRouter() bool {
	if t == nil || t.IsRouter == nil {
		return false
	}
	return *t.IsRouter
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetNeighborState retrieves the value of the leaf NeighborState from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborState is set, it can
// safely use t.GetNeighborState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborState == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetNeighborState() E_IfIp_Neighbor_NeighborState {
	if t == nil || t.NeighborState == 0 {
		return 0
	}
	return t.NeighborState
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Neighbor.
func (*Interface_RoutedVlan_Ipv6_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_RouterAdvertisement represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/router-advertisement YANG schema element.
type Interface_RoutedVlan_Ipv6_RouterAdvertisement struct {
	Interval *uint32 `path:"config/interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Lifetime *uint32 `path:"config/lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Suppress *bool   `path:"config/suppress" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/suppress" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// GetInterval retrieves the value of the leaf Interval from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetLifetime retrieves the value of the leaf Lifetime from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lifetime is set, it can
// safely use t.GetLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lifetime == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetLifetime() uint32 {
	if t == nil || t.Lifetime == nil {
		return 0
	}
	return *t.Lifetime
}

// GetSuppress retrieves the value of the leaf Suppress from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Suppress is set, it can
// safely use t.GetSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Suppress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetSuppress() bool {
	if t == nil || t.Suppress == nil {
		return false
	}
	return *t.Suppress
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_RouterAdvertisement.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Unnumbered represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/unnumbered YANG schema element.
type Interface_RoutedVlan_Ipv6_Unnumbered struct {
	Enabled      *bool                                              `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv6_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Unnumbered.
func (*Interface_RoutedVlan_Ipv6_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/unnumbered/interface-ref YANG schema element.
type Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef.
func (*Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface YANG schema element.
type Interface_Subinterface struct {
	AdminStatus E_Interfaces_Interface_AdminStatus `path:"state/admin-status" module:"openconfig-interfaces/openconfig-interfaces"`
	Counters    *Interface_Subinterface_Counters   `path:"state/counters" module:"openconfig-interfaces/openconfig-interfaces"`
	Cpu         *bool                              `path:"state/cpu" module:"openconfig-interfaces/openconfig-interfaces"`
	Description *string                            `path:"config/description" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/description" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Enabled     *bool                              `path:"config/enabled" module:"openconfig-interfaces/openconfig-interfaces" shadow-path:"state/enabled" shadow-module:"openconfig-interfaces/openconfig-interfaces"`
	Ifindex     *uint32                            `path:"state/ifindex" module:"openconfig-interfaces/openconfig-interfaces"`
	Index       *uint32                            `path:"config/index|index" module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces" shadow-path:"state/index|index" shadow-module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces"`
	Ipv4        *Interface_Subinterface_Ipv4       `path:"ipv4" module:"openconfig-if-ip"`
	Ipv6        *Interface_Subinterface_Ipv6       `path:"ipv6" module:"openconfig-if-ip"`
	LastChange  *uint64                            `path:"state/last-change" module:"openconfig-interfaces/openconfig-interfaces"`
	Logical     *bool                              `path:"state/logical" module:"openconfig-interfaces/openconfig-interfaces"`
	Management  *bool                              `path:"state/management" module:"openconfig-interfaces/openconfig-interfaces"`
	Name        *string                            `path:"state/name" module:"openconfig-interfaces/openconfig-interfaces"`
	OperStatus  E_Interfaces_Interface_OperStatus  `path:"state/oper-status" module:"openconfig-interfaces/openconfig-interfaces"`
	Vlan        *Interface_Subinterface_Vlan       `path:"vlan" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateCounters() *Interface_Subinterface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Counters{}
	return t.Counters
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateIpv4() *Interface_Subinterface_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_Subinterface_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateIpv6() *Interface_Subinterface_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_Subinterface_Ipv6{}
	return t.Ipv6
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateVlan() *Interface_Subinterface_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &Interface_Subinterface_Vlan{}
	return t.Vlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetCounters() *Interface_Subinterface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetIpv4() *Interface_Subinterface_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetIpv6() *Interface_Subinterface_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from Interface_Subinterface. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetVlan() *Interface_Subinterface_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetAdminStatus() E_Interfaces_Interface_AdminStatus {
	if t == nil || t.AdminStatus == 0 {
		return 0
	}
	return t.AdminStatus
}

// GetCpu retrieves the value of the leaf Cpu from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cpu is set, it can
// safely use t.GetCpu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cpu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetCpu() bool {
	if t == nil || t.Cpu == nil {
		return false
	}
	return *t.Cpu
}

// GetDescription retrieves the value of the leaf Description from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetIfindex retrieves the value of the leaf Ifindex from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ifindex is set, it can
// safely use t.GetIfindex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ifindex == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetIfindex() uint32 {
	if t == nil || t.Ifindex == nil {
		return 0
	}
	return *t.Ifindex
}

// GetIndex retrieves the value of the leaf Index from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetLastChange retrieves the value of the leaf LastChange from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetLogical retrieves the value of the leaf Logical from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Logical is set, it can
// safely use t.GetLogical() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Logical == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetLogical() bool {
	if t == nil || t.Logical == nil {
		return false
	}
	return *t.Logical
}

// GetManagement retrieves the value of the leaf Management from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Management is set, it can
// safely use t.GetManagement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Management == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetManagement() bool {
	if t == nil || t.Management == nil {
		return false
	}
	return *t.Management
}

// GetName retrieves the value of the leaf Name from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetOperStatus() E_Interfaces_Interface_OperStatus {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// ΛListKeyMap returns the keys of the Interface_Subinterface struct, which is a YANG list entry.
func (t *Interface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface.
func (*Interface_Subinterface) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Subinterface_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/state/counters YANG schema element.
type Interface_Subinterface_Counters struct {
	CarrierTransitions *uint64 `path:"carrier-transitions" module:"openconfig-interfaces"`
	InBroadcastPkts    *uint64 `path:"in-broadcast-pkts" module:"openconfig-interfaces"`
	InDiscards         *uint64 `path:"in-discards" module:"openconfig-interfaces"`
	InErrors           *uint64 `path:"in-errors" module:"openconfig-interfaces"`
	InFcsErrors        *uint64 `path:"in-fcs-errors" module:"openconfig-interfaces"`
	InMulticastPkts    *uint64 `path:"in-multicast-pkts" module:"openconfig-interfaces"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-interfaces"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-interfaces"`
	InUnicastPkts      *uint64 `path:"in-unicast-pkts" module:"openconfig-interfaces"`
	InUnknownProtos    *uint64 `path:"in-unknown-protos" module:"openconfig-interfaces"`
	LastClear          *uint64 `path:"last-clear" module:"openconfig-interfaces"`
	OutBroadcastPkts   *uint64 `path:"out-broadcast-pkts" module:"openconfig-interfaces"`
	OutDiscards        *uint64 `path:"out-discards" module:"openconfig-interfaces"`
	OutErrors          *uint64 `path:"out-errors" module:"openconfig-interfaces"`
	OutMulticastPkts   *uint64 `path:"out-multicast-pkts" module:"openconfig-interfaces"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-interfaces"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-interfaces"`
	OutUnicastPkts     *uint64 `path:"out-unicast-pkts" module:"openconfig-interfaces"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Counters) IsYANGGoStruct() {}

// GetCarrierTransitions retrieves the value of the leaf CarrierTransitions from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CarrierTransitions is set, it can
// safely use t.GetCarrierTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CarrierTransitions == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetCarrierTransitions() uint64 {
	if t == nil || t.CarrierTransitions == nil {
		return 0
	}
	return *t.CarrierTransitions
}

// GetInBroadcastPkts retrieves the value of the leaf InBroadcastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBroadcastPkts is set, it can
// safely use t.GetInBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInBroadcastPkts() uint64 {
	if t == nil || t.InBroadcastPkts == nil {
		return 0
	}
	return *t.InBroadcastPkts
}

// GetInDiscards retrieves the value of the leaf InDiscards from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscards is set, it can
// safely use t.GetInDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInDiscards() uint64 {
	if t == nil || t.InDiscards == nil {
		return 0
	}
	return *t.InDiscards
}

// GetInErrors retrieves the value of the leaf InErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrors is set, it can
// safely use t.GetInErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInErrors() uint64 {
	if t == nil || t.InErrors == nil {
		return 0
	}
	return *t.InErrors
}

// GetInFcsErrors retrieves the value of the leaf InFcsErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFcsErrors is set, it can
// safely use t.GetInFcsErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFcsErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInFcsErrors() uint64 {
	if t == nil || t.InFcsErrors == nil {
		return 0
	}
	return *t.InFcsErrors
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetInUnicastPkts retrieves the value of the leaf InUnicastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnicastPkts is set, it can
// safely use t.GetInUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInUnicastPkts() uint64 {
	if t == nil || t.InUnicastPkts == nil {
		return 0
	}
	return *t.InUnicastPkts
}

// GetInUnknownProtos retrieves the value of the leaf InUnknownProtos from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnknownProtos is set, it can
// safely use t.GetInUnknownProtos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnknownProtos == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInUnknownProtos() uint64 {
	if t == nil || t.InUnknownProtos == nil {
		return 0
	}
	return *t.InUnknownProtos
}

// GetLastClear retrieves the value of the leaf LastClear from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetLastClear() uint64 {
	if t == nil || t.LastClear == nil {
		return 0
	}
	return *t.LastClear
}

// GetOutBroadcastPkts retrieves the value of the leaf OutBroadcastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutBroadcastPkts is set, it can
// safely use t.GetOutBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutBroadcastPkts() uint64 {
	if t == nil || t.OutBroadcastPkts == nil {
		return 0
	}
	return *t.OutBroadcastPkts
}

// GetOutDiscards retrieves the value of the leaf OutDiscards from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscards is set, it can
// safely use t.GetOutDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutDiscards() uint64 {
	if t == nil || t.OutDiscards == nil {
		return 0
	}
	return *t.OutDiscards
}

// GetOutErrors retrieves the value of the leaf OutErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrors is set, it can
// safely use t.GetOutErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutErrors() uint64 {
	if t == nil || t.OutErrors == nil {
		return 0
	}
	return *t.OutErrors
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// GetOutUnicastPkts retrieves the value of the leaf OutUnicastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutUnicastPkts is set, it can
// safely use t.GetOutUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutUnicastPkts() uint64 {
	if t == nil || t.OutUnicastPkts == nil {
		return 0
	}
	return *t.OutUnicastPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Counters.
func (*Interface_Subinterface_Counters) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Subinterface_Ipv4 represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4 YANG schema element.
type Interface_Subinterface_Ipv4 struct {
	Address    map[string]*Interface_Subinterface_Ipv4_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	Counters   *Interface_Subinterface_Ipv4_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	DhcpClient *bool                                            `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Enabled    *bool                                            `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mtu        *uint16                                          `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mtu" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Neighbor   map[string]*Interface_Subinterface_Ipv4_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	ProxyArp   *Interface_Subinterface_Ipv4_ProxyArp            `path:"proxy-arp" module:"openconfig-if-ip"`
	Unnumbered *Interface_Subinterface_Ipv4_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewAddress(Ip string) (*Interface_Subinterface_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv4_Address struct to the
// list Address of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendAddress(v *Interface_Subinterface_Ipv4_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv4_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendNeighbor(v *Interface_Subinterface_Ipv4_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateCounters() *Interface_Subinterface_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_Subinterface_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Subinterface_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetCounters() *Interface_Subinterface_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4.
func (*Interface_Subinterface_Ipv4) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address YANG schema element.
type Interface_Subinterface_Ipv4_Address struct {
	Ip           *string                                                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	Origin       E_IfIp_IpAddressOrigin                                   `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	PrefixLength *uint8                                                   `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VrrpGroup    map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv4_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address.
func (*Interface_Subinterface_Ipv4_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_Subinterface_Ipv4_Address_VrrpGroup struct {
	AcceptMode            *bool                                                            `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                          `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                           `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                            `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                          `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                           `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                         `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                           `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address_VrrpGroup.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/state/counters YANG schema element.
type Interface_Subinterface_Ipv4_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Counters.
func (*Interface_Subinterface_Ipv4_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Neighbor represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor YANG schema element.
type Interface_Subinterface_Ipv4_Neighbor struct {
	Ip               *string               `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	LinkLayerAddress *string               `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Neighbor.
func (*Interface_Subinterface_Ipv4_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_ProxyArp represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/proxy-arp YANG schema element.
type Interface_Subinterface_Ipv4_ProxyArp struct {
	Mode E_IfIp_ProxyArp_Mode `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_ProxyArp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_ProxyArp) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the Interface_Subinterface_Ipv4_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_ProxyArp) GetMode() E_IfIp_ProxyArp_Mode {
	if t == nil || t.Mode == 0 {
		return IfIp_ProxyArp_Mode_DISABLE
	}
	return t.Mode
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_ProxyArp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_ProxyArp.
func (*Interface_Subinterface_Ipv4_ProxyArp) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Unnumbered represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered YANG schema element.
type Interface_Subinterface_Ipv4_Unnumbered struct {
	Enabled      *bool                                                `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Unnumbered.
func (*Interface_Subinterface_Ipv4_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface-ref YANG schema element.
type Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef.
func (*Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6 represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6 YANG schema element.
type Interface_Subinterface_Ipv6 struct {
	Address                map[string]*Interface_Subinterface_Ipv6_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	Autoconf               *Interface_Subinterface_Ipv6_Autoconf            `path:"autoconf" module:"openconfig-if-ip-ext"`
	Counters               *Interface_Subinterface_Ipv6_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	DhcpClient             *bool                                            `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	DupAddrDetectTransmits *uint32                                          `path:"config/dup-addr-detect-transmits" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/dup-addr-detect-transmits" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Enabled                *bool                                            `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Mtu                    *uint32                                          `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/mtu" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Neighbor               map[string]*Interface_Subinterface_Ipv6_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	RouterAdvertisement    *Interface_Subinterface_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"openconfig-if-ip"`
	Unnumbered             *Interface_Subinterface_Ipv6_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewAddress(Ip string) (*Interface_Subinterface_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv6_Address struct to the
// list Address of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendAddress(v *Interface_Subinterface_Ipv6_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv6_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendNeighbor(v *Interface_Subinterface_Ipv6_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateAutoconf retrieves the value of the Autoconf field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAutoconf() *Interface_Subinterface_Ipv6_Autoconf {
	if t.Autoconf != nil {
		return t.Autoconf
	}
	t.Autoconf = &Interface_Subinterface_Ipv6_Autoconf{}
	return t.Autoconf
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateCounters() *Interface_Subinterface_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_Subinterface_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Subinterface_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetAutoconf returns the value of the Autoconf struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Autoconf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetAutoconf() *Interface_Subinterface_Ipv6_Autoconf {
	if t != nil && t.Autoconf != nil {
		return t.Autoconf
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetCounters() *Interface_Subinterface_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetDupAddrDetectTransmits retrieves the value of the leaf DupAddrDetectTransmits from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DupAddrDetectTransmits is set, it can
// safely use t.GetDupAddrDetectTransmits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DupAddrDetectTransmits == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetDupAddrDetectTransmits() uint32 {
	if t == nil || t.DupAddrDetectTransmits == nil {
		return 1
	}
	return *t.DupAddrDetectTransmits
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6.
func (*Interface_Subinterface_Ipv6) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address YANG schema element.
type Interface_Subinterface_Ipv6_Address struct {
	Ip           *string                                                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	Origin       E_IfIp_IpAddressOrigin                                   `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	PrefixLength *uint8                                                   `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Status       E_IfIp_Address_Status                                    `path:"state/status" module:"openconfig-if-ip/openconfig-if-ip"`
	VrrpGroup    map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv6_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetStatus retrieves the value of the leaf Status from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Status is set, it can
// safely use t.GetStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Status == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetStatus() E_IfIp_Address_Status {
	if t == nil || t.Status == 0 {
		return 0
	}
	return t.Status
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address.
func (*Interface_Subinterface_Ipv6_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_Subinterface_Ipv6_Address_VrrpGroup struct {
	AcceptMode            *bool                                                            `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                          `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                           `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                            `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                          `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                           `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                         `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualLinkLocal      *string                                                          `path:"config/virtual-link-local" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/virtual-link-local" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                           `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualLinkLocal retrieves the value of the leaf VirtualLinkLocal from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualLinkLocal is set, it can
// safely use t.GetVirtualLinkLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualLinkLocal == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualLinkLocal() string {
	if t == nil || t.VirtualLinkLocal == nil {
		return ""
	}
	return *t.VirtualLinkLocal
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address_VrrpGroup.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Autoconf represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/autoconf YANG schema element.
type Interface_Subinterface_Ipv6_Autoconf struct {
	CreateGlobalAddresses      *bool   `path:"config/create-global-addresses" module:"openconfig-if-ip-ext/openconfig-if-ip-ext" shadow-path:"state/create-global-addresses" shadow-module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	CreateTemporaryAddresses   *bool   `path:"config/create-temporary-addresses" module:"openconfig-if-ip-ext/openconfig-if-ip-ext" shadow-path:"state/create-temporary-addresses" shadow-module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	TemporaryPreferredLifetime *uint32 `path:"config/temporary-preferred-lifetime" module:"openconfig-if-ip-ext/openconfig-if-ip-ext" shadow-path:"state/temporary-preferred-lifetime" shadow-module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	TemporaryValidLifetime     *uint32 `path:"config/temporary-valid-lifetime" module:"openconfig-if-ip-ext/openconfig-if-ip-ext" shadow-path:"state/temporary-valid-lifetime" shadow-module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Autoconf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Autoconf) IsYANGGoStruct() {}

// GetCreateGlobalAddresses retrieves the value of the leaf CreateGlobalAddresses from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CreateGlobalAddresses is set, it can
// safely use t.GetCreateGlobalAddresses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CreateGlobalAddresses == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetCreateGlobalAddresses() bool {
	if t == nil || t.CreateGlobalAddresses == nil {
		return true
	}
	return *t.CreateGlobalAddresses
}

// GetCreateTemporaryAddresses retrieves the value of the leaf CreateTemporaryAddresses from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CreateTemporaryAddresses is set, it can
// safely use t.GetCreateTemporaryAddresses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CreateTemporaryAddresses == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetCreateTemporaryAddresses() bool {
	if t == nil || t.CreateTemporaryAddresses == nil {
		return false
	}
	return *t.CreateTemporaryAddresses
}

// GetTemporaryPreferredLifetime retrieves the value of the leaf TemporaryPreferredLifetime from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TemporaryPreferredLifetime is set, it can
// safely use t.GetTemporaryPreferredLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TemporaryPreferredLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetTemporaryPreferredLifetime() uint32 {
	if t == nil || t.TemporaryPreferredLifetime == nil {
		return 86400
	}
	return *t.TemporaryPreferredLifetime
}

// GetTemporaryValidLifetime retrieves the value of the leaf TemporaryValidLifetime from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TemporaryValidLifetime is set, it can
// safely use t.GetTemporaryValidLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TemporaryValidLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetTemporaryValidLifetime() uint32 {
	if t == nil || t.TemporaryValidLifetime == nil {
		return 604800
	}
	return *t.TemporaryValidLifetime
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Autoconf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Autoconf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Autoconf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Autoconf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Autoconf.
func (*Interface_Subinterface_Ipv6_Autoconf) ΛBelongingModule() string {
	return "openconfig-if-ip-ext"
}

// Interface_Subinterface_Ipv6_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/state/counters YANG schema element.
type Interface_Subinterface_Ipv6_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Counters.
func (*Interface_Subinterface_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Neighbor represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor YANG schema element.
type Interface_Subinterface_Ipv6_Neighbor struct {
	Ip               *string                       `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	IsRouter         *bool                         `path:"state/is-router" module:"openconfig-if-ip/openconfig-if-ip"`
	LinkLayerAddress *string                       `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	NeighborState    E_IfIp_Neighbor_NeighborState `path:"state/neighbor-state" module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin         `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetIsRouter retrieves the value of the leaf IsRouter from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsRouter is set, it can
// safely use t.GetIsRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsRouter == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetIsRouter() bool {
	if t == nil || t.IsRouter == nil {
		return false
	}
	return *t.IsRouter
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetNeighborState retrieves the value of the leaf NeighborState from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborState is set, it can
// safely use t.GetNeighborState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborState == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetNeighborState() E_IfIp_Neighbor_NeighborState {
	if t == nil || t.NeighborState == 0 {
		return 0
	}
	return t.NeighborState
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Neighbor.
func (*Interface_Subinterface_Ipv6_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_RouterAdvertisement represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement YANG schema element.
type Interface_Subinterface_Ipv6_RouterAdvertisement struct {
	Interval *uint32 `path:"config/interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Lifetime *uint32 `path:"config/lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Suppress *bool   `path:"config/suppress" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/suppress" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// GetInterval retrieves the value of the leaf Interval from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetLifetime retrieves the value of the leaf Lifetime from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lifetime is set, it can
// safely use t.GetLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetLifetime() uint32 {
	if t == nil || t.Lifetime == nil {
		return 0
	}
	return *t.Lifetime
}

// GetSuppress retrieves the value of the leaf Suppress from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Suppress is set, it can
// safely use t.GetSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Suppress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetSuppress() bool {
	if t == nil || t.Suppress == nil {
		return false
	}
	return *t.Suppress
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_RouterAdvertisement.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Unnumbered represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered YANG schema element.
type Interface_Subinterface_Ipv6_Unnumbered struct {
	Enabled      *bool                                                `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv6_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Unnumbered.
func (*Interface_Subinterface_Ipv6_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface-ref YANG schema element.
type Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"state/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef.
func (*Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Vlan represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan YANG schema element.
type Interface_Subinterface_Vlan struct {
	EgressMapping  *Interface_Subinterface_Vlan_EgressMapping  `path:"egress-mapping" module:"openconfig-vlan"`
	IngressMapping *Interface_Subinterface_Vlan_IngressMapping `path:"ingress-mapping" module:"openconfig-vlan"`
	Match          *Interface_Subinterface_Vlan_Match          `path:"match" module:"openconfig-vlan"`
	VlanId         Interface_Subinterface_Vlan_VlanId_Union    `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan) IsYANGGoStruct() {}

// GetOrCreateEgressMapping retrieves the value of the EgressMapping field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateEgressMapping() *Interface_Subinterface_Vlan_EgressMapping {
	if t.EgressMapping != nil {
		return t.EgressMapping
	}
	t.EgressMapping = &Interface_Subinterface_Vlan_EgressMapping{}
	return t.EgressMapping
}

// GetOrCreateIngressMapping retrieves the value of the IngressMapping field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateIngressMapping() *Interface_Subinterface_Vlan_IngressMapping {
	if t.IngressMapping != nil {
		return t.IngressMapping
	}
	t.IngressMapping = &Interface_Subinterface_Vlan_IngressMapping{}
	return t.IngressMapping
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateMatch() *Interface_Subinterface_Vlan_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &Interface_Subinterface_Vlan_Match{}
	return t.Match
}

// GetEgressMapping returns the value of the EgressMapping struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field EgressMapping is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetEgressMapping() *Interface_Subinterface_Vlan_EgressMapping {
	if t != nil && t.EgressMapping != nil {
		return t.EgressMapping
	}
	return nil
}

// GetIngressMapping returns the value of the IngressMapping struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field IngressMapping is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetIngressMapping() *Interface_Subinterface_Vlan_IngressMapping {
	if t != nil && t.IngressMapping != nil {
		return t.IngressMapping
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetMatch() *Interface_Subinterface_Vlan_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan) GetVlanId() Interface_Subinterface_Vlan_VlanId_Union {
	if t == nil || t.VlanId == nil {
		return nil
	}
	return t.VlanId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan.
func (*Interface_Subinterface_Vlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_EgressMapping represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/egress-mapping YANG schema element.
type Interface_Subinterface_Vlan_EgressMapping struct {
	Tpid            E_VlanTypes_TPID_TYPES      `path:"config/tpid" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/tpid" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanId          *uint16                     `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanStackAction E_VlanTypes_VlanStackAction `path:"config/vlan-stack-action" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-stack-action" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_EgressMapping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_EgressMapping) IsYANGGoStruct() {}

// GetTpid retrieves the value of the leaf Tpid from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// GetVlanStackAction retrieves the value of the leaf VlanStackAction from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanStackAction is set, it can
// safely use t.GetVlanStackAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanStackAction == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetVlanStackAction() E_VlanTypes_VlanStackAction {
	if t == nil || t.VlanStackAction == 0 {
		return 0
	}
	return t.VlanStackAction
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_EgressMapping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_EgressMapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_EgressMapping) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_EgressMapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_EgressMapping.
func (*Interface_Subinterface_Vlan_EgressMapping) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_IngressMapping represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/ingress-mapping YANG schema element.
type Interface_Subinterface_Vlan_IngressMapping struct {
	Tpid            E_VlanTypes_TPID_TYPES      `path:"config/tpid" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/tpid" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanId          *uint16                     `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanStackAction E_VlanTypes_VlanStackAction `path:"config/vlan-stack-action" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-stack-action" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_IngressMapping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_IngressMapping) IsYANGGoStruct() {}

// GetTpid retrieves the value of the leaf Tpid from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// GetVlanStackAction retrieves the value of the leaf VlanStackAction from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanStackAction is set, it can
// safely use t.GetVlanStackAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanStackAction == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetVlanStackAction() E_VlanTypes_VlanStackAction {
	if t == nil || t.VlanStackAction == 0 {
		return 0
	}
	return t.VlanStackAction
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_IngressMapping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_IngressMapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_IngressMapping) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_IngressMapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_IngressMapping.
func (*Interface_Subinterface_Vlan_IngressMapping) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match YANG schema element.
type Interface_Subinterface_Vlan_Match struct {
	DoubleTagged                *Interface_Subinterface_Vlan_Match_DoubleTagged                `path:"double-tagged" module:"openconfig-vlan"`
	DoubleTaggedInnerList       *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList       `path:"double-tagged-inner-list" module:"openconfig-vlan"`
	DoubleTaggedInnerOuterRange *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange `path:"double-tagged-inner-outer-range" module:"openconfig-vlan"`
	DoubleTaggedInnerRange      *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange      `path:"double-tagged-inner-range" module:"openconfig-vlan"`
	DoubleTaggedOuterList       *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList       `path:"double-tagged-outer-list" module:"openconfig-vlan"`
	DoubleTaggedOuterRange      *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange      `path:"double-tagged-outer-range" module:"openconfig-vlan"`
	SingleTagged                *Interface_Subinterface_Vlan_Match_SingleTagged                `path:"single-tagged" module:"openconfig-vlan"`
	SingleTaggedList            *Interface_Subinterface_Vlan_Match_SingleTaggedList            `path:"single-tagged-list" module:"openconfig-vlan"`
	SingleTaggedRange           *Interface_Subinterface_Vlan_Match_SingleTaggedRange           `path:"single-tagged-range" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match) IsYANGGoStruct() {}

// GetOrCreateDoubleTagged retrieves the value of the DoubleTagged field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTagged() *Interface_Subinterface_Vlan_Match_DoubleTagged {
	if t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	t.DoubleTagged = &Interface_Subinterface_Vlan_Match_DoubleTagged{}
	return t.DoubleTagged
}

// GetOrCreateDoubleTaggedInnerList retrieves the value of the DoubleTaggedInnerList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerList() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList {
	if t.DoubleTaggedInnerList != nil {
		return t.DoubleTaggedInnerList
	}
	t.DoubleTaggedInnerList = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList{}
	return t.DoubleTaggedInnerList
}

// GetOrCreateDoubleTaggedInnerOuterRange retrieves the value of the DoubleTaggedInnerOuterRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange {
	if t.DoubleTaggedInnerOuterRange != nil {
		return t.DoubleTaggedInnerOuterRange
	}
	t.DoubleTaggedInnerOuterRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange{}
	return t.DoubleTaggedInnerOuterRange
}

// GetOrCreateDoubleTaggedInnerRange retrieves the value of the DoubleTaggedInnerRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange {
	if t.DoubleTaggedInnerRange != nil {
		return t.DoubleTaggedInnerRange
	}
	t.DoubleTaggedInnerRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange{}
	return t.DoubleTaggedInnerRange
}

// GetOrCreateDoubleTaggedOuterList retrieves the value of the DoubleTaggedOuterList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedOuterList() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList {
	if t.DoubleTaggedOuterList != nil {
		return t.DoubleTaggedOuterList
	}
	t.DoubleTaggedOuterList = &Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList{}
	return t.DoubleTaggedOuterList
}

// GetOrCreateDoubleTaggedOuterRange retrieves the value of the DoubleTaggedOuterRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange {
	if t.DoubleTaggedOuterRange != nil {
		return t.DoubleTaggedOuterRange
	}
	t.DoubleTaggedOuterRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange{}
	return t.DoubleTaggedOuterRange
}

// GetOrCreateSingleTagged retrieves the value of the SingleTagged field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTagged() *Interface_Subinterface_Vlan_Match_SingleTagged {
	if t.SingleTagged != nil {
		return t.SingleTagged
	}
	t.SingleTagged = &Interface_Subinterface_Vlan_Match_SingleTagged{}
	return t.SingleTagged
}

// GetOrCreateSingleTaggedList retrieves the value of the SingleTaggedList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTaggedList() *Interface_Subinterface_Vlan_Match_SingleTaggedList {
	if t.SingleTaggedList != nil {
		return t.SingleTaggedList
	}
	t.SingleTaggedList = &Interface_Subinterface_Vlan_Match_SingleTaggedList{}
	return t.SingleTaggedList
}

// GetOrCreateSingleTaggedRange retrieves the value of the SingleTaggedRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTaggedRange() *Interface_Subinterface_Vlan_Match_SingleTaggedRange {
	if t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	t.SingleTaggedRange = &Interface_Subinterface_Vlan_Match_SingleTaggedRange{}
	return t.SingleTaggedRange
}

// GetDoubleTagged returns the value of the DoubleTagged struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTagged() *Interface_Subinterface_Vlan_Match_DoubleTagged {
	if t != nil && t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	return nil
}

// GetDoubleTaggedInnerList returns the value of the DoubleTaggedInnerList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerList() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList {
	if t != nil && t.DoubleTaggedInnerList != nil {
		return t.DoubleTaggedInnerList
	}
	return nil
}

// GetDoubleTaggedInnerOuterRange returns the value of the DoubleTaggedInnerOuterRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerOuterRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange {
	if t != nil && t.DoubleTaggedInnerOuterRange != nil {
		return t.DoubleTaggedInnerOuterRange
	}
	return nil
}

// GetDoubleTaggedInnerRange returns the value of the DoubleTaggedInnerRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange {
	if t != nil && t.DoubleTaggedInnerRange != nil {
		return t.DoubleTaggedInnerRange
	}
	return nil
}

// GetDoubleTaggedOuterList returns the value of the DoubleTaggedOuterList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedOuterList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedOuterList() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList {
	if t != nil && t.DoubleTaggedOuterList != nil {
		return t.DoubleTaggedOuterList
	}
	return nil
}

// GetDoubleTaggedOuterRange returns the value of the DoubleTaggedOuterRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedOuterRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange {
	if t != nil && t.DoubleTaggedOuterRange != nil {
		return t.DoubleTaggedOuterRange
	}
	return nil
}

// GetSingleTagged returns the value of the SingleTagged struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTagged() *Interface_Subinterface_Vlan_Match_SingleTagged {
	if t != nil && t.SingleTagged != nil {
		return t.SingleTagged
	}
	return nil
}

// GetSingleTaggedList returns the value of the SingleTaggedList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTaggedList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTaggedList() *Interface_Subinterface_Vlan_Match_SingleTaggedList {
	if t != nil && t.SingleTaggedList != nil {
		return t.SingleTaggedList
	}
	return nil
}

// GetSingleTaggedRange returns the value of the SingleTaggedRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTaggedRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTaggedRange() *Interface_Subinterface_Vlan_Match_SingleTaggedRange {
	if t != nil && t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match.
func (*Interface_Subinterface_Vlan_Match) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTagged struct {
	InnerVlanId *uint16 `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId *uint16 `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTagged) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTagged.
func (*Interface_Subinterface_Vlan_Match_DoubleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList struct {
	InnerVlanIds []uint16 `path:"config/inner-vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId  *uint16  `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) IsYANGGoStruct() {}

// GetInnerVlanIds retrieves the value of the leaf InnerVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanIds is set, it can
// safely use t.GetInnerVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetInnerVlanIds() []uint16 {
	if t == nil || t.InnerVlanIds == nil {
		return nil
	}
	return t.InnerVlanIds
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange struct {
	InnerHighVlanId *uint16 `path:"config/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InnerLowVlanId  *uint16 `path:"config/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterHighVlanId *uint16 `path:"config/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterLowVlanId  *uint16 `path:"config/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange struct {
	InnerHighVlanId *uint16  `path:"config/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InnerLowVlanId  *uint16  `path:"config/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId     []uint16 `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetOuterVlanId() []uint16 {
	if t == nil || t.OuterVlanId == nil {
		return nil
	}
	return t.OuterVlanId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList struct {
	InnerVlanId  *uint16  `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanIds []uint16 `path:"config/outer-vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanIds retrieves the value of the leaf OuterVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanIds is set, it can
// safely use t.GetOuterVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetOuterVlanIds() []uint16 {
	if t == nil || t.OuterVlanIds == nil {
		return nil
	}
	return t.OuterVlanIds
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange struct {
	InnerVlanId     *uint16 `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterHighVlanId *uint16 `path:"config/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterLowVlanId  *uint16 `path:"config/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/outer-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTagged struct {
	VlanId *uint16 `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) IsYANGGoStruct() {}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_Match_SingleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTagged.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-list YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedList struct {
	VlanIds []uint16 `path:"config/vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) IsYANGGoStruct() {}

// GetVlanIds retrieves the value of the leaf VlanIds from the Interface_Subinterface_Vlan_Match_SingleTaggedList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanIds is set, it can
// safely use t.GetVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) GetVlanIds() []uint16 {
	if t == nil || t.VlanIds == nil {
		return nil
	}
	return t.VlanIds
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedList.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-range YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedRange struct {
	HighVlanId *uint16 `path:"config/high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	LowVlanId  *uint16 `path:"config/low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"state/low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) IsYANGGoStruct() {}

// GetHighVlanId retrieves the value of the leaf HighVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighVlanId is set, it can
// safely use t.GetHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetHighVlanId() uint16 {
	if t == nil || t.HighVlanId == nil {
		return 0
	}
	return *t.HighVlanId
}

// GetLowVlanId retrieves the value of the leaf LowVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowVlanId is set, it can
// safely use t.GetLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetLowVlanId() uint16 {
	if t == nil || t.LowVlanId == nil {
		return 0
	}
	return *t.LowVlanId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedRange.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Tunnel represents the /openconfig-interfaces/interfaces/interface/tunnel YANG schema element.
type Interface_Tunnel struct {
	Dst    *string                `path:"config/dst" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/dst" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	GreKey *uint32                `path:"config/gre-key" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/gre-key" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Ipv4   *Interface_Tunnel_Ipv4 `path:"ipv4" module:"openconfig-if-tunnel"`
	Ipv6   *Interface_Tunnel_Ipv6 `path:"ipv6" module:"openconfig-if-tunnel"`
	Src    *string                `path:"config/src" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/src" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Ttl    *uint8                 `path:"config/ttl" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/ttl" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel) IsYANGGoStruct() {}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel) GetOrCreateIpv4() *Interface_Tunnel_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_Tunnel_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel) GetOrCreateIpv6() *Interface_Tunnel_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_Tunnel_Ipv6{}
	return t.Ipv6
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_Tunnel. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel) GetIpv4() *Interface_Tunnel_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_Tunnel. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel) GetIpv6() *Interface_Tunnel_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetDst retrieves the value of the leaf Dst from the Interface_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dst is set, it can
// safely use t.GetDst() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dst == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel) GetDst() string {
	if t == nil || t.Dst == nil {
		return ""
	}
	return *t.Dst
}

// GetGreKey retrieves the value of the leaf GreKey from the Interface_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GreKey is set, it can
// safely use t.GetGreKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GreKey == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel) GetGreKey() uint32 {
	if t == nil || t.GreKey == nil {
		return 0
	}
	return *t.GreKey
}

// GetSrc retrieves the value of the leaf Src from the Interface_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Src is set, it can
// safely use t.GetSrc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Src == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel) GetSrc() string {
	if t == nil || t.Src == nil {
		return ""
	}
	return *t.Src
}

// GetTtl retrieves the value of the leaf Ttl from the Interface_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ttl is set, it can
// safely use t.GetTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ttl == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel) GetTtl() uint8 {
	if t == nil || t.Ttl == nil {
		return 0
	}
	return *t.Ttl
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel.
func (*Interface_Tunnel) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv4 represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv4 YANG schema element.
type Interface_Tunnel_Ipv4 struct {
	Address    map[string]*Interface_Tunnel_Ipv4_Address  `path:"addresses/address" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Counters   *Interface_Tunnel_Ipv4_Counters            `path:"state/counters" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	DhcpClient *bool                                      `path:"config/dhcp-client" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Enabled    *bool                                      `path:"config/enabled" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/enabled" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Mtu        *uint16                                    `path:"config/mtu" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/mtu" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Neighbor   map[string]*Interface_Tunnel_Ipv4_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	ProxyArp   *Interface_Tunnel_Ipv4_ProxyArp            `path:"proxy-arp" module:"openconfig-if-tunnel"`
	Unnumbered *Interface_Tunnel_Ipv4_Unnumbered          `path:"unnumbered" module:"openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_Tunnel_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Tunnel_Ipv4) NewAddress(Ip string) (*Interface_Tunnel_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Tunnel_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Tunnel_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Tunnel_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Tunnel_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Tunnel_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Tunnel_Ipv4) GetOrCreateAddress(Ip string) *Interface_Tunnel_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Tunnel_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Tunnel_Ipv4) GetAddress(Ip string) *Interface_Tunnel_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Tunnel_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Tunnel_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Tunnel_Ipv4_Address struct to the
// list Address of Interface_Tunnel_Ipv4. If the key value(s) specified in
// the supplied Interface_Tunnel_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_Tunnel_Ipv4) AppendAddress(v *Interface_Tunnel_Ipv4_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Tunnel_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Tunnel_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Tunnel_Ipv4) NewNeighbor(Ip string) (*Interface_Tunnel_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Tunnel_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Tunnel_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Tunnel_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Tunnel_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Tunnel_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Tunnel_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_Tunnel_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Tunnel_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Tunnel_Ipv4) GetNeighbor(Ip string) *Interface_Tunnel_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Tunnel_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Tunnel_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Tunnel_Ipv4_Neighbor struct to the
// list Neighbor of Interface_Tunnel_Ipv4. If the key value(s) specified in
// the supplied Interface_Tunnel_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Tunnel_Ipv4) AppendNeighbor(v *Interface_Tunnel_Ipv4_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Tunnel_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel_Ipv4) GetOrCreateCounters() *Interface_Tunnel_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Tunnel_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel_Ipv4) GetOrCreateProxyArp() *Interface_Tunnel_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_Tunnel_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel_Ipv4) GetOrCreateUnnumbered() *Interface_Tunnel_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Tunnel_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Tunnel_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel_Ipv4) GetCounters() *Interface_Tunnel_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_Tunnel_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel_Ipv4) GetProxyArp() *Interface_Tunnel_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Tunnel_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel_Ipv4) GetUnnumbered() *Interface_Tunnel_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_Tunnel_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Tunnel_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_Tunnel_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv4.
func (*Interface_Tunnel_Ipv4) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv4_Address represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv4/addresses/address YANG schema element.
type Interface_Tunnel_Ipv4_Address struct {
	Ip           *string                `path:"config/ip|ip" module:"openconfig-if-tunnel/openconfig-if-tunnel|openconfig-if-tunnel" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel|openconfig-if-tunnel"`
	Origin       E_IfIp_IpAddressOrigin `path:"state/origin" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	PrefixLength *uint8                 `path:"config/prefix-length" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv4_Address) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Tunnel_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Tunnel_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_Tunnel_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// ΛListKeyMap returns the keys of the Interface_Tunnel_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_Tunnel_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv4_Address.
func (*Interface_Tunnel_Ipv4_Address) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv4_Counters represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv4/state/counters YANG schema element.
type Interface_Tunnel_Ipv4_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-tunnel"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-tunnel"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-tunnel"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-tunnel"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-tunnel"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-tunnel"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-tunnel"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-tunnel"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-tunnel"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-tunnel"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-tunnel"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv4_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv4_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Tunnel_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv4_Counters.
func (*Interface_Tunnel_Ipv4_Counters) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv4_Neighbor represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv4/neighbors/neighbor YANG schema element.
type Interface_Tunnel_Ipv4_Neighbor struct {
	Ip               *string               `path:"config/ip|ip" module:"openconfig-if-tunnel/openconfig-if-tunnel|openconfig-if-tunnel" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel|openconfig-if-tunnel"`
	LinkLayerAddress *string               `path:"config/link-layer-address" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Origin           E_IfIp_NeighborOrigin `path:"state/origin" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv4_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv4_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Tunnel_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Tunnel_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Tunnel_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// ΛListKeyMap returns the keys of the Interface_Tunnel_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_Tunnel_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv4_Neighbor.
func (*Interface_Tunnel_Ipv4_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv4_ProxyArp represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv4/proxy-arp YANG schema element.
type Interface_Tunnel_Ipv4_ProxyArp struct {
	Mode E_IfIp_ProxyArp_Mode `path:"config/mode" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/mode" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv4_ProxyArp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv4_ProxyArp) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the Interface_Tunnel_Ipv4_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_ProxyArp) GetMode() E_IfIp_ProxyArp_Mode {
	if t == nil || t.Mode == 0 {
		return IfIp_ProxyArp_Mode_DISABLE
	}
	return t.Mode
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_ProxyArp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv4_ProxyArp.
func (*Interface_Tunnel_Ipv4_ProxyArp) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv4_Unnumbered represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv4/unnumbered YANG schema element.
type Interface_Tunnel_Ipv4_Unnumbered struct {
	Enabled      *bool                                          `path:"config/enabled" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/enabled" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	InterfaceRef *Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv4_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv4_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Tunnel_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel_Ipv4_Unnumbered) GetInterfaceRef() *Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Tunnel_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv4_Unnumbered.
func (*Interface_Tunnel_Ipv4_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv4/unnumbered/interface-ref YANG schema element.
type Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/interface" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/subinterface" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef.
func (*Interface_Tunnel_Ipv4_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv6 represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv6 YANG schema element.
type Interface_Tunnel_Ipv6 struct {
	Address                map[string]*Interface_Tunnel_Ipv6_Address  `path:"addresses/address" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Counters               *Interface_Tunnel_Ipv6_Counters            `path:"state/counters" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	DhcpClient             *bool                                      `path:"config/dhcp-client" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/dhcp-client" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	DupAddrDetectTransmits *uint32                                    `path:"config/dup-addr-detect-transmits" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/dup-addr-detect-transmits" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Enabled                *bool                                      `path:"config/enabled" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/enabled" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Mtu                    *uint32                                    `path:"config/mtu" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/mtu" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Neighbor               map[string]*Interface_Tunnel_Ipv6_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	RouterAdvertisement    *Interface_Tunnel_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"openconfig-if-tunnel"`
	Unnumbered             *Interface_Tunnel_Ipv6_Unnumbered          `path:"unnumbered" module:"openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_Tunnel_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Tunnel_Ipv6) NewAddress(Ip string) (*Interface_Tunnel_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Tunnel_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Tunnel_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Tunnel_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Tunnel_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Tunnel_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Tunnel_Ipv6) GetOrCreateAddress(Ip string) *Interface_Tunnel_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Tunnel_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Tunnel_Ipv6) GetAddress(Ip string) *Interface_Tunnel_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Tunnel_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Tunnel_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Tunnel_Ipv6_Address struct to the
// list Address of Interface_Tunnel_Ipv6. If the key value(s) specified in
// the supplied Interface_Tunnel_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_Tunnel_Ipv6) AppendAddress(v *Interface_Tunnel_Ipv6_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Tunnel_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Tunnel_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Tunnel_Ipv6) NewNeighbor(Ip string) (*Interface_Tunnel_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Tunnel_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Tunnel_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Tunnel_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Tunnel_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Tunnel_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Tunnel_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_Tunnel_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Tunnel_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Tunnel_Ipv6) GetNeighbor(Ip string) *Interface_Tunnel_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Tunnel_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Tunnel_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Tunnel_Ipv6_Neighbor struct to the
// list Neighbor of Interface_Tunnel_Ipv6. If the key value(s) specified in
// the supplied Interface_Tunnel_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Tunnel_Ipv6) AppendNeighbor(v *Interface_Tunnel_Ipv6_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Tunnel_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel_Ipv6) GetOrCreateCounters() *Interface_Tunnel_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Tunnel_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel_Ipv6) GetOrCreateRouterAdvertisement() *Interface_Tunnel_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_Tunnel_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel_Ipv6) GetOrCreateUnnumbered() *Interface_Tunnel_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Tunnel_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Tunnel_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel_Ipv6) GetCounters() *Interface_Tunnel_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_Tunnel_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel_Ipv6) GetRouterAdvertisement() *Interface_Tunnel_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Tunnel_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel_Ipv6) GetUnnumbered() *Interface_Tunnel_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_Tunnel_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetDupAddrDetectTransmits retrieves the value of the leaf DupAddrDetectTransmits from the Interface_Tunnel_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DupAddrDetectTransmits is set, it can
// safely use t.GetDupAddrDetectTransmits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DupAddrDetectTransmits == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6) GetDupAddrDetectTransmits() uint32 {
	if t == nil || t.DupAddrDetectTransmits == nil {
		return 1
	}
	return *t.DupAddrDetectTransmits
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Tunnel_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_Tunnel_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv6.
func (*Interface_Tunnel_Ipv6) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv6_Address represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv6/addresses/address YANG schema element.
type Interface_Tunnel_Ipv6_Address struct {
	Ip           *string                `path:"config/ip|ip" module:"openconfig-if-tunnel/openconfig-if-tunnel|openconfig-if-tunnel" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel|openconfig-if-tunnel"`
	Origin       E_IfIp_IpAddressOrigin `path:"state/origin" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	PrefixLength *uint8                 `path:"config/prefix-length" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/prefix-length" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Status       E_IfIp_Address_Status  `path:"state/status" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv6_Address) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Tunnel_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Tunnel_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_Tunnel_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetStatus retrieves the value of the leaf Status from the Interface_Tunnel_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Status is set, it can
// safely use t.GetStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Status == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Address) GetStatus() E_IfIp_Address_Status {
	if t == nil || t.Status == 0 {
		return 0
	}
	return t.Status
}

// ΛListKeyMap returns the keys of the Interface_Tunnel_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_Tunnel_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv6_Address.
func (*Interface_Tunnel_Ipv6_Address) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv6_Counters represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv6/state/counters YANG schema element.
type Interface_Tunnel_Ipv6_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-tunnel"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-tunnel"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-tunnel"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-tunnel"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-tunnel"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-tunnel"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-tunnel"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-tunnel"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-tunnel"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-tunnel"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-tunnel"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv6_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Tunnel_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv6_Counters.
func (*Interface_Tunnel_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv6_Neighbor represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv6/neighbors/neighbor YANG schema element.
type Interface_Tunnel_Ipv6_Neighbor struct {
	Ip               *string                       `path:"config/ip|ip" module:"openconfig-if-tunnel/openconfig-if-tunnel|openconfig-if-tunnel" shadow-path:"state/ip|ip" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel|openconfig-if-tunnel"`
	IsRouter         *bool                         `path:"state/is-router" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	LinkLayerAddress *string                       `path:"config/link-layer-address" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/link-layer-address" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	NeighborState    E_IfIp_Neighbor_NeighborState `path:"state/neighbor-state" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Origin           E_IfIp_NeighborOrigin         `path:"state/origin" module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv6_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv6_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Tunnel_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetIsRouter retrieves the value of the leaf IsRouter from the Interface_Tunnel_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsRouter is set, it can
// safely use t.GetIsRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsRouter == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Neighbor) GetIsRouter() bool {
	if t == nil || t.IsRouter == nil {
		return false
	}
	return *t.IsRouter
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Tunnel_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetNeighborState retrieves the value of the leaf NeighborState from the Interface_Tunnel_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborState is set, it can
// safely use t.GetNeighborState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborState == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Neighbor) GetNeighborState() E_IfIp_Neighbor_NeighborState {
	if t == nil || t.NeighborState == 0 {
		return 0
	}
	return t.NeighborState
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Tunnel_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// ΛListKeyMap returns the keys of the Interface_Tunnel_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_Tunnel_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv6_Neighbor.
func (*Interface_Tunnel_Ipv6_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv6_RouterAdvertisement represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv6/router-advertisement YANG schema element.
type Interface_Tunnel_Ipv6_RouterAdvertisement struct {
	Interval *uint32 `path:"config/interval" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/interval" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Lifetime *uint32 `path:"config/lifetime" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/lifetime" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Suppress *bool   `path:"config/suppress" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/suppress" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// GetInterval retrieves the value of the leaf Interval from the Interface_Tunnel_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_RouterAdvertisement) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetLifetime retrieves the value of the leaf Lifetime from the Interface_Tunnel_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lifetime is set, it can
// safely use t.GetLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lifetime == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_RouterAdvertisement) GetLifetime() uint32 {
	if t == nil || t.Lifetime == nil {
		return 0
	}
	return *t.Lifetime
}

// GetSuppress retrieves the value of the leaf Suppress from the Interface_Tunnel_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Suppress is set, it can
// safely use t.GetSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Suppress == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_RouterAdvertisement) GetSuppress() bool {
	if t == nil || t.Suppress == nil {
		return false
	}
	return *t.Suppress
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv6_RouterAdvertisement.
func (*Interface_Tunnel_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv6_Unnumbered represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv6/unnumbered YANG schema element.
type Interface_Tunnel_Ipv6_Unnumbered struct {
	Enabled      *bool                                          `path:"config/enabled" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/enabled" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	InterfaceRef *Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv6_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv6_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Tunnel_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Tunnel_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Tunnel_Ipv6_Unnumbered) GetInterfaceRef() *Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Tunnel_Ipv6_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv6_Unnumbered.
func (*Interface_Tunnel_Ipv6_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/tunnel/ipv6/unnumbered/interface-ref YANG schema element.
type Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/interface" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-if-tunnel/openconfig-if-tunnel" shadow-path:"state/subinterface" shadow-module:"openconfig-if-tunnel/openconfig-if-tunnel"`
}

// IsYANGGoStruct ensures that Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef.
func (*Interface_Tunnel_Ipv6_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-tunnel"
}

// Keychain represents the /openconfig-keychain/keychains/keychain YANG schema element.
type Keychain struct {
	Key       map[uint64]*Keychain_Key `path:"keys/key" module:"openconfig-keychain/openconfig-keychain"`
	Name      *string                  `path:"config/name|name" module:"openconfig-keychain/openconfig-keychain|openconfig-keychain" shadow-path:"state/name|name" shadow-module:"openconfig-keychain/openconfig-keychain|openconfig-keychain"`
	Tolerance Keychain_Tolerance_Union `path:"config/tolerance" module:"openconfig-keychain/openconfig-keychain" shadow-path:"state/tolerance" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain) IsYANGGoStruct() {}

// NewKey creates a new entry in the Key list of the
// Keychain struct. The keys of the list are populated from the input
// arguments.
func (t *Keychain) NewKey(KeyId uint64) (*Keychain_Key, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[uint64]*Keychain_Key)
	}

	key := KeyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Key[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Key", key)
	}

	t.Key[key] = &Keychain_Key{
		KeyId: &KeyId,
	}

	return t.Key[key], nil
}

// RenameKey renames an entry in the list Key within
// the Keychain struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Keychain) RenameKey(oldK, newK uint64) error {
	if _, ok := t.Key[newK]; ok {
		return fmt.Errorf("key %v already exists in Key", newK)
	}

	e, ok := t.Key[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Key", oldK)
	}
	e.KeyId = &newK

	t.Key[newK] = e
	delete(t.Key, oldK)
	return nil
}

// GetOrCreateKey retrieves the value with the specified keys from
// the receiver Keychain. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Keychain) GetOrCreateKey(KeyId uint64) *Keychain_Key {

	key := KeyId

	if v, ok := t.Key[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewKey(KeyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateKey got unexpected error: %v", err))
	}
	return v
}

// GetKey retrieves the value with the specified key from
// the Key map field of Keychain. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Keychain) GetKey(KeyId uint64) *Keychain_Key {

	if t == nil {
		return nil
	}

	key := KeyId

	if lm, ok := t.Key[key]; ok {
		return lm
	}
	return nil
}

// DeleteKey deletes the value with the specified keys from
// the receiver Keychain. If there is no such element, the function
// is a no-op.
func (t *Keychain) DeleteKey(KeyId uint64) {
	key := KeyId

	delete(t.Key, key)
}

// AppendKey appends the supplied Keychain_Key struct to the
// list Key of Keychain. If the key value(s) specified in
// the supplied Keychain_Key already exist in the list, an error is
// returned.
func (t *Keychain) AppendKey(v *Keychain_Key) error {
	if v.KeyId == nil {
		return fmt.Errorf("invalid nil key received for KeyId")
	}

	key := *v.KeyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[uint64]*Keychain_Key)
	}

	if _, ok := t.Key[key]; ok {
		return fmt.Errorf("duplicate key for list Key %v", key)
	}

	t.Key[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Keychain) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTolerance retrieves the value of the leaf Tolerance from the Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tolerance is set, it can
// safely use t.GetTolerance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tolerance == nil' before retrieving the leaf's value.
func (t *Keychain) GetTolerance() Keychain_Tolerance_Union {
	if t == nil || t.Tolerance == nil {
		return nil
	}
	return t.Tolerance
}

// ΛListKeyMap returns the keys of the Keychain struct, which is a YANG list entry.
func (t *Keychain) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain.
func (*Keychain) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key represents the /openconfig-keychain/keychains/keychain/keys/key YANG schema element.
type Keychain_Key struct {
	CryptoAlgorithm E_KeychainTypes_CRYPTO_TYPE   `path:"config/crypto-algorithm" module:"openconfig-keychain/openconfig-keychain" shadow-path:"state/crypto-algorithm" shadow-module:"openconfig-keychain/openconfig-keychain"`
	KeyId           *uint64                       `path:"config/key-id|key-id" module:"openconfig-keychain/openconfig-keychain|openconfig-keychain" shadow-path:"state/key-id|key-id" shadow-module:"openconfig-keychain/openconfig-keychain|openconfig-keychain"`
	ReceiveLifetime *Keychain_Key_ReceiveLifetime `path:"receive-lifetime" module:"openconfig-keychain"`
	SecretKey       *string                       `path:"config/secret-key" module:"openconfig-keychain/openconfig-keychain" shadow-path:"state/secret-key" shadow-module:"openconfig-keychain/openconfig-keychain"`
	SendLifetime    *Keychain_Key_SendLifetime    `path:"send-lifetime" module:"openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key) IsYANGGoStruct() {}

// GetOrCreateReceiveLifetime retrieves the value of the ReceiveLifetime field
// or returns the existing field if it already exists.
func (t *Keychain_Key) GetOrCreateReceiveLifetime() *Keychain_Key_ReceiveLifetime {
	if t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	t.ReceiveLifetime = &Keychain_Key_ReceiveLifetime{}
	return t.ReceiveLifetime
}

// GetOrCreateSendLifetime retrieves the value of the SendLifetime field
// or returns the existing field if it already exists.
func (t *Keychain_Key) GetOrCreateSendLifetime() *Keychain_Key_SendLifetime {
	if t.SendLifetime != nil {
		return t.SendLifetime
	}
	t.SendLifetime = &Keychain_Key_SendLifetime{}
	return t.SendLifetime
}

// GetReceiveLifetime returns the value of the ReceiveLifetime struct pointer
// from Keychain_Key. If the receiver or the field ReceiveLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Keychain_Key) GetReceiveLifetime() *Keychain_Key_ReceiveLifetime {
	if t != nil && t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	return nil
}

// GetSendLifetime returns the value of the SendLifetime struct pointer
// from Keychain_Key. If the receiver or the field SendLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Keychain_Key) GetSendLifetime() *Keychain_Key_SendLifetime {
	if t != nil && t.SendLifetime != nil {
		return t.SendLifetime
	}
	return nil
}

// GetCryptoAlgorithm retrieves the value of the leaf CryptoAlgorithm from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CryptoAlgorithm is set, it can
// safely use t.GetCryptoAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CryptoAlgorithm == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetCryptoAlgorithm() E_KeychainTypes_CRYPTO_TYPE {
	if t == nil || t.CryptoAlgorithm == 0 {
		return 0
	}
	return t.CryptoAlgorithm
}

// GetKeyId retrieves the value of the leaf KeyId from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyId is set, it can
// safely use t.GetKeyId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyId == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetKeyId() uint64 {
	if t == nil || t.KeyId == nil {
		return 0
	}
	return *t.KeyId
}

// GetSecretKey retrieves the value of the leaf SecretKey from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecretKey is set, it can
// safely use t.GetSecretKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecretKey == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetSecretKey() string {
	if t == nil || t.SecretKey == nil {
		return ""
	}
	return *t.SecretKey
}

// ΛListKeyMap returns the keys of the Keychain_Key struct, which is a YANG list entry.
func (t *Keychain_Key) ΛListKeyMap() (map[string]interface{}, error) {
	if t.KeyId == nil {
		return nil, fmt.Errorf("nil value for key KeyId")
	}

	return map[string]interface{}{
		"key-id": *t.KeyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key.
func (*Keychain_Key) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key_ReceiveLifetime represents the /openconfig-keychain/keychains/keychain/keys/key/receive-lifetime YANG schema element.
type Keychain_Key_ReceiveLifetime struct {
	EndTime   *uint64 `path:"config/end-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"state/end-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
	StartTime *uint64 `path:"config/start-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"state/start-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key_ReceiveLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key_ReceiveLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_ReceiveLifetime) GetEndTime() uint64 {
	if t == nil || t.EndTime == nil {
		return 0
	}
	return *t.EndTime
}

// GetStartTime retrieves the value of the leaf StartTime from the Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_ReceiveLifetime) GetStartTime() uint64 {
	if t == nil || t.StartTime == nil {
		return 0
	}
	return *t.StartTime
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_ReceiveLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key_ReceiveLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_ReceiveLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key_ReceiveLifetime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key_ReceiveLifetime.
func (*Keychain_Key_ReceiveLifetime) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key_SendLifetime represents the /openconfig-keychain/keychains/keychain/keys/key/send-lifetime YANG schema element.
type Keychain_Key_SendLifetime struct {
	EndTime        *uint64 `path:"config/end-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"state/end-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
	SendAndReceive *bool   `path:"config/send-and-receive" module:"openconfig-keychain/openconfig-keychain" shadow-path:"state/send-and-receive" shadow-module:"openconfig-keychain/openconfig-keychain"`
	StartTime      *uint64 `path:"config/start-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"state/start-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key_SendLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key_SendLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetEndTime() uint64 {
	if t == nil || t.EndTime == nil {
		return 0
	}
	return *t.EndTime
}

// GetSendAndReceive retrieves the value of the leaf SendAndReceive from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendAndReceive is set, it can
// safely use t.GetSendAndReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendAndReceive == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetSendAndReceive() bool {
	if t == nil || t.SendAndReceive == nil {
		return true
	}
	return *t.SendAndReceive
}

// GetStartTime retrieves the value of the leaf StartTime from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetStartTime() uint64 {
	if t == nil || t.StartTime == nil {
		return 0
	}
	return *t.StartTime
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_SendLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key_SendLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_SendLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key_SendLifetime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key_SendLifetime.
func (*Keychain_Key_SendLifetime) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Lacp represents the /openconfig-lacp/lacp YANG schema element.
type Lacp struct {
	Interface      map[string]*Lacp_Interface `path:"interfaces/interface" module:"openconfig-lacp/openconfig-lacp"`
	SystemPriority *uint16                    `path:"config/system-priority" module:"openconfig-lacp/openconfig-lacp" shadow-path:"state/system-priority" shadow-module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Lacp struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp) NewInterface(Name string) (*Lacp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lacp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lacp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lacp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp) GetOrCreateInterface(Name string) *Lacp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lacp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp) GetInterface(Name string) *Lacp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lacp. If there is no such element, the function
// is a no-op.
func (t *Lacp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lacp_Interface struct to the
// list Interface of Lacp. If the key value(s) specified in
// the supplied Lacp_Interface already exist in the list, an error is
// returned.
func (t *Lacp) AppendInterface(v *Lacp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *Lacp) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp.
func (*Lacp) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface represents the /openconfig-lacp/lacp/interfaces/interface YANG schema element.
type Lacp_Interface struct {
	Interval       E_Lacp_LacpPeriodType             `path:"config/interval" module:"openconfig-lacp/openconfig-lacp" shadow-path:"state/interval" shadow-module:"openconfig-lacp/openconfig-lacp"`
	LacpMode       E_Lacp_LacpActivityType           `path:"config/lacp-mode" module:"openconfig-lacp/openconfig-lacp" shadow-path:"state/lacp-mode" shadow-module:"openconfig-lacp/openconfig-lacp"`
	Member         map[string]*Lacp_Interface_Member `path:"members/member" module:"openconfig-lacp/openconfig-lacp"`
	Name           *string                           `path:"config/name|name" module:"openconfig-lacp/openconfig-lacp|openconfig-lacp" shadow-path:"state/name|name" shadow-module:"openconfig-lacp/openconfig-lacp|openconfig-lacp"`
	SystemIdMac    *string                           `path:"config/system-id-mac" module:"openconfig-lacp/openconfig-lacp" shadow-path:"state/system-id-mac" shadow-module:"openconfig-lacp/openconfig-lacp"`
	SystemPriority *uint16                           `path:"config/system-priority" module:"openconfig-lacp/openconfig-lacp" shadow-path:"state/system-priority" shadow-module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface) IsYANGGoStruct() {}

// NewMember creates a new entry in the Member list of the
// Lacp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp_Interface) NewMember(Interface string) (*Lacp_Interface_Member, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Member[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Member", key)
	}

	t.Member[key] = &Lacp_Interface_Member{
		Interface: &Interface,
	}

	return t.Member[key], nil
}

// RenameMember renames an entry in the list Member within
// the Lacp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp_Interface) RenameMember(oldK, newK string) error {
	if _, ok := t.Member[newK]; ok {
		return fmt.Errorf("key %v already exists in Member", newK)
	}

	e, ok := t.Member[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Member", oldK)
	}
	e.Interface = &newK

	t.Member[newK] = e
	delete(t.Member, oldK)
	return nil
}

// GetOrCreateMember retrieves the value with the specified keys from
// the receiver Lacp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp_Interface) GetOrCreateMember(Interface string) *Lacp_Interface_Member {

	key := Interface

	if v, ok := t.Member[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMember(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMember got unexpected error: %v", err))
	}
	return v
}

// GetMember retrieves the value with the specified key from
// the Member map field of Lacp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp_Interface) GetMember(Interface string) *Lacp_Interface_Member {

	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.Member[key]; ok {
		return lm
	}
	return nil
}

// DeleteMember deletes the value with the specified keys from
// the receiver Lacp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lacp_Interface) DeleteMember(Interface string) {
	key := Interface

	delete(t.Member, key)
}

// AppendMember appends the supplied Lacp_Interface_Member struct to the
// list Member of Lacp_Interface. If the key value(s) specified in
// the supplied Lacp_Interface_Member already exist in the list, an error is
// returned.
func (t *Lacp_Interface) AppendMember(v *Lacp_Interface_Member) error {
	if v.Interface == nil {
		return fmt.Errorf("invalid nil key received for Interface")
	}

	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	if _, ok := t.Member[key]; ok {
		return fmt.Errorf("duplicate key for list Member %v", key)
	}

	t.Member[key] = v
	return nil
}

// GetInterval retrieves the value of the leaf Interval from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetInterval() E_Lacp_LacpPeriodType {
	if t == nil || t.Interval == 0 {
		return Lacp_LacpPeriodType_SLOW
	}
	return t.Interval
}

// GetLacpMode retrieves the value of the leaf LacpMode from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpMode is set, it can
// safely use t.GetLacpMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpMode == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetLacpMode() E_Lacp_LacpActivityType {
	if t == nil || t.LacpMode == 0 {
		return Lacp_LacpActivityType_ACTIVE
	}
	return t.LacpMode
}

// GetName retrieves the value of the leaf Name from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSystemIdMac retrieves the value of the leaf SystemIdMac from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemIdMac is set, it can
// safely use t.GetSystemIdMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemIdMac == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetSystemIdMac() string {
	if t == nil || t.SystemIdMac == nil {
		return ""
	}
	return *t.SystemIdMac
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// ΛListKeyMap returns the keys of the Lacp_Interface struct, which is a YANG list entry.
func (t *Lacp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface.
func (*Lacp_Interface) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface_Member represents the /openconfig-lacp/lacp/interfaces/interface/members/member YANG schema element.
type Lacp_Interface_Member struct {
	Activity        E_Lacp_LacpActivityType         `path:"state/activity" module:"openconfig-lacp/openconfig-lacp"`
	Aggregatable    *bool                           `path:"state/aggregatable" module:"openconfig-lacp/openconfig-lacp"`
	Collecting      *bool                           `path:"state/collecting" module:"openconfig-lacp/openconfig-lacp"`
	Counters        *Lacp_Interface_Member_Counters `path:"state/counters" module:"openconfig-lacp/openconfig-lacp"`
	Distributing    *bool                           `path:"state/distributing" module:"openconfig-lacp/openconfig-lacp"`
	Interface       *string                         `path:"state/interface|interface" module:"openconfig-lacp/openconfig-lacp|openconfig-lacp" shadow-path:"interface" shadow-module:"openconfig-lacp"`
	LastChange      *uint64                         `path:"state/last-change" module:"openconfig-lacp/openconfig-lacp"`
	OperKey         *uint16                         `path:"state/oper-key" module:"openconfig-lacp/openconfig-lacp"`
	PartnerId       *string                         `path:"state/partner-id" module:"openconfig-lacp/openconfig-lacp"`
	PartnerKey      *uint16                         `path:"state/partner-key" module:"openconfig-lacp/openconfig-lacp"`
	PartnerPortNum  *uint16                         `path:"state/partner-port-num" module:"openconfig-lacp/openconfig-lacp"`
	PortNum         *uint16                         `path:"state/port-num" module:"openconfig-lacp/openconfig-lacp"`
	Synchronization E_Lacp_LacpSynchronizationType  `path:"state/synchronization" module:"openconfig-lacp/openconfig-lacp"`
	SystemId        *string                         `path:"state/system-id" module:"openconfig-lacp/openconfig-lacp"`
	Timeout         E_Lacp_LacpTimeoutType          `path:"state/timeout" module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface_Member implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface_Member) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lacp_Interface_Member) GetOrCreateCounters() *Lacp_Interface_Member_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lacp_Interface_Member_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lacp_Interface_Member. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lacp_Interface_Member) GetCounters() *Lacp_Interface_Member_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetActivity retrieves the value of the leaf Activity from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Activity is set, it can
// safely use t.GetActivity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Activity == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetActivity() E_Lacp_LacpActivityType {
	if t == nil || t.Activity == 0 {
		return 0
	}
	return t.Activity
}

// GetAggregatable retrieves the value of the leaf Aggregatable from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Aggregatable is set, it can
// safely use t.GetAggregatable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Aggregatable == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetAggregatable() bool {
	if t == nil || t.Aggregatable == nil {
		return false
	}
	return *t.Aggregatable
}

// GetCollecting retrieves the value of the leaf Collecting from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Collecting is set, it can
// safely use t.GetCollecting() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Collecting == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetCollecting() bool {
	if t == nil || t.Collecting == nil {
		return false
	}
	return *t.Collecting
}

// GetDistributing retrieves the value of the leaf Distributing from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Distributing is set, it can
// safely use t.GetDistributing() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Distributing == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetDistributing() bool {
	if t == nil || t.Distributing == nil {
		return false
	}
	return *t.Distributing
}

// GetInterface retrieves the value of the leaf Interface from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLastChange retrieves the value of the leaf LastChange from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetOperKey retrieves the value of the leaf OperKey from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperKey is set, it can
// safely use t.GetOperKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperKey == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetOperKey() uint16 {
	if t == nil || t.OperKey == nil {
		return 0
	}
	return *t.OperKey
}

// GetPartnerId retrieves the value of the leaf PartnerId from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerId is set, it can
// safely use t.GetPartnerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerId == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerId() string {
	if t == nil || t.PartnerId == nil {
		return ""
	}
	return *t.PartnerId
}

// GetPartnerKey retrieves the value of the leaf PartnerKey from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerKey is set, it can
// safely use t.GetPartnerKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerKey == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerKey() uint16 {
	if t == nil || t.PartnerKey == nil {
		return 0
	}
	return *t.PartnerKey
}

// GetPartnerPortNum retrieves the value of the leaf PartnerPortNum from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerPortNum is set, it can
// safely use t.GetPartnerPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerPortNum == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerPortNum() uint16 {
	if t == nil || t.PartnerPortNum == nil {
		return 0
	}
	return *t.PartnerPortNum
}

// GetPortNum retrieves the value of the leaf PortNum from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortNum is set, it can
// safely use t.GetPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortNum == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPortNum() uint16 {
	if t == nil || t.PortNum == nil {
		return 0
	}
	return *t.PortNum
}

// GetSynchronization retrieves the value of the leaf Synchronization from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Synchronization is set, it can
// safely use t.GetSynchronization() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Synchronization == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetSynchronization() E_Lacp_LacpSynchronizationType {
	if t == nil || t.Synchronization == 0 {
		return 0
	}
	return t.Synchronization
}

// GetSystemId retrieves the value of the leaf SystemId from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// GetTimeout retrieves the value of the leaf Timeout from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetTimeout() E_Lacp_LacpTimeoutType {
	if t == nil || t.Timeout == 0 {
		return 0
	}
	return t.Timeout
}

// ΛListKeyMap returns the keys of the Lacp_Interface_Member struct, which is a YANG list entry.
func (t *Lacp_Interface_Member) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface_Member.
func (*Lacp_Interface_Member) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface_Member_Counters represents the /openconfig-lacp/lacp/interfaces/interface/members/member/state/counters YANG schema element.
type Lacp_Interface_Member_Counters struct {
	LacpErrors             *uint64 `path:"lacp-errors" module:"openconfig-lacp"`
	LacpInPkts             *uint64 `path:"lacp-in-pkts" module:"openconfig-lacp"`
	LacpOutPkts            *uint64 `path:"lacp-out-pkts" module:"openconfig-lacp"`
	LacpRxErrors           *uint64 `path:"lacp-rx-errors" module:"openconfig-lacp"`
	LacpTimeoutTransitions *uint64 `path:"lacp-timeout-transitions" module:"openconfig-lacp"`
	LacpTxErrors           *uint64 `path:"lacp-tx-errors" module:"openconfig-lacp"`
	LacpUnknownErrors      *uint64 `path:"lacp-unknown-errors" module:"openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface_Member_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface_Member_Counters) IsYANGGoStruct() {}

// GetLacpErrors retrieves the value of the leaf LacpErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpErrors is set, it can
// safely use t.GetLacpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpErrors() uint64 {
	if t == nil || t.LacpErrors == nil {
		return 0
	}
	return *t.LacpErrors
}

// GetLacpInPkts retrieves the value of the leaf LacpInPkts from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpInPkts is set, it can
// safely use t.GetLacpInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpInPkts == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpInPkts() uint64 {
	if t == nil || t.LacpInPkts == nil {
		return 0
	}
	return *t.LacpInPkts
}

// GetLacpOutPkts retrieves the value of the leaf LacpOutPkts from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpOutPkts is set, it can
// safely use t.GetLacpOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpOutPkts == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpOutPkts() uint64 {
	if t == nil || t.LacpOutPkts == nil {
		return 0
	}
	return *t.LacpOutPkts
}

// GetLacpRxErrors retrieves the value of the leaf LacpRxErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpRxErrors is set, it can
// safely use t.GetLacpRxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpRxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpRxErrors() uint64 {
	if t == nil || t.LacpRxErrors == nil {
		return 0
	}
	return *t.LacpRxErrors
}

// GetLacpTimeoutTransitions retrieves the value of the leaf LacpTimeoutTransitions from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpTimeoutTransitions is set, it can
// safely use t.GetLacpTimeoutTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpTimeoutTransitions == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpTimeoutTransitions() uint64 {
	if t == nil || t.LacpTimeoutTransitions == nil {
		return 0
	}
	return *t.LacpTimeoutTransitions
}

// GetLacpTxErrors retrieves the value of the leaf LacpTxErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpTxErrors is set, it can
// safely use t.GetLacpTxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpTxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpTxErrors() uint64 {
	if t == nil || t.LacpTxErrors == nil {
		return 0
	}
	return *t.LacpTxErrors
}

// GetLacpUnknownErrors retrieves the value of the leaf LacpUnknownErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpUnknownErrors is set, it can
// safely use t.GetLacpUnknownErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpUnknownErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpUnknownErrors() uint64 {
	if t == nil || t.LacpUnknownErrors == nil {
		return 0
	}
	return *t.LacpUnknownErrors
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface_Member_Counters.
func (*Lacp_Interface_Member_Counters) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lldp represents the /openconfig-lldp/lldp YANG schema element.
type Lldp struct {
	ChassisId                *string                    `path:"config/chassis-id" module:"openconfig-lldp/openconfig-lldp" shadow-path:"state/chassis-id" shadow-module:"openconfig-lldp/openconfig-lldp"`
	ChassisIdType            E_LldpTypes_ChassisIdType  `path:"config/chassis-id-type" module:"openconfig-lldp/openconfig-lldp" shadow-path:"state/chassis-id-type" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Counters                 *Lldp_Counters             `path:"state/counters" module:"openconfig-lldp/openconfig-lldp"`
	Enabled                  *bool                      `path:"config/enabled" module:"openconfig-lldp/openconfig-lldp" shadow-path:"state/enabled" shadow-module:"openconfig-lldp/openconfig-lldp"`
	HelloTimer               *uint64                    `path:"config/hello-timer" module:"openconfig-lldp/openconfig-lldp" shadow-path:"state/hello-timer" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Interface                map[string]*Lldp_Interface `path:"interfaces/interface" module:"openconfig-lldp/openconfig-lldp"`
	SuppressTlvAdvertisement []E_LldpTypes_LLDP_TLV     `path:"config/suppress-tlv-advertisement" module:"openconfig-lldp/openconfig-lldp" shadow-path:"state/suppress-tlv-advertisement" shadow-module:"openconfig-lldp/openconfig-lldp"`
	SystemDescription        *string                    `path:"config/system-description" module:"openconfig-lldp/openconfig-lldp" shadow-path:"state/system-description" shadow-module:"openconfig-lldp/openconfig-lldp"`
	SystemName               *string                    `path:"config/system-name" module:"openconfig-lldp/openconfig-lldp" shadow-path:"state/system-name" shadow-module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp) NewInterface(Name string) (*Lldp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp) GetOrCreateInterface(Name string) *Lldp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp) GetInterface(Name string) *Lldp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lldp. If there is no such element, the function
// is a no-op.
func (t *Lldp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lldp_Interface struct to the
// list Interface of Lldp. If the key value(s) specified in
// the supplied Lldp_Interface already exist in the list, an error is
// returned.
func (t *Lldp) AppendInterface(v *Lldp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp) GetOrCreateCounters() *Lldp_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp) GetCounters() *Lldp_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetChassisId retrieves the value of the leaf ChassisId from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisId is set, it can
// safely use t.GetChassisId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisId == nil' before retrieving the leaf's value.
func (t *Lldp) GetChassisId() string {
	if t == nil || t.ChassisId == nil {
		return ""
	}
	return *t.ChassisId
}

// GetChassisIdType retrieves the value of the leaf ChassisIdType from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisIdType is set, it can
// safely use t.GetChassisIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisIdType == nil' before retrieving the leaf's value.
func (t *Lldp) GetChassisIdType() E_LldpTypes_ChassisIdType {
	if t == nil || t.ChassisIdType == 0 {
		return 0
	}
	return t.ChassisIdType
}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetHelloTimer retrieves the value of the leaf HelloTimer from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloTimer is set, it can
// safely use t.GetHelloTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloTimer == nil' before retrieving the leaf's value.
func (t *Lldp) GetHelloTimer() uint64 {
	if t == nil || t.HelloTimer == nil {
		return 0
	}
	return *t.HelloTimer
}

// GetSuppressTlvAdvertisement retrieves the value of the leaf SuppressTlvAdvertisement from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressTlvAdvertisement is set, it can
// safely use t.GetSuppressTlvAdvertisement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressTlvAdvertisement == nil' before retrieving the leaf's value.
func (t *Lldp) GetSuppressTlvAdvertisement() []E_LldpTypes_LLDP_TLV {
	if t == nil || t.SuppressTlvAdvertisement == nil {
		return nil
	}
	return t.SuppressTlvAdvertisement
}

// GetSystemDescription retrieves the value of the leaf SystemDescription from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemDescription is set, it can
// safely use t.GetSystemDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemDescription == nil' before retrieving the leaf's value.
func (t *Lldp) GetSystemDescription() string {
	if t == nil || t.SystemDescription == nil {
		return ""
	}
	return *t.SystemDescription
}

// GetSystemName retrieves the value of the leaf SystemName from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemName is set, it can
// safely use t.GetSystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemName == nil' before retrieving the leaf's value.
func (t *Lldp) GetSystemName() string {
	if t == nil || t.SystemName == nil {
		return ""
	}
	return *t.SystemName
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp.
func (*Lldp) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Counters represents the /openconfig-lldp/lldp/state/counters YANG schema element.
type Lldp_Counters struct {
	EntriesAgedOut *uint64 `path:"entries-aged-out" module:"openconfig-lldp"`
	FrameDiscard   *uint64 `path:"frame-discard" module:"openconfig-lldp"`
	FrameErrorIn   *uint64 `path:"frame-error-in" module:"openconfig-lldp"`
	FrameIn        *uint64 `path:"frame-in" module:"openconfig-lldp"`
	FrameOut       *uint64 `path:"frame-out" module:"openconfig-lldp"`
	LastClear      *string `path:"last-clear" module:"openconfig-lldp"`
	TlvAccepted    *uint64 `path:"tlv-accepted" module:"openconfig-lldp"`
	TlvDiscard     *uint64 `path:"tlv-discard" module:"openconfig-lldp"`
	TlvUnknown     *uint64 `path:"tlv-unknown" module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Counters) IsYANGGoStruct() {}

// GetEntriesAgedOut retrieves the value of the leaf EntriesAgedOut from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntriesAgedOut is set, it can
// safely use t.GetEntriesAgedOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntriesAgedOut == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetEntriesAgedOut() uint64 {
	if t == nil || t.EntriesAgedOut == nil {
		return 0
	}
	return *t.EntriesAgedOut
}

// GetFrameDiscard retrieves the value of the leaf FrameDiscard from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameDiscard is set, it can
// safely use t.GetFrameDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameDiscard() uint64 {
	if t == nil || t.FrameDiscard == nil {
		return 0
	}
	return *t.FrameDiscard
}

// GetFrameErrorIn retrieves the value of the leaf FrameErrorIn from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorIn is set, it can
// safely use t.GetFrameErrorIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorIn == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameErrorIn() uint64 {
	if t == nil || t.FrameErrorIn == nil {
		return 0
	}
	return *t.FrameErrorIn
}

// GetFrameIn retrieves the value of the leaf FrameIn from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameIn is set, it can
// safely use t.GetFrameIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameIn == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameIn() uint64 {
	if t == nil || t.FrameIn == nil {
		return 0
	}
	return *t.FrameIn
}

// GetFrameOut retrieves the value of the leaf FrameOut from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameOut is set, it can
// safely use t.GetFrameOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameOut == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameOut() uint64 {
	if t == nil || t.FrameOut == nil {
		return 0
	}
	return *t.FrameOut
}

// GetLastClear retrieves the value of the leaf LastClear from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetLastClear() string {
	if t == nil || t.LastClear == nil {
		return ""
	}
	return *t.LastClear
}

// GetTlvAccepted retrieves the value of the leaf TlvAccepted from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvAccepted is set, it can
// safely use t.GetTlvAccepted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvAccepted == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvAccepted() uint64 {
	if t == nil || t.TlvAccepted == nil {
		return 0
	}
	return *t.TlvAccepted
}

// GetTlvDiscard retrieves the value of the leaf TlvDiscard from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvDiscard is set, it can
// safely use t.GetTlvDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvDiscard() uint64 {
	if t == nil || t.TlvDiscard == nil {
		return 0
	}
	return *t.TlvDiscard
}

// GetTlvUnknown retrieves the value of the leaf TlvUnknown from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvUnknown is set, it can
// safely use t.GetTlvUnknown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvUnknown == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvUnknown() uint64 {
	if t == nil || t.TlvUnknown == nil {
		return 0
	}
	return *t.TlvUnknown
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Counters.
func (*Lldp_Counters) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface represents the /openconfig-lldp/lldp/interfaces/interface YANG schema element.
type Lldp_Interface struct {
	Counters *Lldp_Interface_Counters            `path:"state/counters" module:"openconfig-lldp/openconfig-lldp"`
	Enabled  *bool                               `path:"config/enabled" module:"openconfig-lldp/openconfig-lldp" shadow-path:"state/enabled" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Name     *string                             `path:"config/name|name" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"state/name|name" shadow-module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	Neighbor map[string]*Lldp_Interface_Neighbor `path:"neighbors/neighbor" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// Lldp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface) NewNeighbor(Id string) (*Lldp_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Lldp_Interface_Neighbor{
		Id: &Id,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Lldp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Id = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Lldp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface) GetOrCreateNeighbor(Id string) *Lldp_Interface_Neighbor {

	key := Id

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Lldp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface) GetNeighbor(Id string) *Lldp_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Lldp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface) DeleteNeighbor(Id string) {
	key := Id

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Lldp_Interface_Neighbor struct to the
// list Neighbor of Lldp_Interface. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *Lldp_Interface) AppendNeighbor(v *Lldp_Interface_Neighbor) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp_Interface) GetOrCreateCounters() *Lldp_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Interface_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp_Interface) GetCounters() *Lldp_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp_Interface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetName retrieves the value of the leaf Name from the Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lldp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the Lldp_Interface struct, which is a YANG list entry.
func (t *Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface.
func (*Lldp_Interface) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Counters represents the /openconfig-lldp/lldp/interfaces/interface/state/counters YANG schema element.
type Lldp_Interface_Counters struct {
	FrameDiscard  *uint64 `path:"frame-discard" module:"openconfig-lldp"`
	FrameErrorIn  *uint64 `path:"frame-error-in" module:"openconfig-lldp"`
	FrameErrorOut *uint64 `path:"frame-error-out" module:"openconfig-lldp"`
	FrameIn       *uint64 `path:"frame-in" module:"openconfig-lldp"`
	FrameOut      *uint64 `path:"frame-out" module:"openconfig-lldp"`
	LastClear     *string `path:"last-clear" module:"openconfig-lldp"`
	TlvDiscard    *uint64 `path:"tlv-discard" module:"openconfig-lldp"`
	TlvUnknown    *uint64 `path:"tlv-unknown" module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Counters) IsYANGGoStruct() {}

// GetFrameDiscard retrieves the value of the leaf FrameDiscard from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameDiscard is set, it can
// safely use t.GetFrameDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameDiscard() uint64 {
	if t == nil || t.FrameDiscard == nil {
		return 0
	}
	return *t.FrameDiscard
}

// GetFrameErrorIn retrieves the value of the leaf FrameErrorIn from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorIn is set, it can
// safely use t.GetFrameErrorIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorIn == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameErrorIn() uint64 {
	if t == nil || t.FrameErrorIn == nil {
		return 0
	}
	return *t.FrameErrorIn
}

// GetFrameErrorOut retrieves the value of the leaf FrameErrorOut from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorOut is set, it can
// safely use t.GetFrameErrorOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorOut == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameErrorOut() uint64 {
	if t == nil || t.FrameErrorOut == nil {
		return 0
	}
	return *t.FrameErrorOut
}

// GetFrameIn retrieves the value of the leaf FrameIn from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameIn is set, it can
// safely use t.GetFrameIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameIn == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameIn() uint64 {
	if t == nil || t.FrameIn == nil {
		return 0
	}
	return *t.FrameIn
}

// GetFrameOut retrieves the value of the leaf FrameOut from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameOut is set, it can
// safely use t.GetFrameOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameOut == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameOut() uint64 {
	if t == nil || t.FrameOut == nil {
		return 0
	}
	return *t.FrameOut
}

// GetLastClear retrieves the value of the leaf LastClear from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetLastClear() string {
	if t == nil || t.LastClear == nil {
		return ""
	}
	return *t.LastClear
}

// GetTlvDiscard retrieves the value of the leaf TlvDiscard from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvDiscard is set, it can
// safely use t.GetTlvDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetTlvDiscard() uint64 {
	if t == nil || t.TlvDiscard == nil {
		return 0
	}
	return *t.TlvDiscard
}

// GetTlvUnknown retrieves the value of the leaf TlvUnknown from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvUnknown is set, it can
// safely use t.GetTlvUnknown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvUnknown == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetTlvUnknown() uint64 {
	if t == nil || t.TlvUnknown == nil {
		return 0
	}
	return *t.TlvUnknown
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Counters.
func (*Lldp_Interface_Counters) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor YANG schema element.
type Lldp_Interface_Neighbor struct {
	Age                   *uint64                                                                    `path:"state/age" module:"openconfig-lldp/openconfig-lldp"`
	Capability            map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability `path:"capabilities/capability" module:"openconfig-lldp/openconfig-lldp"`
	ChassisId             *string                                                                    `path:"state/chassis-id" module:"openconfig-lldp/openconfig-lldp"`
	ChassisIdType         E_LldpTypes_ChassisIdType                                                  `path:"state/chassis-id-type" module:"openconfig-lldp/openconfig-lldp"`
	Id                    *string                                                                    `path:"state/id|id" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"id" shadow-module:"openconfig-lldp"`
	LastUpdate            *int64                                                                     `path:"state/last-update" module:"openconfig-lldp/openconfig-lldp"`
	ManagementAddress     *string                                                                    `path:"state/management-address" module:"openconfig-lldp/openconfig-lldp"`
	ManagementAddressType *string                                                                    `path:"state/management-address-type" module:"openconfig-lldp/openconfig-lldp"`
	PortDescription       *string                                                                    `path:"state/port-description" module:"openconfig-lldp/openconfig-lldp"`
	PortId                *string                                                                    `path:"state/port-id" module:"openconfig-lldp/openconfig-lldp"`
	PortIdType            E_LldpTypes_PortIdType                                                     `path:"state/port-id-type" module:"openconfig-lldp/openconfig-lldp"`
	SystemDescription     *string                                                                    `path:"state/system-description" module:"openconfig-lldp/openconfig-lldp"`
	SystemName            *string                                                                    `path:"state/system-name" module:"openconfig-lldp/openconfig-lldp"`
	Tlv                   map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv           `path:"custom-tlvs/tlv" module:"openconfig-lldp/openconfig-lldp"`
	Ttl                   *uint16                                                                    `path:"state/ttl" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor) IsYANGGoStruct() {}

// Lldp_Interface_Neighbor_Tlv_Key represents the key for list Tlv of element /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor.
type Lldp_Interface_Neighbor_Tlv_Key struct {
	Type       int32  `path:"type"`
	Oui        string `path:"oui"`
	OuiSubtype string `path:"oui-subtype"`
}

// NewCapability creates a new entry in the Capability list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) (*Lldp_Interface_Neighbor_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &Lldp_Interface_Neighbor_Capability{
		Name: Name,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameCapability(oldK, newK E_LldpTypes_LLDP_SYSTEM_CAPABILITY) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.Name = newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	key := Name

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// DeleteCapability deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) {
	key := Name

	delete(t.Capability, key)
}

// AppendCapability appends the supplied Lldp_Interface_Neighbor_Capability struct to the
// list Capability of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Capability already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendCapability(v *Lldp_Interface_Neighbor_Capability) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewTlv creates a new entry in the Tlv list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewTlv(Type int32, Oui string, OuiSubtype string) (*Lldp_Interface_Neighbor_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &Lldp_Interface_Neighbor_Tlv{
		Type:       &Type,
		Oui:        &Oui,
		OuiSubtype: &OuiSubtype,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameTlv(oldK, newK Lldp_Interface_Neighbor_Tlv_Key) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = &newK.Type
	e.Oui = &newK.Oui
	e.OuiSubtype = &newK.OuiSubtype

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type, Oui, OuiSubtype)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	if t == nil {
		return nil
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteTlv deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteTlv(Type int32, Oui string, OuiSubtype string) {
	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	delete(t.Tlv, key)
}

// AppendTlv appends the supplied Lldp_Interface_Neighbor_Tlv struct to the
// list Tlv of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Tlv already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendTlv(v *Lldp_Interface_Neighbor_Tlv) error {
	if v.Type == nil {
		return fmt.Errorf("invalid nil key for Type")
	}

	if v.Oui == nil {
		return fmt.Errorf("invalid nil key for Oui")
	}

	if v.OuiSubtype == nil {
		return fmt.Errorf("invalid nil key for OuiSubtype")
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       *v.Type,
		Oui:        *v.Oui,
		OuiSubtype: *v.OuiSubtype,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// GetAge retrieves the value of the leaf Age from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Age is set, it can
// safely use t.GetAge() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Age == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetAge() uint64 {
	if t == nil || t.Age == nil {
		return 0
	}
	return *t.Age
}

// GetChassisId retrieves the value of the leaf ChassisId from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisId is set, it can
// safely use t.GetChassisId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisId == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetChassisId() string {
	if t == nil || t.ChassisId == nil {
		return ""
	}
	return *t.ChassisId
}

// GetChassisIdType retrieves the value of the leaf ChassisIdType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisIdType is set, it can
// safely use t.GetChassisIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisIdType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetChassisIdType() E_LldpTypes_ChassisIdType {
	if t == nil || t.ChassisIdType == 0 {
		return 0
	}
	return t.ChassisIdType
}

// GetId retrieves the value of the leaf Id from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetLastUpdate retrieves the value of the leaf LastUpdate from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastUpdate is set, it can
// safely use t.GetLastUpdate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastUpdate == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetLastUpdate() int64 {
	if t == nil || t.LastUpdate == nil {
		return 0
	}
	return *t.LastUpdate
}

// GetManagementAddress retrieves the value of the leaf ManagementAddress from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagementAddress is set, it can
// safely use t.GetManagementAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagementAddress == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetManagementAddress() string {
	if t == nil || t.ManagementAddress == nil {
		return ""
	}
	return *t.ManagementAddress
}

// GetManagementAddressType retrieves the value of the leaf ManagementAddressType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagementAddressType is set, it can
// safely use t.GetManagementAddressType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagementAddressType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetManagementAddressType() string {
	if t == nil || t.ManagementAddressType == nil {
		return ""
	}
	return *t.ManagementAddressType
}

// GetPortDescription retrieves the value of the leaf PortDescription from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortDescription is set, it can
// safely use t.GetPortDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortDescription == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortDescription() string {
	if t == nil || t.PortDescription == nil {
		return ""
	}
	return *t.PortDescription
}

// GetPortId retrieves the value of the leaf PortId from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortId is set, it can
// safely use t.GetPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortId == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortId() string {
	if t == nil || t.PortId == nil {
		return ""
	}
	return *t.PortId
}

// GetPortIdType retrieves the value of the leaf PortIdType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortIdType is set, it can
// safely use t.GetPortIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortIdType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortIdType() E_LldpTypes_PortIdType {
	if t == nil || t.PortIdType == 0 {
		return 0
	}
	return t.PortIdType
}

// GetSystemDescription retrieves the value of the leaf SystemDescription from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemDescription is set, it can
// safely use t.GetSystemDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemDescription == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetSystemDescription() string {
	if t == nil || t.SystemDescription == nil {
		return ""
	}
	return *t.SystemDescription
}

// GetSystemName retrieves the value of the leaf SystemName from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemName is set, it can
// safely use t.GetSystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemName == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetSystemName() string {
	if t == nil || t.SystemName == nil {
		return ""
	}
	return *t.SystemName
}

// GetTtl retrieves the value of the leaf Ttl from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ttl is set, it can
// safely use t.GetTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ttl == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetTtl() uint16 {
	if t == nil || t.Ttl == nil {
		return 0
	}
	return *t.Ttl
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor.
func (*Lldp_Interface_Neighbor) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor_Capability represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor/capabilities/capability YANG schema element.
type Lldp_Interface_Neighbor_Capability struct {
	Enabled *bool                              `path:"state/enabled" module:"openconfig-lldp/openconfig-lldp"`
	Name    E_LldpTypes_LLDP_SYSTEM_CAPABILITY `path:"state/name|name" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"name" shadow-module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor_Capability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor_Capability) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp_Interface_Neighbor_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Capability) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetName retrieves the value of the leaf Name from the Lldp_Interface_Neighbor_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Capability) GetName() E_LldpTypes_LLDP_SYSTEM_CAPABILITY {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Capability struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Capability) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Capability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor_Capability.
func (*Lldp_Interface_Neighbor_Capability) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor_Tlv represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor/custom-tlvs/tlv YANG schema element.
type Lldp_Interface_Neighbor_Tlv struct {
	Oui        *string `path:"state/oui|oui" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"oui" shadow-module:"openconfig-lldp"`
	OuiSubtype *string `path:"state/oui-subtype|oui-subtype" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"oui-subtype" shadow-module:"openconfig-lldp"`
	Type       *int32  `path:"state/type|type" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"type" shadow-module:"openconfig-lldp"`
	Value      Binary  `path:"state/value" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor_Tlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor_Tlv) IsYANGGoStruct() {}

// GetOui retrieves the value of the leaf Oui from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Oui is set, it can
// safely use t.GetOui() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Oui == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetOui() string {
	if t == nil || t.Oui == nil {
		return ""
	}
	return *t.Oui
}

// GetOuiSubtype retrieves the value of the leaf OuiSubtype from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuiSubtype is set, it can
// safely use t.GetOuiSubtype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuiSubtype == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetOuiSubtype() string {
	if t == nil || t.OuiSubtype == nil {
		return ""
	}
	return *t.OuiSubtype
}

// GetType retrieves the value of the leaf Type from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetType() int32 {
	if t == nil || t.Type == nil {
		return 0
	}
	return *t.Type
}

// GetValue retrieves the value of the leaf Value from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetValue() Binary {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Tlv struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Tlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Oui == nil {
		return nil, fmt.Errorf("nil value for key Oui")
	}

	if t.OuiSubtype == nil {
		return nil, fmt.Errorf("nil value for key OuiSubtype")
	}

	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"oui":         *t.Oui,
		"oui-subtype": *t.OuiSubtype,
		"type":        *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Tlv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor_Tlv.
func (*Lldp_Interface_Neighbor_Tlv) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Macsec represents the /openconfig-macsec/macsec YANG schema element.
type Macsec struct {
	Interface map[string]*Macsec_Interface `path:"interfaces/interface" module:"openconfig-macsec/openconfig-macsec"`
	Mka       *Macsec_Mka                  `path:"mka" module:"openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Macsec struct. The keys of the list are populated from the input
// arguments.
func (t *Macsec) NewInterface(Name string) (*Macsec_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Macsec_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Macsec_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Macsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Macsec) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Macsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Macsec) GetOrCreateInterface(Name string) *Macsec_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Macsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Macsec) GetInterface(Name string) *Macsec_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Macsec. If there is no such element, the function
// is a no-op.
func (t *Macsec) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Macsec_Interface struct to the
// list Interface of Macsec. If the key value(s) specified in
// the supplied Macsec_Interface already exist in the list, an error is
// returned.
func (t *Macsec) AppendInterface(v *Macsec_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Macsec_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateMka retrieves the value of the Mka field
// or returns the existing field if it already exists.
func (t *Macsec) GetOrCreateMka() *Macsec_Mka {
	if t.Mka != nil {
		return t.Mka
	}
	t.Mka = &Macsec_Mka{}
	return t.Mka
}

// GetMka returns the value of the Mka struct pointer
// from Macsec. If the receiver or the field Mka is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec) GetMka() *Macsec_Mka {
	if t != nil && t.Mka != nil {
		return t.Mka
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec.
func (*Macsec) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface represents the /openconfig-macsec/macsec/interfaces/interface YANG schema element.
type Macsec_Interface struct {
	Counters         *Macsec_Interface_Counters          `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	Enable           *bool                               `path:"config/enable" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/enable" shadow-module:"openconfig-macsec/openconfig-macsec"`
	Mka              *Macsec_Interface_Mka               `path:"mka" module:"openconfig-macsec"`
	Name             *string                             `path:"config/name|name" module:"openconfig-macsec/openconfig-macsec|openconfig-macsec" shadow-path:"state/name|name" shadow-module:"openconfig-macsec/openconfig-macsec|openconfig-macsec"`
	ReplayProtection *uint16                             `path:"config/replay-protection" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/replay-protection" shadow-module:"openconfig-macsec/openconfig-macsec"`
	ScsaRx           map[string]*Macsec_Interface_ScsaRx `path:"scsa-rx/scsa-rx" module:"openconfig-macsec/openconfig-macsec"`
	ScsaTx           map[string]*Macsec_Interface_ScsaTx `path:"scsa-tx/scsa-tx" module:"openconfig-macsec/openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface) IsYANGGoStruct() {}

// NewScsaRx creates a new entry in the ScsaRx list of the
// Macsec_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Macsec_Interface) NewScsaRx(SciRx string) (*Macsec_Interface_ScsaRx, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ScsaRx == nil {
		t.ScsaRx = make(map[string]*Macsec_Interface_ScsaRx)
	}

	key := SciRx

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ScsaRx[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ScsaRx", key)
	}

	t.ScsaRx[key] = &Macsec_Interface_ScsaRx{
		SciRx: &SciRx,
	}

	return t.ScsaRx[key], nil
}

// RenameScsaRx renames an entry in the list ScsaRx within
// the Macsec_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Macsec_Interface) RenameScsaRx(oldK, newK string) error {
	if _, ok := t.ScsaRx[newK]; ok {
		return fmt.Errorf("key %v already exists in ScsaRx", newK)
	}

	e, ok := t.ScsaRx[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ScsaRx", oldK)
	}
	e.SciRx = &newK

	t.ScsaRx[newK] = e
	delete(t.ScsaRx, oldK)
	return nil
}

// GetOrCreateScsaRx retrieves the value with the specified keys from
// the receiver Macsec_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Macsec_Interface) GetOrCreateScsaRx(SciRx string) *Macsec_Interface_ScsaRx {

	key := SciRx

	if v, ok := t.ScsaRx[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewScsaRx(SciRx)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateScsaRx got unexpected error: %v", err))
	}
	return v
}

// GetScsaRx retrieves the value with the specified key from
// the ScsaRx map field of Macsec_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Macsec_Interface) GetScsaRx(SciRx string) *Macsec_Interface_ScsaRx {

	if t == nil {
		return nil
	}

	key := SciRx

	if lm, ok := t.ScsaRx[key]; ok {
		return lm
	}
	return nil
}

// DeleteScsaRx deletes the value with the specified keys from
// the receiver Macsec_Interface. If there is no such element, the function
// is a no-op.
func (t *Macsec_Interface) DeleteScsaRx(SciRx string) {
	key := SciRx

	delete(t.ScsaRx, key)
}

// AppendScsaRx appends the supplied Macsec_Interface_ScsaRx struct to the
// list ScsaRx of Macsec_Interface. If the key value(s) specified in
// the supplied Macsec_Interface_ScsaRx already exist in the list, an error is
// returned.
func (t *Macsec_Interface) AppendScsaRx(v *Macsec_Interface_ScsaRx) error {
	if v.SciRx == nil {
		return fmt.Errorf("invalid nil key received for SciRx")
	}

	key := *v.SciRx

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ScsaRx == nil {
		t.ScsaRx = make(map[string]*Macsec_Interface_ScsaRx)
	}

	if _, ok := t.ScsaRx[key]; ok {
		return fmt.Errorf("duplicate key for list ScsaRx %v", key)
	}

	t.ScsaRx[key] = v
	return nil
}

// NewScsaTx creates a new entry in the ScsaTx list of the
// Macsec_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Macsec_Interface) NewScsaTx(SciTx string) (*Macsec_Interface_ScsaTx, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ScsaTx == nil {
		t.ScsaTx = make(map[string]*Macsec_Interface_ScsaTx)
	}

	key := SciTx

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ScsaTx[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ScsaTx", key)
	}

	t.ScsaTx[key] = &Macsec_Interface_ScsaTx{
		SciTx: &SciTx,
	}

	return t.ScsaTx[key], nil
}

// RenameScsaTx renames an entry in the list ScsaTx within
// the Macsec_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Macsec_Interface) RenameScsaTx(oldK, newK string) error {
	if _, ok := t.ScsaTx[newK]; ok {
		return fmt.Errorf("key %v already exists in ScsaTx", newK)
	}

	e, ok := t.ScsaTx[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ScsaTx", oldK)
	}
	e.SciTx = &newK

	t.ScsaTx[newK] = e
	delete(t.ScsaTx, oldK)
	return nil
}

// GetOrCreateScsaTx retrieves the value with the specified keys from
// the receiver Macsec_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Macsec_Interface) GetOrCreateScsaTx(SciTx string) *Macsec_Interface_ScsaTx {

	key := SciTx

	if v, ok := t.ScsaTx[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewScsaTx(SciTx)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateScsaTx got unexpected error: %v", err))
	}
	return v
}

// GetScsaTx retrieves the value with the specified key from
// the ScsaTx map field of Macsec_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Macsec_Interface) GetScsaTx(SciTx string) *Macsec_Interface_ScsaTx {

	if t == nil {
		return nil
	}

	key := SciTx

	if lm, ok := t.ScsaTx[key]; ok {
		return lm
	}
	return nil
}

// DeleteScsaTx deletes the value with the specified keys from
// the receiver Macsec_Interface. If there is no such element, the function
// is a no-op.
func (t *Macsec_Interface) DeleteScsaTx(SciTx string) {
	key := SciTx

	delete(t.ScsaTx, key)
}

// AppendScsaTx appends the supplied Macsec_Interface_ScsaTx struct to the
// list ScsaTx of Macsec_Interface. If the key value(s) specified in
// the supplied Macsec_Interface_ScsaTx already exist in the list, an error is
// returned.
func (t *Macsec_Interface) AppendScsaTx(v *Macsec_Interface_ScsaTx) error {
	if v.SciTx == nil {
		return fmt.Errorf("invalid nil key received for SciTx")
	}

	key := *v.SciTx

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ScsaTx == nil {
		t.ScsaTx = make(map[string]*Macsec_Interface_ScsaTx)
	}

	if _, ok := t.ScsaTx[key]; ok {
		return fmt.Errorf("duplicate key for list ScsaTx %v", key)
	}

	t.ScsaTx[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Interface) GetOrCreateCounters() *Macsec_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Interface_Counters{}
	return t.Counters
}

// GetOrCreateMka retrieves the value of the Mka field
// or returns the existing field if it already exists.
func (t *Macsec_Interface) GetOrCreateMka() *Macsec_Interface_Mka {
	if t.Mka != nil {
		return t.Mka
	}
	t.Mka = &Macsec_Interface_Mka{}
	return t.Mka
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface) GetCounters() *Macsec_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetMka returns the value of the Mka struct pointer
// from Macsec_Interface. If the receiver or the field Mka is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface) GetMka() *Macsec_Interface_Mka {
	if t != nil && t.Mka != nil {
		return t.Mka
	}
	return nil
}

// GetEnable retrieves the value of the leaf Enable from the Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *Macsec_Interface) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetName retrieves the value of the leaf Name from the Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Macsec_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetReplayProtection retrieves the value of the leaf ReplayProtection from the Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplayProtection is set, it can
// safely use t.GetReplayProtection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplayProtection == nil' before retrieving the leaf's value.
func (t *Macsec_Interface) GetReplayProtection() uint16 {
	if t == nil || t.ReplayProtection == nil {
		return 0
	}
	return *t.ReplayProtection
}

// ΛListKeyMap returns the keys of the Macsec_Interface struct, which is a YANG list entry.
func (t *Macsec_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface.
func (*Macsec_Interface) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_Counters represents the /openconfig-macsec/macsec/interfaces/interface/state/counters YANG schema element.
type Macsec_Interface_Counters struct {
	RxBadtagPkts     *uint64 `path:"rx-badtag-pkts" module:"openconfig-macsec"`
	RxNosciPkts      *uint64 `path:"rx-nosci-pkts" module:"openconfig-macsec"`
	RxUnknownsciPkts *uint64 `path:"rx-unknownsci-pkts" module:"openconfig-macsec"`
	RxUntaggedPkts   *uint64 `path:"rx-untagged-pkts" module:"openconfig-macsec"`
	TxUntaggedPkts   *uint64 `path:"tx-untagged-pkts" module:"openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_Counters) IsYANGGoStruct() {}

// GetRxBadtagPkts retrieves the value of the leaf RxBadtagPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxBadtagPkts is set, it can
// safely use t.GetRxBadtagPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxBadtagPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxBadtagPkts() uint64 {
	if t == nil || t.RxBadtagPkts == nil {
		return 0
	}
	return *t.RxBadtagPkts
}

// GetRxNosciPkts retrieves the value of the leaf RxNosciPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxNosciPkts is set, it can
// safely use t.GetRxNosciPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxNosciPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxNosciPkts() uint64 {
	if t == nil || t.RxNosciPkts == nil {
		return 0
	}
	return *t.RxNosciPkts
}

// GetRxUnknownsciPkts retrieves the value of the leaf RxUnknownsciPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxUnknownsciPkts is set, it can
// safely use t.GetRxUnknownsciPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxUnknownsciPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxUnknownsciPkts() uint64 {
	if t == nil || t.RxUnknownsciPkts == nil {
		return 0
	}
	return *t.RxUnknownsciPkts
}

// GetRxUntaggedPkts retrieves the value of the leaf RxUntaggedPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxUntaggedPkts is set, it can
// safely use t.GetRxUntaggedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxUntaggedPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxUntaggedPkts() uint64 {
	if t == nil || t.RxUntaggedPkts == nil {
		return 0
	}
	return *t.RxUntaggedPkts
}

// GetTxUntaggedPkts retrieves the value of the leaf TxUntaggedPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TxUntaggedPkts is set, it can
// safely use t.GetTxUntaggedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TxUntaggedPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetTxUntaggedPkts() uint64 {
	if t == nil || t.TxUntaggedPkts == nil {
		return 0
	}
	return *t.TxUntaggedPkts
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_Counters.
func (*Macsec_Interface_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_Mka represents the /openconfig-macsec/macsec/interfaces/interface/mka YANG schema element.
type Macsec_Interface_Mka struct {
	Counters  *Macsec_Interface_Mka_Counters `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	KeyChain  *string                        `path:"config/key-chain" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/key-chain" shadow-module:"openconfig-macsec/openconfig-macsec"`
	MkaPolicy *string                        `path:"config/mka-policy" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/mka-policy" shadow-module:"openconfig-macsec/openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Interface_Mka implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_Mka) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Interface_Mka) GetOrCreateCounters() *Macsec_Interface_Mka_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Interface_Mka_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Interface_Mka. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface_Mka) GetCounters() *Macsec_Interface_Mka_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetKeyChain retrieves the value of the leaf KeyChain from the Macsec_Interface_Mka
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyChain is set, it can
// safely use t.GetKeyChain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyChain == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka) GetKeyChain() string {
	if t == nil || t.KeyChain == nil {
		return ""
	}
	return *t.KeyChain
}

// GetMkaPolicy retrieves the value of the leaf MkaPolicy from the Macsec_Interface_Mka
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MkaPolicy is set, it can
// safely use t.GetMkaPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MkaPolicy == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka) GetMkaPolicy() string {
	if t == nil || t.MkaPolicy == nil {
		return ""
	}
	return *t.MkaPolicy
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Mka) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_Mka"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Mka) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_Mka) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_Mka.
func (*Macsec_Interface_Mka) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_Mka_Counters represents the /openconfig-macsec/macsec/interfaces/interface/mka/state/counters YANG schema element.
type Macsec_Interface_Mka_Counters struct {
	InCakMkpdu  *uint64 `path:"in-cak-mkpdu" module:"openconfig-macsec"`
	InMkpdu     *uint64 `path:"in-mkpdu" module:"openconfig-macsec"`
	InSakMkpdu  *uint64 `path:"in-sak-mkpdu" module:"openconfig-macsec"`
	OutCakMkpdu *uint64 `path:"out-cak-mkpdu" module:"openconfig-macsec"`
	OutMkpdu    *uint64 `path:"out-mkpdu" module:"openconfig-macsec"`
	OutSakMkpdu *uint64 `path:"out-sak-mkpdu" module:"openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Interface_Mka_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_Mka_Counters) IsYANGGoStruct() {}

// GetInCakMkpdu retrieves the value of the leaf InCakMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InCakMkpdu is set, it can
// safely use t.GetInCakMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InCakMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetInCakMkpdu() uint64 {
	if t == nil || t.InCakMkpdu == nil {
		return 0
	}
	return *t.InCakMkpdu
}

// GetInMkpdu retrieves the value of the leaf InMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpdu is set, it can
// safely use t.GetInMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetInMkpdu() uint64 {
	if t == nil || t.InMkpdu == nil {
		return 0
	}
	return *t.InMkpdu
}

// GetInSakMkpdu retrieves the value of the leaf InSakMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InSakMkpdu is set, it can
// safely use t.GetInSakMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InSakMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetInSakMkpdu() uint64 {
	if t == nil || t.InSakMkpdu == nil {
		return 0
	}
	return *t.InSakMkpdu
}

// GetOutCakMkpdu retrieves the value of the leaf OutCakMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutCakMkpdu is set, it can
// safely use t.GetOutCakMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutCakMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetOutCakMkpdu() uint64 {
	if t == nil || t.OutCakMkpdu == nil {
		return 0
	}
	return *t.OutCakMkpdu
}

// GetOutMkpdu retrieves the value of the leaf OutMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMkpdu is set, it can
// safely use t.GetOutMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetOutMkpdu() uint64 {
	if t == nil || t.OutMkpdu == nil {
		return 0
	}
	return *t.OutMkpdu
}

// GetOutSakMkpdu retrieves the value of the leaf OutSakMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutSakMkpdu is set, it can
// safely use t.GetOutSakMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutSakMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetOutSakMkpdu() uint64 {
	if t == nil || t.OutSakMkpdu == nil {
		return 0
	}
	return *t.OutSakMkpdu
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Mka_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_Mka_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Mka_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_Mka_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_Mka_Counters.
func (*Macsec_Interface_Mka_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_ScsaRx represents the /openconfig-macsec/macsec/interfaces/interface/scsa-rx/scsa-rx YANG schema element.
type Macsec_Interface_ScsaRx struct {
	Counters *Macsec_Interface_ScsaRx_Counters `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	SciRx    *string                           `path:"state/sci-rx|sci-rx" module:"openconfig-macsec/openconfig-macsec|openconfig-macsec" shadow-path:"sci-rx" shadow-module:"openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Interface_ScsaRx implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_ScsaRx) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Interface_ScsaRx) GetOrCreateCounters() *Macsec_Interface_ScsaRx_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Interface_ScsaRx_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Interface_ScsaRx. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface_ScsaRx) GetCounters() *Macsec_Interface_ScsaRx_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetSciRx retrieves the value of the leaf SciRx from the Macsec_Interface_ScsaRx
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SciRx is set, it can
// safely use t.GetSciRx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SciRx == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx) GetSciRx() string {
	if t == nil || t.SciRx == nil {
		return ""
	}
	return *t.SciRx
}

// ΛListKeyMap returns the keys of the Macsec_Interface_ScsaRx struct, which is a YANG list entry.
func (t *Macsec_Interface_ScsaRx) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SciRx == nil {
		return nil, fmt.Errorf("nil value for key SciRx")
	}

	return map[string]interface{}{
		"sci-rx": *t.SciRx,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaRx) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_ScsaRx"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaRx) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_ScsaRx) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_ScsaRx.
func (*Macsec_Interface_ScsaRx) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_ScsaRx_Counters represents the /openconfig-macsec/macsec/interfaces/interface/scsa-rx/scsa-rx/state/counters YANG schema element.
type Macsec_Interface_ScsaRx_Counters struct {
	SaInvalid *uint64 `path:"sa-invalid" module:"openconfig-macsec"`
	SaValid   *uint64 `path:"sa-valid" module:"openconfig-macsec"`
	ScInvalid *uint64 `path:"sc-invalid" module:"openconfig-macsec"`
	ScValid   *uint64 `path:"sc-valid" module:"openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Interface_ScsaRx_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_ScsaRx_Counters) IsYANGGoStruct() {}

// GetSaInvalid retrieves the value of the leaf SaInvalid from the Macsec_Interface_ScsaRx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SaInvalid is set, it can
// safely use t.GetSaInvalid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SaInvalid == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx_Counters) GetSaInvalid() uint64 {
	if t == nil || t.SaInvalid == nil {
		return 0
	}
	return *t.SaInvalid
}

// GetSaValid retrieves the value of the leaf SaValid from the Macsec_Interface_ScsaRx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SaValid is set, it can
// safely use t.GetSaValid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SaValid == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx_Counters) GetSaValid() uint64 {
	if t == nil || t.SaValid == nil {
		return 0
	}
	return *t.SaValid
}

// GetScInvalid retrieves the value of the leaf ScInvalid from the Macsec_Interface_ScsaRx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScInvalid is set, it can
// safely use t.GetScInvalid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScInvalid == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx_Counters) GetScInvalid() uint64 {
	if t == nil || t.ScInvalid == nil {
		return 0
	}
	return *t.ScInvalid
}

// GetScValid retrieves the value of the leaf ScValid from the Macsec_Interface_ScsaRx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScValid is set, it can
// safely use t.GetScValid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScValid == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx_Counters) GetScValid() uint64 {
	if t == nil || t.ScValid == nil {
		return 0
	}
	return *t.ScValid
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaRx_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_ScsaRx_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaRx_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_ScsaRx_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_ScsaRx_Counters.
func (*Macsec_Interface_ScsaRx_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_ScsaTx represents the /openconfig-macsec/macsec/interfaces/interface/scsa-tx/scsa-tx YANG schema element.
type Macsec_Interface_ScsaTx struct {
	Counters *Macsec_Interface_ScsaTx_Counters `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	SciTx    *string                           `path:"state/sci-tx|sci-tx" module:"openconfig-macsec/openconfig-macsec|openconfig-macsec" shadow-path:"sci-tx" shadow-module:"openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Interface_ScsaTx implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_ScsaTx) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Interface_ScsaTx) GetOrCreateCounters() *Macsec_Interface_ScsaTx_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Interface_ScsaTx_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Interface_ScsaTx. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface_ScsaTx) GetCounters() *Macsec_Interface_ScsaTx_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetSciTx retrieves the value of the leaf SciTx from the Macsec_Interface_ScsaTx
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SciTx is set, it can
// safely use t.GetSciTx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SciTx == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx) GetSciTx() string {
	if t == nil || t.SciTx == nil {
		return ""
	}
	return *t.SciTx
}

// ΛListKeyMap returns the keys of the Macsec_Interface_ScsaTx struct, which is a YANG list entry.
func (t *Macsec_Interface_ScsaTx) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SciTx == nil {
		return nil, fmt.Errorf("nil value for key SciTx")
	}

	return map[string]interface{}{
		"sci-tx": *t.SciTx,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaTx) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_ScsaTx"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaTx) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_ScsaTx) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_ScsaTx.
func (*Macsec_Interface_ScsaTx) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_ScsaTx_Counters represents the /openconfig-macsec/macsec/interfaces/interface/scsa-tx/scsa-tx/state/counters YANG schema element.
type Macsec_Interface_ScsaTx_Counters struct {
	SaAuthOnly  *uint64 `path:"sa-auth-only" module:"openconfig-macsec"`
	SaEncrypted *uint64 `path:"sa-encrypted" module:"openconfig-macsec"`
	ScAuthOnly  *uint64 `path:"sc-auth-only" module:"openconfig-macsec"`
	ScEncrypted *uint64 `path:"sc-encrypted" module:"openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Interface_ScsaTx_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_ScsaTx_Counters) IsYANGGoStruct() {}

// GetSaAuthOnly retrieves the value of the leaf SaAuthOnly from the Macsec_Interface_ScsaTx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SaAuthOnly is set, it can
// safely use t.GetSaAuthOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SaAuthOnly == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx_Counters) GetSaAuthOnly() uint64 {
	if t == nil || t.SaAuthOnly == nil {
		return 0
	}
	return *t.SaAuthOnly
}

// GetSaEncrypted retrieves the value of the leaf SaEncrypted from the Macsec_Interface_ScsaTx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SaEncrypted is set, it can
// safely use t.GetSaEncrypted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SaEncrypted == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx_Counters) GetSaEncrypted() uint64 {
	if t == nil || t.SaEncrypted == nil {
		return 0
	}
	return *t.SaEncrypted
}

// GetScAuthOnly retrieves the value of the leaf ScAuthOnly from the Macsec_Interface_ScsaTx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScAuthOnly is set, it can
// safely use t.GetScAuthOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScAuthOnly == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx_Counters) GetScAuthOnly() uint64 {
	if t == nil || t.ScAuthOnly == nil {
		return 0
	}
	return *t.ScAuthOnly
}

// GetScEncrypted retrieves the value of the leaf ScEncrypted from the Macsec_Interface_ScsaTx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScEncrypted is set, it can
// safely use t.GetScEncrypted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScEncrypted == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx_Counters) GetScEncrypted() uint64 {
	if t == nil || t.ScEncrypted == nil {
		return 0
	}
	return *t.ScEncrypted
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaTx_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_ScsaTx_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaTx_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_ScsaTx_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_ScsaTx_Counters.
func (*Macsec_Interface_ScsaTx_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Mka represents the /openconfig-macsec/macsec/mka YANG schema element.
type Macsec_Mka struct {
	Counters *Macsec_Mka_Counters          `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	Policy   map[string]*Macsec_Mka_Policy `path:"policies/policy" module:"openconfig-macsec/openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Mka implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Mka) IsYANGGoStruct() {}

// NewPolicy creates a new entry in the Policy list of the
// Macsec_Mka struct. The keys of the list are populated from the input
// arguments.
func (t *Macsec_Mka) NewPolicy(Name string) (*Macsec_Mka_Policy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*Macsec_Mka_Policy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &Macsec_Mka_Policy{
		Name: &Name,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the Macsec_Mka struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Macsec_Mka) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.Name = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver Macsec_Mka. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Macsec_Mka) GetOrCreatePolicy(Name string) *Macsec_Mka_Policy {

	key := Name

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of Macsec_Mka. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Macsec_Mka) GetPolicy(Name string) *Macsec_Mka_Policy {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver Macsec_Mka. If there is no such element, the function
// is a no-op.
func (t *Macsec_Mka) DeletePolicy(Name string) {
	key := Name

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied Macsec_Mka_Policy struct to the
// list Policy of Macsec_Mka. If the key value(s) specified in
// the supplied Macsec_Mka_Policy already exist in the list, an error is
// returned.
func (t *Macsec_Mka) AppendPolicy(v *Macsec_Mka_Policy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*Macsec_Mka_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Mka) GetOrCreateCounters() *Macsec_Mka_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Mka_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Mka. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Mka) GetCounters() *Macsec_Mka_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Mka"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Mka) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Mka.
func (*Macsec_Mka) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Mka_Counters represents the /openconfig-macsec/macsec/mka/state/counters YANG schema element.
type Macsec_Mka_Counters struct {
	InMkpduBadPeerErrors         *uint64 `path:"in-mkpdu-bad-peer-errors" module:"openconfig-macsec"`
	InMkpduIcvVerificationErrors *uint64 `path:"in-mkpdu-icv-verification-errors" module:"openconfig-macsec"`
	InMkpduPeerListErrors        *uint64 `path:"in-mkpdu-peer-list-errors" module:"openconfig-macsec"`
	InMkpduValidationErrors      *uint64 `path:"in-mkpdu-validation-errors" module:"openconfig-macsec"`
	OutMkpduErrors               *uint64 `path:"out-mkpdu-errors" module:"openconfig-macsec"`
	SakCipherMismatchErrors      *uint64 `path:"sak-cipher-mismatch-errors" module:"openconfig-macsec"`
	SakDecryptionErrors          *uint64 `path:"sak-decryption-errors" module:"openconfig-macsec"`
	SakEncryptionErrors          *uint64 `path:"sak-encryption-errors" module:"openconfig-macsec"`
	SakGenerationErrors          *uint64 `path:"sak-generation-errors" module:"openconfig-macsec"`
	SakHashErrors                *uint64 `path:"sak-hash-errors" module:"openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Mka_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Mka_Counters) IsYANGGoStruct() {}

// GetInMkpduBadPeerErrors retrieves the value of the leaf InMkpduBadPeerErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpduBadPeerErrors is set, it can
// safely use t.GetInMkpduBadPeerErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpduBadPeerErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetInMkpduBadPeerErrors() uint64 {
	if t == nil || t.InMkpduBadPeerErrors == nil {
		return 0
	}
	return *t.InMkpduBadPeerErrors
}

// GetInMkpduIcvVerificationErrors retrieves the value of the leaf InMkpduIcvVerificationErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpduIcvVerificationErrors is set, it can
// safely use t.GetInMkpduIcvVerificationErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpduIcvVerificationErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetInMkpduIcvVerificationErrors() uint64 {
	if t == nil || t.InMkpduIcvVerificationErrors == nil {
		return 0
	}
	return *t.InMkpduIcvVerificationErrors
}

// GetInMkpduPeerListErrors retrieves the value of the leaf InMkpduPeerListErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpduPeerListErrors is set, it can
// safely use t.GetInMkpduPeerListErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpduPeerListErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetInMkpduPeerListErrors() uint64 {
	if t == nil || t.InMkpduPeerListErrors == nil {
		return 0
	}
	return *t.InMkpduPeerListErrors
}

// GetInMkpduValidationErrors retrieves the value of the leaf InMkpduValidationErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpduValidationErrors is set, it can
// safely use t.GetInMkpduValidationErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpduValidationErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetInMkpduValidationErrors() uint64 {
	if t == nil || t.InMkpduValidationErrors == nil {
		return 0
	}
	return *t.InMkpduValidationErrors
}

// GetOutMkpduErrors retrieves the value of the leaf OutMkpduErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMkpduErrors is set, it can
// safely use t.GetOutMkpduErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMkpduErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetOutMkpduErrors() uint64 {
	if t == nil || t.OutMkpduErrors == nil {
		return 0
	}
	return *t.OutMkpduErrors
}

// GetSakCipherMismatchErrors retrieves the value of the leaf SakCipherMismatchErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakCipherMismatchErrors is set, it can
// safely use t.GetSakCipherMismatchErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakCipherMismatchErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakCipherMismatchErrors() uint64 {
	if t == nil || t.SakCipherMismatchErrors == nil {
		return 0
	}
	return *t.SakCipherMismatchErrors
}

// GetSakDecryptionErrors retrieves the value of the leaf SakDecryptionErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakDecryptionErrors is set, it can
// safely use t.GetSakDecryptionErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakDecryptionErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakDecryptionErrors() uint64 {
	if t == nil || t.SakDecryptionErrors == nil {
		return 0
	}
	return *t.SakDecryptionErrors
}

// GetSakEncryptionErrors retrieves the value of the leaf SakEncryptionErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakEncryptionErrors is set, it can
// safely use t.GetSakEncryptionErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakEncryptionErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakEncryptionErrors() uint64 {
	if t == nil || t.SakEncryptionErrors == nil {
		return 0
	}
	return *t.SakEncryptionErrors
}

// GetSakGenerationErrors retrieves the value of the leaf SakGenerationErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakGenerationErrors is set, it can
// safely use t.GetSakGenerationErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakGenerationErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakGenerationErrors() uint64 {
	if t == nil || t.SakGenerationErrors == nil {
		return 0
	}
	return *t.SakGenerationErrors
}

// GetSakHashErrors retrieves the value of the leaf SakHashErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakHashErrors is set, it can
// safely use t.GetSakHashErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakHashErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakHashErrors() uint64 {
	if t == nil || t.SakHashErrors == nil {
		return 0
	}
	return *t.SakHashErrors
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Mka_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Mka_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Mka_Counters.
func (*Macsec_Mka_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Mka_Policy represents the /openconfig-macsec/macsec/mka/policies/policy YANG schema element.
type Macsec_Mka_Policy struct {
	ConfidentialityOffset  E_MacsecTypes_ConfidentialityOffset `path:"config/confidentiality-offset" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/confidentiality-offset" shadow-module:"openconfig-macsec/openconfig-macsec"`
	DelayProtection        *bool                               `path:"config/delay-protection" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/delay-protection" shadow-module:"openconfig-macsec/openconfig-macsec"`
	IncludeIcvIndicator    *bool                               `path:"config/include-icv-indicator" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/include-icv-indicator" shadow-module:"openconfig-macsec/openconfig-macsec"`
	KeyServerPriority      *uint8                              `path:"config/key-server-priority" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/key-server-priority" shadow-module:"openconfig-macsec/openconfig-macsec"`
	MacsecCipherSuite      []E_MacsecTypes_MacsecCipherSuite   `path:"config/macsec-cipher-suite" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/macsec-cipher-suite" shadow-module:"openconfig-macsec/openconfig-macsec"`
	Name                   *string                             `path:"config/name|name" module:"openconfig-macsec/openconfig-macsec|openconfig-macsec" shadow-path:"state/name|name" shadow-module:"openconfig-macsec/openconfig-macsec|openconfig-macsec"`
	SakRekeyInterval       *uint32                             `path:"config/sak-rekey-interval" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/sak-rekey-interval" shadow-module:"openconfig-macsec/openconfig-macsec"`
	SakRekeyOnLivePeerLoss *bool                               `path:"config/sak-rekey-on-live-peer-loss" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/sak-rekey-on-live-peer-loss" shadow-module:"openconfig-macsec/openconfig-macsec"`
	UseUpdatedEthHeader    *bool                               `path:"config/use-updated-eth-header" module:"openconfig-macsec/openconfig-macsec" shadow-path:"state/use-updated-eth-header" shadow-module:"openconfig-macsec/openconfig-macsec"`
}

// IsYANGGoStruct ensures that Macsec_Mka_Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Mka_Policy) IsYANGGoStruct() {}

// GetConfidentialityOffset retrieves the value of the leaf ConfidentialityOffset from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConfidentialityOffset is set, it can
// safely use t.GetConfidentialityOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConfidentialityOffset == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetConfidentialityOffset() E_MacsecTypes_ConfidentialityOffset {
	if t == nil || t.ConfidentialityOffset == 0 {
		return MacsecTypes_ConfidentialityOffset_0_BYTES
	}
	return t.ConfidentialityOffset
}

// GetDelayProtection retrieves the value of the leaf DelayProtection from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DelayProtection is set, it can
// safely use t.GetDelayProtection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DelayProtection == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetDelayProtection() bool {
	if t == nil || t.DelayProtection == nil {
		return false
	}
	return *t.DelayProtection
}

// GetIncludeIcvIndicator retrieves the value of the leaf IncludeIcvIndicator from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeIcvIndicator is set, it can
// safely use t.GetIncludeIcvIndicator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeIcvIndicator == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetIncludeIcvIndicator() bool {
	if t == nil || t.IncludeIcvIndicator == nil {
		return true
	}
	return *t.IncludeIcvIndicator
}

// GetKeyServerPriority retrieves the value of the leaf KeyServerPriority from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyServerPriority is set, it can
// safely use t.GetKeyServerPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyServerPriority == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetKeyServerPriority() uint8 {
	if t == nil || t.KeyServerPriority == nil {
		return 16
	}
	return *t.KeyServerPriority
}

// GetMacsecCipherSuite retrieves the value of the leaf MacsecCipherSuite from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacsecCipherSuite is set, it can
// safely use t.GetMacsecCipherSuite() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacsecCipherSuite == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetMacsecCipherSuite() []E_MacsecTypes_MacsecCipherSuite {
	if t == nil || t.MacsecCipherSuite == nil {
		return nil
	}
	return t.MacsecCipherSuite
}

// GetName retrieves the value of the leaf Name from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSakRekeyInterval retrieves the value of the leaf SakRekeyInterval from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakRekeyInterval is set, it can
// safely use t.GetSakRekeyInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakRekeyInterval == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetSakRekeyInterval() uint32 {
	if t == nil || t.SakRekeyInterval == nil {
		return 0
	}
	return *t.SakRekeyInterval
}

// GetSakRekeyOnLivePeerLoss retrieves the value of the leaf SakRekeyOnLivePeerLoss from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakRekeyOnLivePeerLoss is set, it can
// safely use t.GetSakRekeyOnLivePeerLoss() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakRekeyOnLivePeerLoss == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetSakRekeyOnLivePeerLoss() bool {
	if t == nil || t.SakRekeyOnLivePeerLoss == nil {
		return false
	}
	return *t.SakRekeyOnLivePeerLoss
}

// GetUseUpdatedEthHeader retrieves the value of the leaf UseUpdatedEthHeader from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseUpdatedEthHeader is set, it can
// safely use t.GetUseUpdatedEthHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseUpdatedEthHeader == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetUseUpdatedEthHeader() bool {
	if t == nil || t.UseUpdatedEthHeader == nil {
		return false
	}
	return *t.UseUpdatedEthHeader
}

// ΛListKeyMap returns the keys of the Macsec_Mka_Policy struct, which is a YANG list entry.
func (t *Macsec_Mka_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka_Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Mka_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka_Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Mka_Policy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Mka_Policy.
func (*Macsec_Mka_Policy) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// NetworkInstance represents the /openconfig-network-instance/network-instances/network-instance YANG schema element.
type NetworkInstance struct {
	Afts                   *NetworkInstance_Afts                                                    `path:"afts" module:"openconfig-network-instance"`
	ConnectionPoint        map[string]*NetworkInstance_ConnectionPoint                              `path:"connection-points/connection-point" module:"openconfig-network-instance/openconfig-network-instance"`
	Description            *string                                                                  `path:"config/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled                *bool                                                                    `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EnabledAddressFamilies []E_Types_ADDRESS_FAMILY                                                 `path:"config/enabled-address-families" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/enabled-address-families" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Encapsulation          *NetworkInstance_Encapsulation                                           `path:"encapsulation" module:"openconfig-network-instance"`
	Evpn                   *NetworkInstance_Evpn                                                    `path:"evpn" module:"openconfig-network-instance"`
	Fdb                    *NetworkInstance_Fdb                                                     `path:"fdb" module:"openconfig-network-instance"`
	InterInstancePolicies  *NetworkInstance_InterInstancePolicies                                   `path:"inter-instance-policies" module:"openconfig-network-instance"`
	Interface              map[string]*NetworkInstance_Interface                                    `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Mpls                   *NetworkInstance_Mpls                                                    `path:"mpls" module:"openconfig-network-instance"`
	Mtu                    *uint16                                                                  `path:"config/mtu" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/mtu" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name                   *string                                                                  `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	PolicyForwarding       *NetworkInstance_PolicyForwarding                                        `path:"policy-forwarding" module:"openconfig-network-instance"`
	Protocol               map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol               `path:"protocols/protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	RouteDistinguisher     *string                                                                  `path:"config/route-distinguisher" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/route-distinguisher" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RouteLimit             map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit                   `path:"route-limits/route-limit" module:"openconfig-network-instance/openconfig-network-instance"`
	RouterId               *string                                                                  `path:"config/router-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/router-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SegmentRouting         *NetworkInstance_SegmentRouting                                          `path:"segment-routing" module:"openconfig-network-instance"`
	Table                  map[NetworkInstance_Table_Key]*NetworkInstance_Table                     `path:"tables/table" module:"openconfig-network-instance/openconfig-network-instance"`
	TableConnection        map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection `path:"table-connections/table-connection" module:"openconfig-network-instance/openconfig-network-instance"`
	Type                   E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE                             `path:"config/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan                   map[uint16]*NetworkInstance_Vlan                                         `path:"vlans/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance) IsYANGGoStruct() {}

// NetworkInstance_Protocol_Key represents the key for list Protocol of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_Protocol_Key struct {
	Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"identifier"`
	Name       string                              `path:"name"`
}

// NetworkInstance_Table_Key represents the key for list Table of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_Table_Key struct {
	Protocol      E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"protocol"`
	AddressFamily E_Types_ADDRESS_FAMILY              `path:"address-family"`
}

// NetworkInstance_TableConnection_Key represents the key for list TableConnection of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_TableConnection_Key struct {
	SrcProtocol   E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"src-protocol"`
	DstProtocol   E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"dst-protocol"`
	AddressFamily E_Types_ADDRESS_FAMILY              `path:"address-family"`
}

// NewConnectionPoint creates a new entry in the ConnectionPoint list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewConnectionPoint(ConnectionPointId string) (*NetworkInstance_ConnectionPoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	key := ConnectionPointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConnectionPoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConnectionPoint", key)
	}

	t.ConnectionPoint[key] = &NetworkInstance_ConnectionPoint{
		ConnectionPointId: &ConnectionPointId,
	}

	return t.ConnectionPoint[key], nil
}

// RenameConnectionPoint renames an entry in the list ConnectionPoint within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameConnectionPoint(oldK, newK string) error {
	if _, ok := t.ConnectionPoint[newK]; ok {
		return fmt.Errorf("key %v already exists in ConnectionPoint", newK)
	}

	e, ok := t.ConnectionPoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConnectionPoint", oldK)
	}
	e.ConnectionPointId = &newK

	t.ConnectionPoint[newK] = e
	delete(t.ConnectionPoint, oldK)
	return nil
}

// GetOrCreateConnectionPoint retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	key := ConnectionPointId

	if v, ok := t.ConnectionPoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConnectionPoint(ConnectionPointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConnectionPoint got unexpected error: %v", err))
	}
	return v
}

// GetConnectionPoint retrieves the value with the specified key from
// the ConnectionPoint map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	if t == nil {
		return nil
	}

	key := ConnectionPointId

	if lm, ok := t.ConnectionPoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConnectionPoint deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteConnectionPoint(ConnectionPointId string) {
	key := ConnectionPointId

	delete(t.ConnectionPoint, key)
}

// AppendConnectionPoint appends the supplied NetworkInstance_ConnectionPoint struct to the
// list ConnectionPoint of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendConnectionPoint(v *NetworkInstance_ConnectionPoint) error {
	if v.ConnectionPointId == nil {
		return fmt.Errorf("invalid nil key received for ConnectionPointId")
	}

	key := *v.ConnectionPointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	if _, ok := t.ConnectionPoint[key]; ok {
		return fmt.Errorf("duplicate key for list ConnectionPoint %v", key)
	}

	t.ConnectionPoint[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewInterface(Id string) (*NetworkInstance_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateInterface(Id string) *NetworkInstance_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetInterface(Id string) *NetworkInstance_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteInterface(Id string) {
	key := Id

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Interface struct to the
// list Interface of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendInterface(v *NetworkInstance_Interface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewProtocol creates a new entry in the Protocol list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) (*NetworkInstance_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NetworkInstance_Protocol{
		Identifier: Identifier,
		Name:       &Name,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameProtocol(oldK, newK NetworkInstance_Protocol_Key) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.Identifier = newK.Identifier
	e.Name = &newK.Name

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(Identifier, Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocol deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) {
	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	delete(t.Protocol, key)
}

// AppendProtocol appends the supplied NetworkInstance_Protocol struct to the
// list Protocol of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendProtocol(v *NetworkInstance_Protocol) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key for Name")
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: v.Identifier,
		Name:       *v.Name,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// NewRouteLimit creates a new entry in the RouteLimit list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewRouteLimit(Afi E_Types_ADDRESS_FAMILY) (*NetworkInstance_RouteLimit, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	key := Afi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RouteLimit[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RouteLimit", key)
	}

	t.RouteLimit[key] = &NetworkInstance_RouteLimit{
		Afi: Afi,
	}

	return t.RouteLimit[key], nil
}

// RenameRouteLimit renames an entry in the list RouteLimit within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameRouteLimit(oldK, newK E_Types_ADDRESS_FAMILY) error {
	if _, ok := t.RouteLimit[newK]; ok {
		return fmt.Errorf("key %v already exists in RouteLimit", newK)
	}

	e, ok := t.RouteLimit[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RouteLimit", oldK)
	}
	e.Afi = newK

	t.RouteLimit[newK] = e
	delete(t.RouteLimit, oldK)
	return nil
}

// GetOrCreateRouteLimit retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateRouteLimit(Afi E_Types_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	key := Afi

	if v, ok := t.RouteLimit[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRouteLimit(Afi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRouteLimit got unexpected error: %v", err))
	}
	return v
}

// GetRouteLimit retrieves the value with the specified key from
// the RouteLimit map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetRouteLimit(Afi E_Types_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	if t == nil {
		return nil
	}

	key := Afi

	if lm, ok := t.RouteLimit[key]; ok {
		return lm
	}
	return nil
}

// DeleteRouteLimit deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteRouteLimit(Afi E_Types_ADDRESS_FAMILY) {
	key := Afi

	delete(t.RouteLimit, key)
}

// AppendRouteLimit appends the supplied NetworkInstance_RouteLimit struct to the
// list RouteLimit of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_RouteLimit already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendRouteLimit(v *NetworkInstance_RouteLimit) error {
	key := v.Afi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	if _, ok := t.RouteLimit[key]; ok {
		return fmt.Errorf("duplicate key for list RouteLimit %v", key)
	}

	t.RouteLimit[key] = v
	return nil
}

// NewTable creates a new entry in the Table list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) (*NetworkInstance_Table, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Table[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Table", key)
	}

	t.Table[key] = &NetworkInstance_Table{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	return t.Table[key], nil
}

// RenameTable renames an entry in the list Table within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTable(oldK, newK NetworkInstance_Table_Key) error {
	if _, ok := t.Table[newK]; ok {
		return fmt.Errorf("key %v already exists in Table", newK)
	}

	e, ok := t.Table[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Table", oldK)
	}
	e.Protocol = newK.Protocol
	e.AddressFamily = newK.AddressFamily

	t.Table[newK] = e
	delete(t.Table, oldK)
	return nil
}

// GetOrCreateTable retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_Table {

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.Table[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTable(Protocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTable got unexpected error: %v", err))
	}
	return v
}

// GetTable retrieves the value with the specified key from
// the Table map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_Table {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.Table[key]; ok {
		return lm
	}
	return nil
}

// DeleteTable deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) {
	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	delete(t.Table, key)
}

// AppendTable appends the supplied NetworkInstance_Table struct to the
// list Table of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Table already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTable(v *NetworkInstance_Table) error {
	key := NetworkInstance_Table_Key{
		Protocol:      v.Protocol,
		AddressFamily: v.AddressFamily,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	if _, ok := t.Table[key]; ok {
		return fmt.Errorf("duplicate key for list Table %v", key)
	}

	t.Table[key] = v
	return nil
}

// NewTableConnection creates a new entry in the TableConnection list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) (*NetworkInstance_TableConnection, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TableConnection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TableConnection", key)
	}

	t.TableConnection[key] = &NetworkInstance_TableConnection{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	return t.TableConnection[key], nil
}

// RenameTableConnection renames an entry in the list TableConnection within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTableConnection(oldK, newK NetworkInstance_TableConnection_Key) error {
	if _, ok := t.TableConnection[newK]; ok {
		return fmt.Errorf("key %v already exists in TableConnection", newK)
	}

	e, ok := t.TableConnection[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TableConnection", oldK)
	}
	e.SrcProtocol = newK.SrcProtocol
	e.DstProtocol = newK.DstProtocol
	e.AddressFamily = newK.AddressFamily

	t.TableConnection[newK] = e
	delete(t.TableConnection, oldK)
	return nil
}

// GetOrCreateTableConnection retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.TableConnection[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTableConnection(SrcProtocol, DstProtocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTableConnection got unexpected error: %v", err))
	}
	return v
}

// GetTableConnection retrieves the value with the specified key from
// the TableConnection map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	if t == nil {
		return nil
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.TableConnection[key]; ok {
		return lm
	}
	return nil
}

// DeleteTableConnection deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	delete(t.TableConnection, key)
}

// AppendTableConnection appends the supplied NetworkInstance_TableConnection struct to the
// list TableConnection of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_TableConnection already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTableConnection(v *NetworkInstance_TableConnection) error {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   v.SrcProtocol,
		DstProtocol:   v.DstProtocol,
		AddressFamily: v.AddressFamily,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	if _, ok := t.TableConnection[key]; ok {
		return fmt.Errorf("duplicate key for list TableConnection %v", key)
	}

	t.TableConnection[key] = v
	return nil
}

// NewVlan creates a new entry in the Vlan list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewVlan(VlanId uint16) (*NetworkInstance_Vlan, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vlan[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vlan", key)
	}

	t.Vlan[key] = &NetworkInstance_Vlan{
		VlanId: &VlanId,
	}

	return t.Vlan[key], nil
}

// RenameVlan renames an entry in the list Vlan within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameVlan(oldK, newK uint16) error {
	if _, ok := t.Vlan[newK]; ok {
		return fmt.Errorf("key %v already exists in Vlan", newK)
	}

	e, ok := t.Vlan[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vlan", oldK)
	}
	e.VlanId = &newK

	t.Vlan[newK] = e
	delete(t.Vlan, oldK)
	return nil
}

// GetOrCreateVlan retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateVlan(VlanId uint16) *NetworkInstance_Vlan {

	key := VlanId

	if v, ok := t.Vlan[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlan(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlan got unexpected error: %v", err))
	}
	return v
}

// GetVlan retrieves the value with the specified key from
// the Vlan map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetVlan(VlanId uint16) *NetworkInstance_Vlan {

	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.Vlan[key]; ok {
		return lm
	}
	return nil
}

// DeleteVlan deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteVlan(VlanId uint16) {
	key := VlanId

	delete(t.Vlan, key)
}

// AppendVlan appends the supplied NetworkInstance_Vlan struct to the
// list Vlan of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Vlan already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendVlan(v *NetworkInstance_Vlan) error {
	if v.VlanId == nil {
		return fmt.Errorf("invalid nil key received for VlanId")
	}

	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	if _, ok := t.Vlan[key]; ok {
		return fmt.Errorf("duplicate key for list Vlan %v", key)
	}

	t.Vlan[key] = v
	return nil
}

// GetOrCreateAfts retrieves the value of the Afts field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateAfts() *NetworkInstance_Afts {
	if t.Afts != nil {
		return t.Afts
	}
	t.Afts = &NetworkInstance_Afts{}
	return t.Afts
}

// GetOrCreateEncapsulation retrieves the value of the Encapsulation field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEncapsulation() *NetworkInstance_Encapsulation {
	if t.Encapsulation != nil {
		return t.Encapsulation
	}
	t.Encapsulation = &NetworkInstance_Encapsulation{}
	return t.Encapsulation
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEvpn() *NetworkInstance_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &NetworkInstance_Evpn{}
	return t.Evpn
}

// GetOrCreateFdb retrieves the value of the Fdb field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateFdb() *NetworkInstance_Fdb {
	if t.Fdb != nil {
		return t.Fdb
	}
	t.Fdb = &NetworkInstance_Fdb{}
	return t.Fdb
}

// GetOrCreateInterInstancePolicies retrieves the value of the InterInstancePolicies field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	t.InterInstancePolicies = &NetworkInstance_InterInstancePolicies{}
	return t.InterInstancePolicies
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateMpls() *NetworkInstance_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Mpls{}
	return t.Mpls
}

// GetOrCreatePolicyForwarding retrieves the value of the PolicyForwarding field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreatePolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	t.PolicyForwarding = &NetworkInstance_PolicyForwarding{}
	return t.PolicyForwarding
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateSegmentRouting() *NetworkInstance_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_SegmentRouting{}
	return t.SegmentRouting
}

// GetAfts returns the value of the Afts struct pointer
// from NetworkInstance. If the receiver or the field Afts is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetAfts() *NetworkInstance_Afts {
	if t != nil && t.Afts != nil {
		return t.Afts
	}
	return nil
}

// GetEncapsulation returns the value of the Encapsulation struct pointer
// from NetworkInstance. If the receiver or the field Encapsulation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEncapsulation() *NetworkInstance_Encapsulation {
	if t != nil && t.Encapsulation != nil {
		return t.Encapsulation
	}
	return nil
}

// GetEvpn returns the value of the Evpn struct pointer
// from NetworkInstance. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEvpn() *NetworkInstance_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetFdb returns the value of the Fdb struct pointer
// from NetworkInstance. If the receiver or the field Fdb is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetFdb() *NetworkInstance_Fdb {
	if t != nil && t.Fdb != nil {
		return t.Fdb
	}
	return nil
}

// GetInterInstancePolicies returns the value of the InterInstancePolicies struct pointer
// from NetworkInstance. If the receiver or the field InterInstancePolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t != nil && t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetMpls() *NetworkInstance_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetPolicyForwarding returns the value of the PolicyForwarding struct pointer
// from NetworkInstance. If the receiver or the field PolicyForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetPolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t != nil && t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetSegmentRouting() *NetworkInstance_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetEnabledAddressFamilies retrieves the value of the leaf EnabledAddressFamilies from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnabledAddressFamilies is set, it can
// safely use t.GetEnabledAddressFamilies() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnabledAddressFamilies == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetEnabledAddressFamilies() []E_Types_ADDRESS_FAMILY {
	if t == nil || t.EnabledAddressFamilies == nil {
		return nil
	}
	return t.EnabledAddressFamilies
}

// GetMtu retrieves the value of the leaf Mtu from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// GetName retrieves the value of the leaf Name from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRouteDistinguisher retrieves the value of the leaf RouteDistinguisher from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteDistinguisher is set, it can
// safely use t.GetRouteDistinguisher() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteDistinguisher == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetRouteDistinguisher() string {
	if t == nil || t.RouteDistinguisher == nil {
		return ""
	}
	return *t.RouteDistinguisher
}

// GetRouterId retrieves the value of the leaf RouterId from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// GetType retrieves the value of the leaf Type from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetType() E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the NetworkInstance struct, which is a YANG list entry.
func (t *NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance.
func (*NetworkInstance) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts represents the /openconfig-network-instance/network-instances/network-instance/afts YANG schema element.
type NetworkInstance_Afts struct {
	Ipv4Entry             map[string]*NetworkInstance_Afts_Ipv4Entry                                       `path:"ipv4-unicast/ipv4-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv6Entry             map[string]*NetworkInstance_Afts_Ipv6Entry                                       `path:"ipv6-unicast/ipv6-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	LabelEntry            map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry `path:"mpls/label-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	MacEntry              map[string]*NetworkInstance_Afts_MacEntry                                        `path:"ethernet/mac-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop               map[uint64]*NetworkInstance_Afts_NextHop                                         `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup          map[uint64]*NetworkInstance_Afts_NextHopGroup                                    `path:"next-hop-groups/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	PolicyForwardingEntry map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry                           `path:"policy-forwarding/policy-forwarding-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	StateSynced           *NetworkInstance_Afts_StateSynced                                                `path:"state-synced" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts) IsYANGGoStruct() {}

// NewIpv4Entry creates a new entry in the Ipv4Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv4Entry(Prefix string) (*NetworkInstance_Afts_Ipv4Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Entry", key)
	}

	t.Ipv4Entry[key] = &NetworkInstance_Afts_Ipv4Entry{
		Prefix: &Prefix,
	}

	return t.Ipv4Entry[key], nil
}

// RenameIpv4Entry renames an entry in the list Ipv4Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv4Entry(oldK, newK string) error {
	if _, ok := t.Ipv4Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Entry", newK)
	}

	e, ok := t.Ipv4Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv4Entry[newK] = e
	delete(t.Ipv4Entry, oldK)
	return nil
}

// GetOrCreateIpv4Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	key := Prefix

	if v, ok := t.Ipv4Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Entry retrieves the value with the specified key from
// the Ipv4Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv4Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv4Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv4Entry, key)
}

// AppendIpv4Entry appends the supplied NetworkInstance_Afts_Ipv4Entry struct to the
// list Ipv4Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv4Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv4Entry(v *NetworkInstance_Afts_Ipv4Entry) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	if _, ok := t.Ipv4Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Entry %v", key)
	}

	t.Ipv4Entry[key] = v
	return nil
}

// NewIpv6Entry creates a new entry in the Ipv6Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv6Entry(Prefix string) (*NetworkInstance_Afts_Ipv6Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Entry", key)
	}

	t.Ipv6Entry[key] = &NetworkInstance_Afts_Ipv6Entry{
		Prefix: &Prefix,
	}

	return t.Ipv6Entry[key], nil
}

// RenameIpv6Entry renames an entry in the list Ipv6Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv6Entry(oldK, newK string) error {
	if _, ok := t.Ipv6Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Entry", newK)
	}

	e, ok := t.Ipv6Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv6Entry[newK] = e
	delete(t.Ipv6Entry, oldK)
	return nil
}

// GetOrCreateIpv6Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	key := Prefix

	if v, ok := t.Ipv6Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Entry retrieves the value with the specified key from
// the Ipv6Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv6Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv6Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv6Entry, key)
}

// AppendIpv6Entry appends the supplied NetworkInstance_Afts_Ipv6Entry struct to the
// list Ipv6Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv6Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv6Entry(v *NetworkInstance_Afts_Ipv6Entry) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	if _, ok := t.Ipv6Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Entry %v", key)
	}

	t.Ipv6Entry[key] = v
	return nil
}

// NewLabelEntry creates a new entry in the LabelEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) (*NetworkInstance_Afts_LabelEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	key := Label

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LabelEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LabelEntry", key)
	}

	t.LabelEntry[key] = &NetworkInstance_Afts_LabelEntry{
		Label: Label,
	}

	return t.LabelEntry[key], nil
}

// RenameLabelEntry renames an entry in the list LabelEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameLabelEntry(oldK, newK NetworkInstance_Afts_LabelEntry_Label_Union) error {
	if _, ok := t.LabelEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in LabelEntry", newK)
	}

	e, ok := t.LabelEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LabelEntry", oldK)
	}
	e.Label = newK

	t.LabelEntry[newK] = e
	delete(t.LabelEntry, oldK)
	return nil
}

// GetOrCreateLabelEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	key := Label

	if v, ok := t.LabelEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLabelEntry(Label)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLabelEntry got unexpected error: %v", err))
	}
	return v
}

// GetLabelEntry retrieves the value with the specified key from
// the LabelEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	if t == nil {
		return nil
	}

	key := Label

	if lm, ok := t.LabelEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteLabelEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) {
	key := Label

	delete(t.LabelEntry, key)
}

// AppendLabelEntry appends the supplied NetworkInstance_Afts_LabelEntry struct to the
// list LabelEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_LabelEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendLabelEntry(v *NetworkInstance_Afts_LabelEntry) error {
	key := v.Label

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	if _, ok := t.LabelEntry[key]; ok {
		return fmt.Errorf("duplicate key for list LabelEntry %v", key)
	}

	t.LabelEntry[key] = v
	return nil
}

// NewMacEntry creates a new entry in the MacEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewMacEntry(MacAddress string) (*NetworkInstance_Afts_MacEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MacEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MacEntry", key)
	}

	t.MacEntry[key] = &NetworkInstance_Afts_MacEntry{
		MacAddress: &MacAddress,
	}

	return t.MacEntry[key], nil
}

// RenameMacEntry renames an entry in the list MacEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameMacEntry(oldK, newK string) error {
	if _, ok := t.MacEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in MacEntry", newK)
	}

	e, ok := t.MacEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MacEntry", oldK)
	}
	e.MacAddress = &newK

	t.MacEntry[newK] = e
	delete(t.MacEntry, oldK)
	return nil
}

// GetOrCreateMacEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	key := MacAddress

	if v, ok := t.MacEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacEntry got unexpected error: %v", err))
	}
	return v
}

// GetMacEntry retrieves the value with the specified key from
// the MacEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.MacEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteMacEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteMacEntry(MacAddress string) {
	key := MacAddress

	delete(t.MacEntry, key)
}

// AppendMacEntry appends the supplied NetworkInstance_Afts_MacEntry struct to the
// list MacEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_MacEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendMacEntry(v *NetworkInstance_Afts_MacEntry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key received for MacAddress")
	}

	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	if _, ok := t.MacEntry[key]; ok {
		return fmt.Errorf("duplicate key for list MacEntry %v", key)
	}

	t.MacEntry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHop struct to the
// list NextHop of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHop(v *NetworkInstance_Afts_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHopGroup(Id uint64) (*NetworkInstance_Afts_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Afts_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Afts_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHopGroup(v *NetworkInstance_Afts_NextHopGroup) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// NewPolicyForwardingEntry creates a new entry in the PolicyForwardingEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewPolicyForwardingEntry(Index uint64) (*NetworkInstance_Afts_PolicyForwardingEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicyForwardingEntry", key)
	}

	t.PolicyForwardingEntry[key] = &NetworkInstance_Afts_PolicyForwardingEntry{
		Index: &Index,
	}

	return t.PolicyForwardingEntry[key], nil
}

// RenamePolicyForwardingEntry renames an entry in the list PolicyForwardingEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenamePolicyForwardingEntry(oldK, newK uint64) error {
	if _, ok := t.PolicyForwardingEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicyForwardingEntry", newK)
	}

	e, ok := t.PolicyForwardingEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicyForwardingEntry", oldK)
	}
	e.Index = &newK

	t.PolicyForwardingEntry[newK] = e
	delete(t.PolicyForwardingEntry, oldK)
	return nil
}

// GetOrCreatePolicyForwardingEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreatePolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	key := Index

	if v, ok := t.PolicyForwardingEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicyForwardingEntry(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicyForwardingEntry got unexpected error: %v", err))
	}
	return v
}

// GetPolicyForwardingEntry retrieves the value with the specified key from
// the PolicyForwardingEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetPolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.PolicyForwardingEntry[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicyForwardingEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeletePolicyForwardingEntry(Index uint64) {
	key := Index

	delete(t.PolicyForwardingEntry, key)
}

// AppendPolicyForwardingEntry appends the supplied NetworkInstance_Afts_PolicyForwardingEntry struct to the
// list PolicyForwardingEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_PolicyForwardingEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendPolicyForwardingEntry(v *NetworkInstance_Afts_PolicyForwardingEntry) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return fmt.Errorf("duplicate key for list PolicyForwardingEntry %v", key)
	}

	t.PolicyForwardingEntry[key] = v
	return nil
}

// GetOrCreateStateSynced retrieves the value of the StateSynced field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts) GetOrCreateStateSynced() *NetworkInstance_Afts_StateSynced {
	if t.StateSynced != nil {
		return t.StateSynced
	}
	t.StateSynced = &NetworkInstance_Afts_StateSynced{}
	return t.StateSynced
}

// GetStateSynced returns the value of the StateSynced struct pointer
// from NetworkInstance_Afts. If the receiver or the field StateSynced is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts) GetStateSynced() *NetworkInstance_Afts_StateSynced {
	if t != nil && t.StateSynced != nil {
		return t.StateSynced
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts.
func (*NetworkInstance_Afts) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv4Entry represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry YANG schema element.
type NetworkInstance_Afts_Ipv4Entry struct {
	Counters          *NetworkInstance_Afts_Ipv4Entry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader E_AftTypes_EncapsulationHeaderType       `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata     Binary                                   `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	OriginProtocol    E_PolicyTypes_INSTALL_PROTOCOL_TYPE      `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix            *string                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"prefix" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv4Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv4Entry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOrCreateCounters() *NetworkInstance_Afts_Ipv4Entry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_Ipv4Entry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_Ipv4Entry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_Ipv4Entry) GetCounters() *NetworkInstance_Afts_Ipv4Entry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv4Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv4Entry.
func (*NetworkInstance_Afts_Ipv4Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv4Entry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/counters YANG schema element.
type NetworkInstance_Afts_Ipv4Entry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv4Entry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv4Entry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_Ipv4Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_Ipv4Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv4Entry_Counters.
func (*NetworkInstance_Afts_Ipv4Entry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv6Entry represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry YANG schema element.
type NetworkInstance_Afts_Ipv6Entry struct {
	Counters          *NetworkInstance_Afts_Ipv6Entry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader E_AftTypes_EncapsulationHeaderType       `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata     Binary                                   `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	OriginProtocol    E_PolicyTypes_INSTALL_PROTOCOL_TYPE      `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix            *string                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"prefix" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv6Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv6Entry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOrCreateCounters() *NetworkInstance_Afts_Ipv6Entry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_Ipv6Entry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_Ipv6Entry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_Ipv6Entry) GetCounters() *NetworkInstance_Afts_Ipv6Entry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv6Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv6Entry.
func (*NetworkInstance_Afts_Ipv6Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv6Entry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/counters YANG schema element.
type NetworkInstance_Afts_Ipv6Entry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv6Entry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv6Entry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_Ipv6Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_Ipv6Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv6Entry_Counters.
func (*NetworkInstance_Afts_Ipv6Entry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_LabelEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry YANG schema element.
type NetworkInstance_Afts_LabelEntry struct {
	Counters             *NetworkInstance_Afts_LabelEntry_Counters                    `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata        Binary                                                       `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	Label                NetworkInstance_Afts_LabelEntry_Label_Union                  `path:"state/label|label" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"label" shadow-module:"openconfig-network-instance"`
	PoppedMplsLabelStack []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union `path:"state/popped-mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_LabelEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_LabelEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_LabelEntry) GetOrCreateCounters() *NetworkInstance_Afts_LabelEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_LabelEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_LabelEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_LabelEntry) GetCounters() *NetworkInstance_Afts_LabelEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetLabel() NetworkInstance_Afts_LabelEntry_Label_Union {
	if t == nil || t.Label == nil {
		return nil
	}
	return t.Label
}

// GetPoppedMplsLabelStack retrieves the value of the leaf PoppedMplsLabelStack from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PoppedMplsLabelStack is set, it can
// safely use t.GetPoppedMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PoppedMplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetPoppedMplsLabelStack() []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union {
	if t == nil || t.PoppedMplsLabelStack == nil {
		return nil
	}
	return t.PoppedMplsLabelStack
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_LabelEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_LabelEntry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"label": t.Label,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_LabelEntry.
func (*NetworkInstance_Afts_LabelEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_LabelEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/counters YANG schema element.
type NetworkInstance_Afts_LabelEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_LabelEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_LabelEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_LabelEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_LabelEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_LabelEntry_Counters.
func (*NetworkInstance_Afts_LabelEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_MacEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry YANG schema element.
type NetworkInstance_Afts_MacEntry struct {
	Counters      *NetworkInstance_Afts_MacEntry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata Binary                                  `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress    *string                                 `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_MacEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_MacEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_MacEntry) GetOrCreateCounters() *NetworkInstance_Afts_MacEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_MacEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_MacEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_MacEntry) GetCounters() *NetworkInstance_Afts_MacEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_MacEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_MacEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_MacEntry.
func (*NetworkInstance_Afts_MacEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_MacEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/counters YANG schema element.
type NetworkInstance_Afts_MacEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_MacEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_MacEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_MacEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_MacEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_MacEntry_Counters.
func (*NetworkInstance_Afts_MacEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop YANG schema element.
type NetworkInstance_Afts_NextHop struct {
	Counters             *NetworkInstance_Afts_NextHop_Counters                    `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader    E_AftTypes_EncapsulationHeaderType                        `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulateHeader    E_AftTypes_EncapsulationHeaderType                        `path:"state/encapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	Index                *uint64                                                   `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	InterfaceRef         *NetworkInstance_Afts_NextHop_InterfaceRef                `path:"interface-ref" module:"openconfig-network-instance"`
	IpAddress            *string                                                   `path:"state/ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	IpInIp               *NetworkInstance_Afts_NextHop_IpInIp                      `path:"ip-in-ip" module:"openconfig-network-instance"`
	LspName              *string                                                   `path:"state/lsp-name" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress           *string                                                   `path:"state/mac-address" module:"openconfig-network-instance/openconfig-network-instance"`
	OriginProtocol       E_PolicyTypes_INSTALL_PROTOCOL_TYPE                       `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	PopTopLabel          *bool                                                     `path:"state/pop-top-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ProgrammedIndex      *uint64                                                   `path:"state/programmed-index" module:"openconfig-network-instance/openconfig-network-instance"`
	PushedMplsLabelStack []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union `path:"state/pushed-mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
	TunnelSrcIpAddress   *string                                                   `path:"state/tunnel-src-ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	VniLabel             *uint32                                                   `path:"state/vni-label" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateCounters() *NetworkInstance_Afts_NextHop_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_NextHop_Counters{}
	return t.Counters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Afts_NextHop_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateIpInIp retrieves the value of the IpInIp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateIpInIp() *NetworkInstance_Afts_NextHop_IpInIp {
	if t.IpInIp != nil {
		return t.IpInIp
	}
	t.IpInIp = &NetworkInstance_Afts_NextHop_IpInIp{}
	return t.IpInIp
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetCounters() *NetworkInstance_Afts_NextHop_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetIpInIp returns the value of the IpInIp struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field IpInIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetIpInIp() *NetworkInstance_Afts_NextHop_IpInIp {
	if t != nil && t.IpInIp != nil {
		return t.IpInIp
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEncapsulateHeader retrieves the value of the leaf EncapsulateHeader from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulateHeader is set, it can
// safely use t.GetEncapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetEncapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.EncapsulateHeader == 0 {
		return 0
	}
	return t.EncapsulateHeader
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpAddress retrieves the value of the leaf IpAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetLspName retrieves the value of the leaf LspName from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspName is set, it can
// safely use t.GetLspName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetLspName() string {
	if t == nil || t.LspName == nil {
		return ""
	}
	return *t.LspName
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPopTopLabel retrieves the value of the leaf PopTopLabel from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PopTopLabel is set, it can
// safely use t.GetPopTopLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PopTopLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetPopTopLabel() bool {
	if t == nil || t.PopTopLabel == nil {
		return false
	}
	return *t.PopTopLabel
}

// GetProgrammedIndex retrieves the value of the leaf ProgrammedIndex from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProgrammedIndex is set, it can
// safely use t.GetProgrammedIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProgrammedIndex == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetProgrammedIndex() uint64 {
	if t == nil || t.ProgrammedIndex == nil {
		return 0
	}
	return *t.ProgrammedIndex
}

// GetPushedMplsLabelStack retrieves the value of the leaf PushedMplsLabelStack from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushedMplsLabelStack is set, it can
// safely use t.GetPushedMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushedMplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetPushedMplsLabelStack() []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union {
	if t == nil || t.PushedMplsLabelStack == nil {
		return nil
	}
	return t.PushedMplsLabelStack
}

// GetTunnelSrcIpAddress retrieves the value of the leaf TunnelSrcIpAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelSrcIpAddress is set, it can
// safely use t.GetTunnelSrcIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelSrcIpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetTunnelSrcIpAddress() string {
	if t == nil || t.TunnelSrcIpAddress == nil {
		return ""
	}
	return *t.TunnelSrcIpAddress
}

// GetVniLabel retrieves the value of the leaf VniLabel from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniLabel is set, it can
// safely use t.GetVniLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetVniLabel() uint32 {
	if t == nil || t.VniLabel == nil {
		return 0
	}
	return *t.VniLabel
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop.
func (*NetworkInstance_Afts_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group YANG schema element.
type NetworkInstance_Afts_NextHopGroup struct {
	BackupNextHopGroup *uint64                                                 `path:"state/backup-next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	Color              *uint64                                                 `path:"state/color" module:"openconfig-network-instance/openconfig-network-instance"`
	Condition          map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition `path:"conditional/condition" module:"openconfig-network-instance/openconfig-network-instance"`
	Id                 *uint64                                                 `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	NextHop            map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop   `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ProgrammedId       *uint64                                                 `path:"state/programmed-id" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup) IsYANGGoStruct() {}

// NewCondition creates a new entry in the Condition list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewCondition(Id uint64) (*NetworkInstance_Afts_NextHopGroup_Condition, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Condition[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Condition", key)
	}

	t.Condition[key] = &NetworkInstance_Afts_NextHopGroup_Condition{
		Id: &Id,
	}

	return t.Condition[key], nil
}

// RenameCondition renames an entry in the list Condition within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameCondition(oldK, newK uint64) error {
	if _, ok := t.Condition[newK]; ok {
		return fmt.Errorf("key %v already exists in Condition", newK)
	}

	e, ok := t.Condition[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Condition", oldK)
	}
	e.Id = &newK

	t.Condition[newK] = e
	delete(t.Condition, oldK)
	return nil
}

// GetOrCreateCondition retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateCondition(Id uint64) *NetworkInstance_Afts_NextHopGroup_Condition {

	key := Id

	if v, ok := t.Condition[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCondition(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCondition got unexpected error: %v", err))
	}
	return v
}

// GetCondition retrieves the value with the specified key from
// the Condition map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetCondition(Id uint64) *NetworkInstance_Afts_NextHopGroup_Condition {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Condition[key]; ok {
		return lm
	}
	return nil
}

// DeleteCondition deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteCondition(Id uint64) {
	key := Id

	delete(t.Condition, key)
}

// AppendCondition appends the supplied NetworkInstance_Afts_NextHopGroup_Condition struct to the
// list Condition of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_Condition already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendCondition(v *NetworkInstance_Afts_NextHopGroup_Condition) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}

	if _, ok := t.Condition[key]; ok {
		return fmt.Errorf("duplicate key for list Condition %v", key)
	}

	t.Condition[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendNextHop(v *NetworkInstance_Afts_NextHopGroup_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetBackupNextHopGroup retrieves the value of the leaf BackupNextHopGroup from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackupNextHopGroup is set, it can
// safely use t.GetBackupNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackupNextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetBackupNextHopGroup() uint64 {
	if t == nil || t.BackupNextHopGroup == nil {
		return 0
	}
	return *t.BackupNextHopGroup
}

// GetColor retrieves the value of the leaf Color from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Color is set, it can
// safely use t.GetColor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Color == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetColor() uint64 {
	if t == nil || t.Color == nil {
		return 0
	}
	return *t.Color
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetProgrammedId retrieves the value of the leaf ProgrammedId from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProgrammedId is set, it can
// safely use t.GetProgrammedId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProgrammedId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetProgrammedId() uint64 {
	if t == nil || t.ProgrammedId == nil {
		return 0
	}
	return *t.ProgrammedId
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup.
func (*NetworkInstance_Afts_NextHopGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_Condition represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition YANG schema element.
type NetworkInstance_Afts_NextHopGroup_Condition struct {
	Dscp           []uint8                                                                `path:"state/dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	Id             *uint64                                                                `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	InputInterface map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface `path:"input-interfaces/input-interface" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup   *uint64                                                                `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_Condition implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_Condition) IsYANGGoStruct() {}

// NewInputInterface creates a new entry in the InputInterface list of the
// NetworkInstance_Afts_NextHopGroup_Condition struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) NewInputInterface(Id string) (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InputInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InputInterface", key)
	}

	t.InputInterface[key] = &NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{
		Id: &Id,
	}

	return t.InputInterface[key], nil
}

// RenameInputInterface renames an entry in the list InputInterface within
// the NetworkInstance_Afts_NextHopGroup_Condition struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) RenameInputInterface(oldK, newK string) error {
	if _, ok := t.InputInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in InputInterface", newK)
	}

	e, ok := t.InputInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InputInterface", oldK)
	}
	e.Id = &newK

	t.InputInterface[newK] = e
	delete(t.InputInterface, oldK)
	return nil
}

// GetOrCreateInputInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup_Condition. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetOrCreateInputInterface(Id string) *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {

	key := Id

	if v, ok := t.InputInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInputInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInputInterface got unexpected error: %v", err))
	}
	return v
}

// GetInputInterface retrieves the value with the specified key from
// the InputInterface map field of NetworkInstance_Afts_NextHopGroup_Condition. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetInputInterface(Id string) *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.InputInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInputInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup_Condition. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) DeleteInputInterface(Id string) {
	key := Id

	delete(t.InputInterface, key)
}

// AppendInputInterface appends the supplied NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct to the
// list InputInterface of NetworkInstance_Afts_NextHopGroup_Condition. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_Condition_InputInterface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) AppendInputInterface(v *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}

	if _, ok := t.InputInterface[key]; ok {
		return fmt.Errorf("duplicate key for list InputInterface %v", key)
	}

	t.InputInterface[key] = v
	return nil
}

// GetDscp retrieves the value of the leaf Dscp from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetDscp() []uint8 {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_Condition struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_Condition"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_Condition.
func (*NetworkInstance_Afts_NextHopGroup_Condition) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_Condition_InputInterface represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface YANG schema element.
type NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct {
	Id           *string `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_Condition_InputInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_Condition_InputInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_Condition_InputInterface.
func (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_NextHop represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop YANG schema element.
type NetworkInstance_Afts_NextHopGroup_NextHop struct {
	Index  *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Weight *uint64 `path:"state/weight" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetWeight retrieves the value of the leaf Weight from the NetworkInstance_Afts_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) GetWeight() uint64 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_NextHop.
func (*NetworkInstance_Afts_NextHopGroup_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/counters YANG schema element.
type NetworkInstance_Afts_NextHop_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_NextHop_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_NextHop_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_Counters.
func (*NetworkInstance_Afts_NextHop_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref YANG schema element.
type NetworkInstance_Afts_NextHop_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Afts_NextHop_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Afts_NextHop_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_InterfaceRef.
func (*NetworkInstance_Afts_NextHop_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_IpInIp represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip YANG schema element.
type NetworkInstance_Afts_NextHop_IpInIp struct {
	DstIp *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_IpInIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_IpInIp) IsYANGGoStruct() {}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_IpInIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_IpInIp) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_IpInIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_IpInIp) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_IpInIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_IpInIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_IpInIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_IpInIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_IpInIp.
func (*NetworkInstance_Afts_NextHop_IpInIp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_PolicyForwardingEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry YANG schema element.
type NetworkInstance_Afts_PolicyForwardingEntry struct {
	Counters      *NetworkInstance_Afts_PolicyForwardingEntry_Counters        `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata Binary                                                      `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	Index         *uint64                                                     `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	IpDscp        *uint8                                                      `path:"state/ip-dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	IpPrefix      *string                                                     `path:"state/ip-prefix" module:"openconfig-network-instance/openconfig-network-instance"`
	IpProtocol    NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union `path:"state/ip-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	L4DstPort     *uint16                                                     `path:"state/l4-dst-port" module:"openconfig-network-instance/openconfig-network-instance"`
	L4SrcPort     *uint16                                                     `path:"state/l4-src-port" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress    *string                                                     `path:"state/mac-address" module:"openconfig-network-instance/openconfig-network-instance"`
	MplsLabel     NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union  `path:"state/mpls-label" module:"openconfig-network-instance/openconfig-network-instance"`
	MplsTc        *uint8                                                      `path:"state/mpls-tc" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_PolicyForwardingEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_PolicyForwardingEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetOrCreateCounters() *NetworkInstance_Afts_PolicyForwardingEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_PolicyForwardingEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_PolicyForwardingEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetCounters() *NetworkInstance_Afts_PolicyForwardingEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpDscp retrieves the value of the leaf IpDscp from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpDscp is set, it can
// safely use t.GetIpDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpDscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpDscp() uint8 {
	if t == nil || t.IpDscp == nil {
		return 0
	}
	return *t.IpDscp
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetIpProtocol retrieves the value of the leaf IpProtocol from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpProtocol is set, it can
// safely use t.GetIpProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpProtocol() NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	if t == nil || t.IpProtocol == nil {
		return nil
	}
	return t.IpProtocol
}

// GetL4DstPort retrieves the value of the leaf L4DstPort from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L4DstPort is set, it can
// safely use t.GetL4DstPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L4DstPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetL4DstPort() uint16 {
	if t == nil || t.L4DstPort == nil {
		return 0
	}
	return *t.L4DstPort
}

// GetL4SrcPort retrieves the value of the leaf L4SrcPort from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L4SrcPort is set, it can
// safely use t.GetL4SrcPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L4SrcPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetL4SrcPort() uint16 {
	if t == nil || t.L4SrcPort == nil {
		return 0
	}
	return *t.L4SrcPort
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetMplsLabel retrieves the value of the leaf MplsLabel from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabel is set, it can
// safely use t.GetMplsLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMplsLabel() NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	if t == nil || t.MplsLabel == nil {
		return nil
	}
	return t.MplsLabel
}

// GetMplsTc retrieves the value of the leaf MplsTc from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsTc is set, it can
// safely use t.GetMplsTc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsTc == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMplsTc() uint8 {
	if t == nil || t.MplsTc == nil {
		return 0
	}
	return *t.MplsTc
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_PolicyForwardingEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_PolicyForwardingEntry.
func (*NetworkInstance_Afts_PolicyForwardingEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_PolicyForwardingEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/counters YANG schema element.
type NetworkInstance_Afts_PolicyForwardingEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_PolicyForwardingEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_PolicyForwardingEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_PolicyForwardingEntry_Counters.
func (*NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_StateSynced represents the /openconfig-network-instance/network-instances/network-instance/afts/state-synced YANG schema element.
type NetworkInstance_Afts_StateSynced struct {
	Ipv4Unicast *bool `path:"state/ipv4-unicast" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv6Unicast *bool `path:"state/ipv6-unicast" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_StateSynced implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_StateSynced) IsYANGGoStruct() {}

// GetIpv4Unicast retrieves the value of the leaf Ipv4Unicast from the NetworkInstance_Afts_StateSynced
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Unicast is set, it can
// safely use t.GetIpv4Unicast() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Unicast == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_StateSynced) GetIpv4Unicast() bool {
	if t == nil || t.Ipv4Unicast == nil {
		return false
	}
	return *t.Ipv4Unicast
}

// GetIpv6Unicast retrieves the value of the leaf Ipv6Unicast from the NetworkInstance_Afts_StateSynced
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Unicast is set, it can
// safely use t.GetIpv6Unicast() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Unicast == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_StateSynced) GetIpv6Unicast() bool {
	if t == nil || t.Ipv6Unicast == nil {
		return false
	}
	return *t.Ipv6Unicast
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_StateSynced) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_StateSynced"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_StateSynced) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_StateSynced) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_StateSynced.
func (*NetworkInstance_Afts_StateSynced) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point YANG schema element.
type NetworkInstance_ConnectionPoint struct {
	ConnectionPointId *string                                              `path:"config/connection-point-id|connection-point-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/connection-point-id|connection-point-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Endpoint          map[string]*NetworkInstance_ConnectionPoint_Endpoint `path:"endpoints/endpoint" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint) IsYANGGoStruct() {}

// NewEndpoint creates a new entry in the Endpoint list of the
// NetworkInstance_ConnectionPoint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint) NewEndpoint(EndpointId string) (*NetworkInstance_ConnectionPoint_Endpoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	key := EndpointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Endpoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Endpoint", key)
	}

	t.Endpoint[key] = &NetworkInstance_ConnectionPoint_Endpoint{
		EndpointId: &EndpointId,
	}

	return t.Endpoint[key], nil
}

// RenameEndpoint renames an entry in the list Endpoint within
// the NetworkInstance_ConnectionPoint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint) RenameEndpoint(oldK, newK string) error {
	if _, ok := t.Endpoint[newK]; ok {
		return fmt.Errorf("key %v already exists in Endpoint", newK)
	}

	e, ok := t.Endpoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Endpoint", oldK)
	}
	e.EndpointId = &newK

	t.Endpoint[newK] = e
	delete(t.Endpoint, oldK)
	return nil
}

// GetOrCreateEndpoint retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint) GetOrCreateEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	key := EndpointId

	if v, ok := t.Endpoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpoint(EndpointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpoint got unexpected error: %v", err))
	}
	return v
}

// GetEndpoint retrieves the value with the specified key from
// the Endpoint map field of NetworkInstance_ConnectionPoint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint) GetEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	if t == nil {
		return nil
	}

	key := EndpointId

	if lm, ok := t.Endpoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpoint deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint) DeleteEndpoint(EndpointId string) {
	key := EndpointId

	delete(t.Endpoint, key)
}

// AppendEndpoint appends the supplied NetworkInstance_ConnectionPoint_Endpoint struct to the
// list Endpoint of NetworkInstance_ConnectionPoint. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint) AppendEndpoint(v *NetworkInstance_ConnectionPoint_Endpoint) error {
	if v.EndpointId == nil {
		return fmt.Errorf("invalid nil key received for EndpointId")
	}

	key := *v.EndpointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	if _, ok := t.Endpoint[key]; ok {
		return fmt.Errorf("duplicate key for list Endpoint %v", key)
	}

	t.Endpoint[key] = v
	return nil
}

// GetConnectionPointId retrieves the value of the leaf ConnectionPointId from the NetworkInstance_ConnectionPoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConnectionPointId is set, it can
// safely use t.GetConnectionPointId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConnectionPointId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint) GetConnectionPointId() string {
	if t == nil || t.ConnectionPointId == nil {
		return ""
	}
	return *t.ConnectionPointId
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConnectionPointId == nil {
		return nil, fmt.Errorf("nil value for key ConnectionPointId")
	}

	return map[string]interface{}{
		"connection-point-id": *t.ConnectionPointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint.
func (*NetworkInstance_ConnectionPoint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint struct {
	Active     *bool                                            `path:"state/active" module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointId *string                                          `path:"config/endpoint-id|endpoint-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/endpoint-id|endpoint-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Local      *NetworkInstance_ConnectionPoint_Endpoint_Local  `path:"local" module:"openconfig-network-instance"`
	Precedence *uint16                                          `path:"config/precedence" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/precedence" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Remote     *NetworkInstance_ConnectionPoint_Endpoint_Remote `path:"remote" module:"openconfig-network-instance"`
	Type       E_NetworkInstanceTypes_ENDPOINT_TYPE             `path:"config/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vxlan      *NetworkInstance_ConnectionPoint_Endpoint_Vxlan  `path:"vxlan" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint) IsYANGGoStruct() {}

// GetOrCreateLocal retrieves the value of the Local field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t.Local != nil {
		return t.Local
	}
	t.Local = &NetworkInstance_ConnectionPoint_Endpoint_Local{}
	return t.Local
}

// GetOrCreateRemote retrieves the value of the Remote field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t.Remote != nil {
		return t.Remote
	}
	t.Remote = &NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	return t.Remote
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateVxlan() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	return t.Vxlan
}

// GetLocal returns the value of the Local struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Local is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t != nil && t.Local != nil {
		return t.Local
	}
	return nil
}

// GetRemote returns the value of the Remote struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Remote is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t != nil && t.Remote != nil {
		return t.Remote
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetVxlan() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetActive retrieves the value of the leaf Active from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Active is set, it can
// safely use t.GetActive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Active == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetActive() bool {
	if t == nil || t.Active == nil {
		return false
	}
	return *t.Active
}

// GetEndpointId retrieves the value of the leaf EndpointId from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndpointId is set, it can
// safely use t.GetEndpointId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndpointId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetEndpointId() string {
	if t == nil || t.EndpointId == nil {
		return ""
	}
	return *t.EndpointId
}

// GetPrecedence retrieves the value of the leaf Precedence from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetPrecedence() uint16 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetType() E_NetworkInstanceTypes_ENDPOINT_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.EndpointId == nil {
		return nil, fmt.Errorf("nil value for key EndpointId")
	}

	return map[string]interface{}{
		"endpoint-id": *t.EndpointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint.
func (*NetworkInstance_ConnectionPoint_Endpoint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Local represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Local struct {
	Interface            *string `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteId               *uint16 `path:"config/site-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/site-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteLabelBlockOffset *uint16 `path:"config/site-label-block-offset" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/site-label-block-offset" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteLabelBlockSize   *uint16 `path:"config/site-label-block-size" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/site-label-block-size" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface         *uint32 `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Local implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Local) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSiteId retrieves the value of the leaf SiteId from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteId is set, it can
// safely use t.GetSiteId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteId() uint16 {
	if t == nil || t.SiteId == nil {
		return 0
	}
	return *t.SiteId
}

// GetSiteLabelBlockOffset retrieves the value of the leaf SiteLabelBlockOffset from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteLabelBlockOffset is set, it can
// safely use t.GetSiteLabelBlockOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteLabelBlockOffset == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteLabelBlockOffset() uint16 {
	if t == nil || t.SiteLabelBlockOffset == nil {
		return 0
	}
	return *t.SiteLabelBlockOffset
}

// GetSiteLabelBlockSize retrieves the value of the leaf SiteLabelBlockSize from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteLabelBlockSize is set, it can
// safely use t.GetSiteLabelBlockSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteLabelBlockSize == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteLabelBlockSize() uint16 {
	if t == nil || t.SiteLabelBlockSize == nil {
		return 0
	}
	return *t.SiteLabelBlockSize
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Local"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Local.
func (*NetworkInstance_ConnectionPoint_Endpoint_Local) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Remote represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Remote struct {
	RemoteSystem             *string `path:"config/remote-system" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/remote-system" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteId                   *uint16 `path:"config/site-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/site-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	VirtualCircuitIdentifier *uint32 `path:"config/virtual-circuit-identifier" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/virtual-circuit-identifier" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Remote implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Remote) IsYANGGoStruct() {}

// GetRemoteSystem retrieves the value of the leaf RemoteSystem from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteSystem is set, it can
// safely use t.GetRemoteSystem() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteSystem == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetRemoteSystem() string {
	if t == nil || t.RemoteSystem == nil {
		return ""
	}
	return *t.RemoteSystem
}

// GetSiteId retrieves the value of the leaf SiteId from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteId is set, it can
// safely use t.GetSiteId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetSiteId() uint16 {
	if t == nil || t.SiteId == nil {
		return 0
	}
	return *t.SiteId
}

// GetVirtualCircuitIdentifier retrieves the value of the leaf VirtualCircuitIdentifier from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualCircuitIdentifier is set, it can
// safely use t.GetVirtualCircuitIdentifier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualCircuitIdentifier == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetVirtualCircuitIdentifier() uint32 {
	if t == nil || t.VirtualCircuitIdentifier == nil {
		return 0
	}
	return *t.VirtualCircuitIdentifier
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Remote"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Remote.
func (*NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct {
	Description     *string                                                                 `path:"config/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled         *bool                                                                   `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointPeer    map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer `path:"endpoint-peers/endpoint-peer" module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointVni     map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni  `path:"endpoint-vnis/endpoint-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	SourceInterface *string                                                                 `path:"config/source-interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/source-interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan) IsYANGGoStruct() {}

// NewEndpointPeer creates a new entry in the EndpointPeer list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewEndpointPeer(PeerAddress string) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}

	key := PeerAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EndpointPeer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EndpointPeer", key)
	}

	t.EndpointPeer[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer{
		PeerAddress: &PeerAddress,
	}

	return t.EndpointPeer[key], nil
}

// RenameEndpointPeer renames an entry in the list EndpointPeer within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameEndpointPeer(oldK, newK string) error {
	if _, ok := t.EndpointPeer[newK]; ok {
		return fmt.Errorf("key %v already exists in EndpointPeer", newK)
	}

	e, ok := t.EndpointPeer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EndpointPeer", oldK)
	}
	e.PeerAddress = &newK

	t.EndpointPeer[newK] = e
	delete(t.EndpointPeer, oldK)
	return nil
}

// GetOrCreateEndpointPeer retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointPeer(PeerAddress string) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {

	key := PeerAddress

	if v, ok := t.EndpointPeer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpointPeer(PeerAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpointPeer got unexpected error: %v", err))
	}
	return v
}

// GetEndpointPeer retrieves the value with the specified key from
// the EndpointPeer map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEndpointPeer(PeerAddress string) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {

	if t == nil {
		return nil
	}

	key := PeerAddress

	if lm, ok := t.EndpointPeer[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpointPeer deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteEndpointPeer(PeerAddress string) {
	key := PeerAddress

	delete(t.EndpointPeer, key)
}

// AppendEndpointPeer appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct to the
// list EndpointPeer of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendEndpointPeer(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) error {
	if v.PeerAddress == nil {
		return fmt.Errorf("invalid nil key received for PeerAddress")
	}

	key := *v.PeerAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}

	if _, ok := t.EndpointPeer[key]; ok {
		return fmt.Errorf("duplicate key for list EndpointPeer %v", key)
	}

	t.EndpointPeer[key] = v
	return nil
}

// NewEndpointVni creates a new entry in the EndpointVni list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewEndpointVni(Vni uint32) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}

	key := Vni

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EndpointVni[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EndpointVni", key)
	}

	t.EndpointVni[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni{
		Vni: &Vni,
	}

	return t.EndpointVni[key], nil
}

// RenameEndpointVni renames an entry in the list EndpointVni within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameEndpointVni(oldK, newK uint32) error {
	if _, ok := t.EndpointVni[newK]; ok {
		return fmt.Errorf("key %v already exists in EndpointVni", newK)
	}

	e, ok := t.EndpointVni[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EndpointVni", oldK)
	}
	e.Vni = &newK

	t.EndpointVni[newK] = e
	delete(t.EndpointVni, oldK)
	return nil
}

// GetOrCreateEndpointVni retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {

	key := Vni

	if v, ok := t.EndpointVni[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpointVni(Vni)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpointVni got unexpected error: %v", err))
	}
	return v
}

// GetEndpointVni retrieves the value with the specified key from
// the EndpointVni map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {

	if t == nil {
		return nil
	}

	key := Vni

	if lm, ok := t.EndpointVni[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpointVni deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteEndpointVni(Vni uint32) {
	key := Vni

	delete(t.EndpointVni, key)
}

// AppendEndpointVni appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct to the
// list EndpointVni of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendEndpointVni(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) error {
	if v.Vni == nil {
		return fmt.Errorf("invalid nil key received for Vni")
	}

	key := *v.Vni

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}

	if _, ok := t.EndpointVni[key]; ok {
		return fmt.Errorf("duplicate key for list EndpointVni %v", key)
	}

	t.EndpointVni[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetSourceInterface retrieves the value of the leaf SourceInterface from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceInterface is set, it can
// safely use t.GetSourceInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceInterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetSourceInterface() string {
	if t == nil || t.SourceInterface == nil {
		return ""
	}
	return *t.SourceInterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-peers/endpoint-peer YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct {
	ControlPlaneVnis *string                       `path:"state/control-plane-vnis" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerAddress      *string                       `path:"state/peer-address|peer-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"peer-address" shadow-module:"openconfig-network-instance"`
	PeerState        E_Evpn_EndpointPeer_PeerState `path:"state/peer-state" module:"openconfig-network-instance/openconfig-network-instance"`
	RouterMac        *string                       `path:"state/router-mac" module:"openconfig-network-instance/openconfig-network-instance"`
	Uptime           *uint64                       `path:"state/uptime" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) IsYANGGoStruct() {}

// GetControlPlaneVnis retrieves the value of the leaf ControlPlaneVnis from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlPlaneVnis is set, it can
// safely use t.GetControlPlaneVnis() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlPlaneVnis == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetControlPlaneVnis() string {
	if t == nil || t.ControlPlaneVnis == nil {
		return ""
	}
	return *t.ControlPlaneVnis
}

// GetPeerAddress retrieves the value of the leaf PeerAddress from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerAddress is set, it can
// safely use t.GetPeerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetPeerAddress() string {
	if t == nil || t.PeerAddress == nil {
		return ""
	}
	return *t.PeerAddress
}

// GetPeerState retrieves the value of the leaf PeerState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerState is set, it can
// safely use t.GetPeerState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetPeerState() E_Evpn_EndpointPeer_PeerState {
	if t == nil || t.PeerState == 0 {
		return 0
	}
	return t.PeerState
}

// GetRouterMac retrieves the value of the leaf RouterMac from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterMac is set, it can
// safely use t.GetRouterMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetRouterMac() string {
	if t == nil || t.RouterMac == nil {
		return ""
	}
	return *t.RouterMac
}

// GetUptime retrieves the value of the leaf Uptime from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uptime is set, it can
// safely use t.GetUptime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uptime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetUptime() uint64 {
	if t == nil || t.Uptime == nil {
		return 0
	}
	return *t.Uptime
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerAddress == nil {
		return nil, fmt.Errorf("nil value for key PeerAddress")
	}

	return map[string]interface{}{
		"peer-address": *t.PeerAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct {
	BridgeDomain            *uint32                                                                                  `path:"state/bridge-domain" module:"openconfig-network-instance/openconfig-network-instance"`
	L3VrfName               *string                                                                                  `path:"state/l3-vrf-name" module:"openconfig-network-instance/openconfig-network-instance"`
	LearningMode            E_EvpnTypes_LearningMode                                                                 `path:"state/learning-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	MultidestinationTraffic NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union `path:"state/multidestination-traffic" module:"openconfig-network-instance/openconfig-network-instance"`
	SviState                E_Evpn_EndpointVni_SviState                                                              `path:"state/svi-state" module:"openconfig-network-instance/openconfig-network-instance"`
	Vni                     *uint32                                                                                  `path:"state/vni|vni" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"vni" shadow-module:"openconfig-network-instance"`
	VniState                E_Evpn_EndpointVni_VniState                                                              `path:"state/vni-state" module:"openconfig-network-instance/openconfig-network-instance"`
	VniType                 E_Evpn_EndpointVni_VniType                                                               `path:"state/vni-type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) IsYANGGoStruct() {}

// GetBridgeDomain retrieves the value of the leaf BridgeDomain from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BridgeDomain is set, it can
// safely use t.GetBridgeDomain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BridgeDomain == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetBridgeDomain() uint32 {
	if t == nil || t.BridgeDomain == nil {
		return 0
	}
	return *t.BridgeDomain
}

// GetL3VrfName retrieves the value of the leaf L3VrfName from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3VrfName is set, it can
// safely use t.GetL3VrfName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3VrfName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetL3VrfName() string {
	if t == nil || t.L3VrfName == nil {
		return ""
	}
	return *t.L3VrfName
}

// GetLearningMode retrieves the value of the leaf LearningMode from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearningMode is set, it can
// safely use t.GetLearningMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearningMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetLearningMode() E_EvpnTypes_LearningMode {
	if t == nil || t.LearningMode == 0 {
		return 0
	}
	return t.LearningMode
}

// GetMultidestinationTraffic retrieves the value of the leaf MultidestinationTraffic from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MultidestinationTraffic is set, it can
// safely use t.GetMultidestinationTraffic() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MultidestinationTraffic == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetMultidestinationTraffic() NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union {
	if t == nil || t.MultidestinationTraffic == nil {
		return nil
	}
	return t.MultidestinationTraffic
}

// GetSviState retrieves the value of the leaf SviState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SviState is set, it can
// safely use t.GetSviState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SviState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetSviState() E_Evpn_EndpointVni_SviState {
	if t == nil || t.SviState == 0 {
		return 0
	}
	return t.SviState
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// GetVniState retrieves the value of the leaf VniState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniState is set, it can
// safely use t.GetVniState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVniState() E_Evpn_EndpointVni_VniState {
	if t == nil || t.VniState == 0 {
		return 0
	}
	return t.VniState
}

// GetVniType retrieves the value of the leaf VniType from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniType is set, it can
// safely use t.GetVniType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVniType() E_Evpn_EndpointVni_VniType {
	if t == nil || t.VniType == 0 {
		return 0
	}
	return t.VniType
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Vni == nil {
		return nil, fmt.Errorf("nil value for key Vni")
	}

	return map[string]interface{}{
		"vni": *t.Vni,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Encapsulation represents the /openconfig-network-instance/network-instances/network-instance/encapsulation YANG schema element.
type NetworkInstance_Encapsulation struct {
	ControlWord         *bool                                        `path:"config/control-word" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/control-word" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulationType   E_NetworkInstanceTypes_ENCAPSULATION         `path:"config/encapsulation-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/encapsulation-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LabelAllocationMode E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE `path:"config/label-allocation-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/label-allocation-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Encapsulation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Encapsulation) IsYANGGoStruct() {}

// GetControlWord retrieves the value of the leaf ControlWord from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlWord is set, it can
// safely use t.GetControlWord() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlWord == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetControlWord() bool {
	if t == nil || t.ControlWord == nil {
		return false
	}
	return *t.ControlWord
}

// GetEncapsulationType retrieves the value of the leaf EncapsulationType from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulationType is set, it can
// safely use t.GetEncapsulationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetEncapsulationType() E_NetworkInstanceTypes_ENCAPSULATION {
	if t == nil || t.EncapsulationType == 0 {
		return 0
	}
	return t.EncapsulationType
}

// GetLabelAllocationMode retrieves the value of the leaf LabelAllocationMode from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelAllocationMode is set, it can
// safely use t.GetLabelAllocationMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelAllocationMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetLabelAllocationMode() E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	if t == nil || t.LabelAllocationMode == 0 {
		return 0
	}
	return t.LabelAllocationMode
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Encapsulation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Encapsulation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Encapsulation.
func (*NetworkInstance_Encapsulation) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn represents the /openconfig-network-instance/network-instances/network-instance/evpn YANG schema element.
type NetworkInstance_Evpn struct {
	EthernetSegment map[string]*NetworkInstance_Evpn_EthernetSegment `path:"ethernet-segments/ethernet-segment" module:"openconfig-network-instance/openconfig-network-instance"`
	EvpnInstance    map[string]*NetworkInstance_Evpn_EvpnInstance    `path:"evpn-instances/evpn-instance" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn) IsYANGGoStruct() {}

// NewEthernetSegment creates a new entry in the EthernetSegment list of the
// NetworkInstance_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn) NewEthernetSegment(Name string) (*NetworkInstance_Evpn_EthernetSegment, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EthernetSegment == nil {
		t.EthernetSegment = make(map[string]*NetworkInstance_Evpn_EthernetSegment)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EthernetSegment[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EthernetSegment", key)
	}

	t.EthernetSegment[key] = &NetworkInstance_Evpn_EthernetSegment{
		Name: &Name,
	}

	return t.EthernetSegment[key], nil
}

// RenameEthernetSegment renames an entry in the list EthernetSegment within
// the NetworkInstance_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn) RenameEthernetSegment(oldK, newK string) error {
	if _, ok := t.EthernetSegment[newK]; ok {
		return fmt.Errorf("key %v already exists in EthernetSegment", newK)
	}

	e, ok := t.EthernetSegment[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EthernetSegment", oldK)
	}
	e.Name = &newK

	t.EthernetSegment[newK] = e
	delete(t.EthernetSegment, oldK)
	return nil
}

// GetOrCreateEthernetSegment retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn) GetOrCreateEthernetSegment(Name string) *NetworkInstance_Evpn_EthernetSegment {

	key := Name

	if v, ok := t.EthernetSegment[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEthernetSegment(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEthernetSegment got unexpected error: %v", err))
	}
	return v
}

// GetEthernetSegment retrieves the value with the specified key from
// the EthernetSegment map field of NetworkInstance_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn) GetEthernetSegment(Name string) *NetworkInstance_Evpn_EthernetSegment {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.EthernetSegment[key]; ok {
		return lm
	}
	return nil
}

// DeleteEthernetSegment deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn) DeleteEthernetSegment(Name string) {
	key := Name

	delete(t.EthernetSegment, key)
}

// AppendEthernetSegment appends the supplied NetworkInstance_Evpn_EthernetSegment struct to the
// list EthernetSegment of NetworkInstance_Evpn. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EthernetSegment already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn) AppendEthernetSegment(v *NetworkInstance_Evpn_EthernetSegment) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EthernetSegment == nil {
		t.EthernetSegment = make(map[string]*NetworkInstance_Evpn_EthernetSegment)
	}

	if _, ok := t.EthernetSegment[key]; ok {
		return fmt.Errorf("duplicate key for list EthernetSegment %v", key)
	}

	t.EthernetSegment[key] = v
	return nil
}

// NewEvpnInstance creates a new entry in the EvpnInstance list of the
// NetworkInstance_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn) NewEvpnInstance(Evi string) (*NetworkInstance_Evpn_EvpnInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}

	key := Evi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EvpnInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EvpnInstance", key)
	}

	t.EvpnInstance[key] = &NetworkInstance_Evpn_EvpnInstance{
		Evi: &Evi,
	}

	return t.EvpnInstance[key], nil
}

// RenameEvpnInstance renames an entry in the list EvpnInstance within
// the NetworkInstance_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn) RenameEvpnInstance(oldK, newK string) error {
	if _, ok := t.EvpnInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in EvpnInstance", newK)
	}

	e, ok := t.EvpnInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EvpnInstance", oldK)
	}
	e.Evi = &newK

	t.EvpnInstance[newK] = e
	delete(t.EvpnInstance, oldK)
	return nil
}

// GetOrCreateEvpnInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn) GetOrCreateEvpnInstance(Evi string) *NetworkInstance_Evpn_EvpnInstance {

	key := Evi

	if v, ok := t.EvpnInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvpnInstance(Evi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvpnInstance got unexpected error: %v", err))
	}
	return v
}

// GetEvpnInstance retrieves the value with the specified key from
// the EvpnInstance map field of NetworkInstance_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn) GetEvpnInstance(Evi string) *NetworkInstance_Evpn_EvpnInstance {

	if t == nil {
		return nil
	}

	key := Evi

	if lm, ok := t.EvpnInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteEvpnInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn) DeleteEvpnInstance(Evi string) {
	key := Evi

	delete(t.EvpnInstance, key)
}

// AppendEvpnInstance appends the supplied NetworkInstance_Evpn_EvpnInstance struct to the
// list EvpnInstance of NetworkInstance_Evpn. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn) AppendEvpnInstance(v *NetworkInstance_Evpn_EvpnInstance) error {
	if v.Evi == nil {
		return fmt.Errorf("invalid nil key received for Evi")
	}

	key := *v.Evi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}

	if _, ok := t.EvpnInstance[key]; ok {
		return fmt.Errorf("duplicate key for list EvpnInstance %v", key)
	}

	t.EvpnInstance[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn.
func (*NetworkInstance_Evpn) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EthernetSegment represents the /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment YANG schema element.
type NetworkInstance_Evpn_EthernetSegment struct {
	DfElection     *NetworkInstance_Evpn_EthernetSegment_DfElection `path:"df-election" module:"openconfig-network-instance"`
	Esi            NetworkInstance_Evpn_EthernetSegment_Esi_Union   `path:"config/esi" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/esi" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EsiType        E_EvpnTypes_EsiType                              `path:"config/esi-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/esi-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Interface      *string                                          `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name           *string                                          `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	RedundancyMode E_EvpnTypes_EVPN_REDUNDANCY_MODE                 `path:"config/redundancy-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/redundancy-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface   *uint32                                          `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EthernetSegment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EthernetSegment) IsYANGGoStruct() {}

// GetOrCreateDfElection retrieves the value of the DfElection field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EthernetSegment) GetOrCreateDfElection() *NetworkInstance_Evpn_EthernetSegment_DfElection {
	if t.DfElection != nil {
		return t.DfElection
	}
	t.DfElection = &NetworkInstance_Evpn_EthernetSegment_DfElection{}
	return t.DfElection
}

// GetDfElection returns the value of the DfElection struct pointer
// from NetworkInstance_Evpn_EthernetSegment. If the receiver or the field DfElection is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EthernetSegment) GetDfElection() *NetworkInstance_Evpn_EthernetSegment_DfElection {
	if t != nil && t.DfElection != nil {
		return t.DfElection
	}
	return nil
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetEsi() NetworkInstance_Evpn_EthernetSegment_Esi_Union {
	if t == nil || t.Esi == nil {
		return nil
	}
	return t.Esi
}

// GetEsiType retrieves the value of the leaf EsiType from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsiType is set, it can
// safely use t.GetEsiType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsiType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetEsiType() E_EvpnTypes_EsiType {
	if t == nil || t.EsiType == 0 {
		return EvpnTypes_EsiType_TYPE_0_OPERATOR_CONFIGURED
	}
	return t.EsiType
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRedundancyMode retrieves the value of the leaf RedundancyMode from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedundancyMode is set, it can
// safely use t.GetRedundancyMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedundancyMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetRedundancyMode() E_EvpnTypes_EVPN_REDUNDANCY_MODE {
	if t == nil || t.RedundancyMode == 0 {
		return 0
	}
	return t.RedundancyMode
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EthernetSegment struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EthernetSegment) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EthernetSegment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EthernetSegment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EthernetSegment) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EthernetSegment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EthernetSegment.
func (*NetworkInstance_Evpn_EthernetSegment) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EthernetSegment_DfElection represents the /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election YANG schema element.
type NetworkInstance_Evpn_EthernetSegment_DfElection struct {
	DfElectionMethod E_Evpn_DfElection_DfElectionMethod `path:"config/df-election-method" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/df-election-method" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ElectionWaitTime *uint32                            `path:"config/election-wait-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/election-wait-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Preference       *uint16                            `path:"config/preference" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/preference" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Revertive        *bool                              `path:"config/revertive" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/revertive" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EthernetSegment_DfElection implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EthernetSegment_DfElection) IsYANGGoStruct() {}

// GetDfElectionMethod retrieves the value of the leaf DfElectionMethod from the NetworkInstance_Evpn_EthernetSegment_DfElection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DfElectionMethod is set, it can
// safely use t.GetDfElectionMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DfElectionMethod == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) GetDfElectionMethod() E_Evpn_DfElection_DfElectionMethod {
	if t == nil || t.DfElectionMethod == 0 {
		return 0
	}
	return t.DfElectionMethod
}

// GetElectionWaitTime retrieves the value of the leaf ElectionWaitTime from the NetworkInstance_Evpn_EthernetSegment_DfElection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ElectionWaitTime is set, it can
// safely use t.GetElectionWaitTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ElectionWaitTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) GetElectionWaitTime() uint32 {
	if t == nil || t.ElectionWaitTime == nil {
		return 0
	}
	return *t.ElectionWaitTime
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Evpn_EthernetSegment_DfElection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) GetPreference() uint16 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetRevertive retrieves the value of the leaf Revertive from the NetworkInstance_Evpn_EthernetSegment_DfElection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Revertive is set, it can
// safely use t.GetRevertive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Revertive == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) GetRevertive() bool {
	if t == nil || t.Revertive == nil {
		return true
	}
	return *t.Revertive
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EthernetSegment_DfElection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EthernetSegment_DfElection.
func (*NetworkInstance_Evpn_EthernetSegment_DfElection) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance YANG schema element.
type NetworkInstance_Evpn_EvpnInstance struct {
	BComponent         map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent   `path:"pbb/b-component" module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulationType  E_NetworkInstanceTypes_ENCAPSULATION                       `path:"config/encapsulation-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/encapsulation-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Evi                *string                                                    `path:"config/evi|evi" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/evi|evi" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ImportExportPolicy *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy      `path:"import-export-policy" module:"openconfig-network-instance"`
	MulticastGroup     *string                                                    `path:"config/multicast-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/multicast-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastMask      *string                                                    `path:"config/multicast-mask" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/multicast-mask" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReplicationMode    E_Evpn_EvpnInstance_ReplicationMode                        `path:"config/replication-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/replication-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RouteDistinguisher NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union `path:"config/route-distinguisher" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/route-distinguisher" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ServiceType        E_EvpnTypes_EVPN_TYPE                                      `path:"config/service-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/service-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vxlan              *NetworkInstance_Evpn_EvpnInstance_Vxlan                   `path:"vxlan" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance) IsYANGGoStruct() {}

// NewBComponent creates a new entry in the BComponent list of the
// NetworkInstance_Evpn_EvpnInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn_EvpnInstance) NewBComponent(BComponentName string) (*NetworkInstance_Evpn_EvpnInstance_BComponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}

	key := BComponentName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BComponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BComponent", key)
	}

	t.BComponent[key] = &NetworkInstance_Evpn_EvpnInstance_BComponent{
		BComponentName: &BComponentName,
	}

	return t.BComponent[key], nil
}

// RenameBComponent renames an entry in the list BComponent within
// the NetworkInstance_Evpn_EvpnInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn_EvpnInstance) RenameBComponent(oldK, newK string) error {
	if _, ok := t.BComponent[newK]; ok {
		return fmt.Errorf("key %v already exists in BComponent", newK)
	}

	e, ok := t.BComponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BComponent", oldK)
	}
	e.BComponentName = &newK

	t.BComponent[newK] = e
	delete(t.BComponent, oldK)
	return nil
}

// GetOrCreateBComponent retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateBComponent(BComponentName string) *NetworkInstance_Evpn_EvpnInstance_BComponent {

	key := BComponentName

	if v, ok := t.BComponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBComponent(BComponentName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBComponent got unexpected error: %v", err))
	}
	return v
}

// GetBComponent retrieves the value with the specified key from
// the BComponent map field of NetworkInstance_Evpn_EvpnInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetBComponent(BComponentName string) *NetworkInstance_Evpn_EvpnInstance_BComponent {

	if t == nil {
		return nil
	}

	key := BComponentName

	if lm, ok := t.BComponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteBComponent deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn_EvpnInstance) DeleteBComponent(BComponentName string) {
	key := BComponentName

	delete(t.BComponent, key)
}

// AppendBComponent appends the supplied NetworkInstance_Evpn_EvpnInstance_BComponent struct to the
// list BComponent of NetworkInstance_Evpn_EvpnInstance. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance_BComponent already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn_EvpnInstance) AppendBComponent(v *NetworkInstance_Evpn_EvpnInstance_BComponent) error {
	if v.BComponentName == nil {
		return fmt.Errorf("invalid nil key received for BComponentName")
	}

	key := *v.BComponentName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}

	if _, ok := t.BComponent[key]; ok {
		return fmt.Errorf("duplicate key for list BComponent %v", key)
	}

	t.BComponent[key] = v
	return nil
}

// GetOrCreateImportExportPolicy retrieves the value of the ImportExportPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateImportExportPolicy() *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	if t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	t.ImportExportPolicy = &NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	return t.ImportExportPolicy
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateVxlan() *NetworkInstance_Evpn_EvpnInstance_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	return t.Vxlan
}

// GetImportExportPolicy returns the value of the ImportExportPolicy struct pointer
// from NetworkInstance_Evpn_EvpnInstance. If the receiver or the field ImportExportPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetImportExportPolicy() *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	if t != nil && t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_Evpn_EvpnInstance. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetVxlan() *NetworkInstance_Evpn_EvpnInstance_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetEncapsulationType retrieves the value of the leaf EncapsulationType from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulationType is set, it can
// safely use t.GetEncapsulationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetEncapsulationType() E_NetworkInstanceTypes_ENCAPSULATION {
	if t == nil || t.EncapsulationType == 0 {
		return 0
	}
	return t.EncapsulationType
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetEvi() string {
	if t == nil || t.Evi == nil {
		return ""
	}
	return *t.Evi
}

// GetMulticastGroup retrieves the value of the leaf MulticastGroup from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastGroup is set, it can
// safely use t.GetMulticastGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetMulticastGroup() string {
	if t == nil || t.MulticastGroup == nil {
		return ""
	}
	return *t.MulticastGroup
}

// GetMulticastMask retrieves the value of the leaf MulticastMask from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastMask is set, it can
// safely use t.GetMulticastMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetMulticastMask() string {
	if t == nil || t.MulticastMask == nil {
		return ""
	}
	return *t.MulticastMask
}

// GetReplicationMode retrieves the value of the leaf ReplicationMode from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplicationMode is set, it can
// safely use t.GetReplicationMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplicationMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetReplicationMode() E_Evpn_EvpnInstance_ReplicationMode {
	if t == nil || t.ReplicationMode == 0 {
		return 0
	}
	return t.ReplicationMode
}

// GetRouteDistinguisher retrieves the value of the leaf RouteDistinguisher from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteDistinguisher is set, it can
// safely use t.GetRouteDistinguisher() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteDistinguisher == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetRouteDistinguisher() NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	if t == nil || t.RouteDistinguisher == nil {
		return nil
	}
	return t.RouteDistinguisher
}

// GetServiceType retrieves the value of the leaf ServiceType from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServiceType is set, it can
// safely use t.GetServiceType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServiceType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetServiceType() E_EvpnTypes_EVPN_TYPE {
	if t == nil || t.ServiceType == 0 {
		return 0
	}
	return t.ServiceType
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Evi == nil {
		return nil, fmt.Errorf("nil value for key Evi")
	}

	return map[string]interface{}{
		"evi": *t.Evi,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance.
func (*NetworkInstance_Evpn_EvpnInstance) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_BComponent represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_BComponent struct {
	BComponentName *string                                                             `path:"config/b-component-name|b-component-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/b-component-name|b-component-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	BackboneSrcMac *string                                                             `path:"config/backbone-src-mac" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/backbone-src-mac" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IComponent     map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent `path:"i-components/i-component" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_BComponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent) IsYANGGoStruct() {}

// NewIComponent creates a new entry in the IComponent list of the
// NetworkInstance_Evpn_EvpnInstance_BComponent struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) NewIComponent(ISid uint32) (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}

	key := ISid

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IComponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IComponent", key)
	}

	t.IComponent[key] = &NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
		ISid: &ISid,
	}

	return t.IComponent[key], nil
}

// RenameIComponent renames an entry in the list IComponent within
// the NetworkInstance_Evpn_EvpnInstance_BComponent struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) RenameIComponent(oldK, newK uint32) error {
	if _, ok := t.IComponent[newK]; ok {
		return fmt.Errorf("key %v already exists in IComponent", newK)
	}

	e, ok := t.IComponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IComponent", oldK)
	}
	e.ISid = &newK

	t.IComponent[newK] = e
	delete(t.IComponent, oldK)
	return nil
}

// GetOrCreateIComponent retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance_BComponent. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetOrCreateIComponent(ISid uint32) *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {

	key := ISid

	if v, ok := t.IComponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIComponent(ISid)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIComponent got unexpected error: %v", err))
	}
	return v
}

// GetIComponent retrieves the value with the specified key from
// the IComponent map field of NetworkInstance_Evpn_EvpnInstance_BComponent. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetIComponent(ISid uint32) *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {

	if t == nil {
		return nil
	}

	key := ISid

	if lm, ok := t.IComponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteIComponent deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance_BComponent. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) DeleteIComponent(ISid uint32) {
	key := ISid

	delete(t.IComponent, key)
}

// AppendIComponent appends the supplied NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct to the
// list IComponent of NetworkInstance_Evpn_EvpnInstance_BComponent. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) AppendIComponent(v *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) error {
	if v.ISid == nil {
		return fmt.Errorf("invalid nil key received for ISid")
	}

	key := *v.ISid

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}

	if _, ok := t.IComponent[key]; ok {
		return fmt.Errorf("duplicate key for list IComponent %v", key)
	}

	t.IComponent[key] = v
	return nil
}

// GetBComponentName retrieves the value of the leaf BComponentName from the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BComponentName is set, it can
// safely use t.GetBComponentName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BComponentName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetBComponentName() string {
	if t == nil || t.BComponentName == nil {
		return ""
	}
	return *t.BComponentName
}

// GetBackboneSrcMac retrieves the value of the leaf BackboneSrcMac from the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackboneSrcMac is set, it can
// safely use t.GetBackboneSrcMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackboneSrcMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetBackboneSrcMac() string {
	if t == nil || t.BackboneSrcMac == nil {
		return ""
	}
	return *t.BackboneSrcMac
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance_BComponent struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BComponentName == nil {
		return nil, fmt.Errorf("nil value for key BComponentName")
	}

	return map[string]interface{}{
		"b-component-name": *t.BComponentName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_BComponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_BComponent.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct {
	ISid *uint32 `path:"config/i-sid|i-sid" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/i-sid|i-sid" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) IsYANGGoStruct() {}

// GetISid retrieves the value of the leaf ISid from the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ISid is set, it can
// safely use t.GetISid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ISid == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) GetISid() uint32 {
	if t == nil || t.ISid == nil {
		return 0
	}
	return *t.ISid
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ISid == nil {
		return nil, fmt.Errorf("nil value for key ISid")
	}

	return map[string]interface{}{
		"i-sid": *t.ISid,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy struct {
	ExportRouteTarget []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union `path:"config/export-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/export-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportRouteTarget []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union `path:"config/import-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/import-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) IsYANGGoStruct() {}

// GetExportRouteTarget retrieves the value of the leaf ExportRouteTarget from the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportRouteTarget is set, it can
// safely use t.GetExportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) GetExportRouteTarget() []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union {
	if t == nil || t.ExportRouteTarget == nil {
		return nil
	}
	return t.ExportRouteTarget
}

// GetImportRouteTarget retrieves the value of the leaf ImportRouteTarget from the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportRouteTarget is set, it can
// safely use t.GetImportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) GetImportRouteTarget() []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union {
	if t == nil || t.ImportRouteTarget == nil {
		return nil
	}
	return t.ImportRouteTarget
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy.
func (*NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_Vxlan struct {
	AnycastSourceInterface         *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface `path:"anycast-source-interface" module:"openconfig-network-instance"`
	HostReachabilityBgp            *bool                                                           `path:"config/host-reachability-bgp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/host-reachability-bgp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastGroup                 *string                                                         `path:"config/multicast-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/multicast-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastMask                  *string                                                         `path:"config/multicast-mask" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/multicast-mask" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	OverlayEndpoint                *string                                                         `path:"config/overlay-endpoint" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/overlay-endpoint" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	OverlayEndpointNetworkInstance *string                                                         `path:"config/overlay-endpoint-network-instance" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/overlay-endpoint-network-instance" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vni                            *uint32                                                         `path:"config/vni" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/vni" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan) IsYANGGoStruct() {}

// GetOrCreateAnycastSourceInterface retrieves the value of the AnycastSourceInterface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOrCreateAnycastSourceInterface() *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	if t.AnycastSourceInterface != nil {
		return t.AnycastSourceInterface
	}
	t.AnycastSourceInterface = &NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	return t.AnycastSourceInterface
}

// GetAnycastSourceInterface returns the value of the AnycastSourceInterface struct pointer
// from NetworkInstance_Evpn_EvpnInstance_Vxlan. If the receiver or the field AnycastSourceInterface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetAnycastSourceInterface() *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	if t != nil && t.AnycastSourceInterface != nil {
		return t.AnycastSourceInterface
	}
	return nil
}

// GetHostReachabilityBgp retrieves the value of the leaf HostReachabilityBgp from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostReachabilityBgp is set, it can
// safely use t.GetHostReachabilityBgp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostReachabilityBgp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetHostReachabilityBgp() bool {
	if t == nil || t.HostReachabilityBgp == nil {
		return false
	}
	return *t.HostReachabilityBgp
}

// GetMulticastGroup retrieves the value of the leaf MulticastGroup from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastGroup is set, it can
// safely use t.GetMulticastGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetMulticastGroup() string {
	if t == nil || t.MulticastGroup == nil {
		return ""
	}
	return *t.MulticastGroup
}

// GetMulticastMask retrieves the value of the leaf MulticastMask from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastMask is set, it can
// safely use t.GetMulticastMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetMulticastMask() string {
	if t == nil || t.MulticastMask == nil {
		return ""
	}
	return *t.MulticastMask
}

// GetOverlayEndpoint retrieves the value of the leaf OverlayEndpoint from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverlayEndpoint is set, it can
// safely use t.GetOverlayEndpoint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverlayEndpoint == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOverlayEndpoint() string {
	if t == nil || t.OverlayEndpoint == nil {
		return ""
	}
	return *t.OverlayEndpoint
}

// GetOverlayEndpointNetworkInstance retrieves the value of the leaf OverlayEndpointNetworkInstance from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverlayEndpointNetworkInstance is set, it can
// safely use t.GetOverlayEndpointNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverlayEndpointNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOverlayEndpointNetworkInstance() string {
	if t == nil || t.OverlayEndpointNetworkInstance == nil {
		return ""
	}
	return *t.OverlayEndpointNetworkInstance
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_Vxlan.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface struct {
	Interface    *string `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb represents the /openconfig-network-instance/network-instances/network-instance/fdb YANG schema element.
type NetworkInstance_Fdb struct {
	AnycastGatewayMac             *string                          `path:"config/anycast-gateway-mac" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/anycast-gateway-mac" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ArpProxy                      *NetworkInstance_Fdb_ArpProxy    `path:"arp-proxy" module:"openconfig-network-instance"`
	FloodUnknownUnicastSupression *bool                            `path:"config/flood-unknown-unicast-supression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/flood-unknown-unicast-supression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	L2Rib                         *NetworkInstance_Fdb_L2Rib       `path:"l2rib" module:"openconfig-network-instance"`
	MacAgingTime                  *uint16                          `path:"config/mac-aging-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/mac-aging-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacLearning                   *bool                            `path:"config/mac-learning" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/mac-learning" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobility                   *NetworkInstance_Fdb_MacMobility `path:"mac-mobility" module:"openconfig-network-instance"`
	MacTable                      *NetworkInstance_Fdb_MacTable    `path:"mac-table" module:"openconfig-network-instance"`
	MaximumEntries                *uint16                          `path:"config/maximum-entries" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/maximum-entries" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NdProxy                       *NetworkInstance_Fdb_NdProxy     `path:"nd-proxy" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb) IsYANGGoStruct() {}

// GetOrCreateArpProxy retrieves the value of the ArpProxy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateArpProxy() *NetworkInstance_Fdb_ArpProxy {
	if t.ArpProxy != nil {
		return t.ArpProxy
	}
	t.ArpProxy = &NetworkInstance_Fdb_ArpProxy{}
	return t.ArpProxy
}

// GetOrCreateL2Rib retrieves the value of the L2Rib field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateL2Rib() *NetworkInstance_Fdb_L2Rib {
	if t.L2Rib != nil {
		return t.L2Rib
	}
	t.L2Rib = &NetworkInstance_Fdb_L2Rib{}
	return t.L2Rib
}

// GetOrCreateMacMobility retrieves the value of the MacMobility field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacMobility() *NetworkInstance_Fdb_MacMobility {
	if t.MacMobility != nil {
		return t.MacMobility
	}
	t.MacMobility = &NetworkInstance_Fdb_MacMobility{}
	return t.MacMobility
}

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacTable() *NetworkInstance_Fdb_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_MacTable{}
	return t.MacTable
}

// GetOrCreateNdProxy retrieves the value of the NdProxy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateNdProxy() *NetworkInstance_Fdb_NdProxy {
	if t.NdProxy != nil {
		return t.NdProxy
	}
	t.NdProxy = &NetworkInstance_Fdb_NdProxy{}
	return t.NdProxy
}

// GetArpProxy returns the value of the ArpProxy struct pointer
// from NetworkInstance_Fdb. If the receiver or the field ArpProxy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetArpProxy() *NetworkInstance_Fdb_ArpProxy {
	if t != nil && t.ArpProxy != nil {
		return t.ArpProxy
	}
	return nil
}

// GetL2Rib returns the value of the L2Rib struct pointer
// from NetworkInstance_Fdb. If the receiver or the field L2Rib is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetL2Rib() *NetworkInstance_Fdb_L2Rib {
	if t != nil && t.L2Rib != nil {
		return t.L2Rib
	}
	return nil
}

// GetMacMobility returns the value of the MacMobility struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacMobility is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacMobility() *NetworkInstance_Fdb_MacMobility {
	if t != nil && t.MacMobility != nil {
		return t.MacMobility
	}
	return nil
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacTable() *NetworkInstance_Fdb_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// GetNdProxy returns the value of the NdProxy struct pointer
// from NetworkInstance_Fdb. If the receiver or the field NdProxy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetNdProxy() *NetworkInstance_Fdb_NdProxy {
	if t != nil && t.NdProxy != nil {
		return t.NdProxy
	}
	return nil
}

// GetAnycastGatewayMac retrieves the value of the leaf AnycastGatewayMac from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGatewayMac is set, it can
// safely use t.GetAnycastGatewayMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGatewayMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetAnycastGatewayMac() string {
	if t == nil || t.AnycastGatewayMac == nil {
		return ""
	}
	return *t.AnycastGatewayMac
}

// GetFloodUnknownUnicastSupression retrieves the value of the leaf FloodUnknownUnicastSupression from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FloodUnknownUnicastSupression is set, it can
// safely use t.GetFloodUnknownUnicastSupression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FloodUnknownUnicastSupression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetFloodUnknownUnicastSupression() bool {
	if t == nil || t.FloodUnknownUnicastSupression == nil {
		return false
	}
	return *t.FloodUnknownUnicastSupression
}

// GetMacAgingTime retrieves the value of the leaf MacAgingTime from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAgingTime is set, it can
// safely use t.GetMacAgingTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAgingTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMacAgingTime() uint16 {
	if t == nil || t.MacAgingTime == nil {
		return 0
	}
	return *t.MacAgingTime
}

// GetMacLearning retrieves the value of the leaf MacLearning from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacLearning is set, it can
// safely use t.GetMacLearning() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacLearning == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMacLearning() bool {
	if t == nil || t.MacLearning == nil {
		return false
	}
	return *t.MacLearning
}

// GetMaximumEntries retrieves the value of the leaf MaximumEntries from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumEntries is set, it can
// safely use t.GetMaximumEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumEntries == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMaximumEntries() uint16 {
	if t == nil || t.MaximumEntries == nil {
		return 0
	}
	return *t.MaximumEntries
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb.
func (*NetworkInstance_Fdb) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_ArpProxy represents the /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy YANG schema element.
type NetworkInstance_Fdb_ArpProxy struct {
	ArpSuppression               *bool   `path:"config/arp-suppression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/arp-suppression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DuplicateIpDetectionInterval *uint16 `path:"config/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable                       *bool   `path:"config/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"config/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_ArpProxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_ArpProxy) IsYANGGoStruct() {}

// GetArpSuppression retrieves the value of the leaf ArpSuppression from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ArpSuppression is set, it can
// safely use t.GetArpSuppression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ArpSuppression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetArpSuppression() bool {
	if t == nil || t.ArpSuppression == nil {
		return false
	}
	return *t.ArpSuppression
}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_ArpProxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_ArpProxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_ArpProxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_ArpProxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_ArpProxy.
func (*NetworkInstance_Fdb_ArpProxy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib YANG schema element.
type NetworkInstance_Fdb_L2Rib struct {
	MacIpTable *NetworkInstance_Fdb_L2Rib_MacIpTable `path:"mac-ip-table" module:"openconfig-network-instance"`
	MacTable   *NetworkInstance_Fdb_L2Rib_MacTable   `path:"mac-table" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib) IsYANGGoStruct() {}

// GetOrCreateMacIpTable retrieves the value of the MacIpTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_L2Rib) GetOrCreateMacIpTable() *NetworkInstance_Fdb_L2Rib_MacIpTable {
	if t.MacIpTable != nil {
		return t.MacIpTable
	}
	t.MacIpTable = &NetworkInstance_Fdb_L2Rib_MacIpTable{}
	return t.MacIpTable
}

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_L2Rib) GetOrCreateMacTable() *NetworkInstance_Fdb_L2Rib_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_L2Rib_MacTable{}
	return t.MacTable
}

// GetMacIpTable returns the value of the MacIpTable struct pointer
// from NetworkInstance_Fdb_L2Rib. If the receiver or the field MacIpTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_L2Rib) GetMacIpTable() *NetworkInstance_Fdb_L2Rib_MacIpTable {
	if t != nil && t.MacIpTable != nil {
		return t.MacIpTable
	}
	return nil
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb_L2Rib. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_L2Rib) GetMacTable() *NetworkInstance_Fdb_L2Rib_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib.
func (*NetworkInstance_Fdb_L2Rib) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable struct {
	Entry   map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop                                       `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable) IsYANGGoStruct() {}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key represents the key for list Entry of element /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key struct {
	MacAddress string `path:"mac-address"`
	HostIp     string `path:"host-ip"`
}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewEntry(MacAddress string, HostIp string) (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_Entry{
		MacAddress: &MacAddress,
		HostIp:     &HostIp,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameEntry(oldK, newK NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.HostIp = &newK.HostIp

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateEntry(MacAddress string, HostIp string) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, HostIp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetEntry(MacAddress string, HostIp string) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteEntry(MacAddress string, HostIp string) {
	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendEntry(v *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key for MacAddress")
	}

	if v.HostIp == nil {
		return fmt.Errorf("invalid nil key for HostIp")
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: *v.MacAddress,
		HostIp:     *v.HostIp,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct {
	Evi        *uint32                                                                                      `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	HostIp     *string                                                                                      `path:"state/host-ip|host-ip" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"host-ip" shadow-module:"openconfig-network-instance"`
	L2Vni      *uint32                                                                                      `path:"state/l2-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	L3Vni      *uint32                                                                                      `path:"state/l3-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress *string                                                                                      `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
	Producer   map[E_NetworkInstance_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer `path:"producers/producer" module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan       *uint16                                                                                      `path:"state/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) IsYANGGoStruct() {}

// NewProducer creates a new entry in the Producer list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) NewProducer(Producer E_NetworkInstance_Producer_Producer) (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_NetworkInstance_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}

	key := Producer

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Producer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Producer", key)
	}

	t.Producer[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer{
		Producer: Producer,
	}

	return t.Producer[key], nil
}

// RenameProducer renames an entry in the list Producer within
// the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) RenameProducer(oldK, newK E_NetworkInstance_Producer_Producer) error {
	if _, ok := t.Producer[newK]; ok {
		return fmt.Errorf("key %v already exists in Producer", newK)
	}

	e, ok := t.Producer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Producer", oldK)
	}
	e.Producer = newK

	t.Producer[newK] = e
	delete(t.Producer, oldK)
	return nil
}

// GetOrCreateProducer retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetOrCreateProducer(Producer E_NetworkInstance_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {

	key := Producer

	if v, ok := t.Producer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProducer(Producer)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProducer got unexpected error: %v", err))
	}
	return v
}

// GetProducer retrieves the value with the specified key from
// the Producer map field of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetProducer(Producer E_NetworkInstance_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {

	if t == nil {
		return nil
	}

	key := Producer

	if lm, ok := t.Producer[key]; ok {
		return lm
	}
	return nil
}

// DeleteProducer deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) DeleteProducer(Producer E_NetworkInstance_Producer_Producer) {
	key := Producer

	delete(t.Producer, key)
}

// AppendProducer appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct to the
// list Producer of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) AppendProducer(v *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) error {
	key := v.Producer

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_NetworkInstance_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}

	if _, ok := t.Producer[key]; ok {
		return fmt.Errorf("duplicate key for list Producer %v", key)
	}

	t.Producer[key] = v
	return nil
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetHostIp retrieves the value of the leaf HostIp from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostIp is set, it can
// safely use t.GetHostIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetHostIp() string {
	if t == nil || t.HostIp == nil {
		return ""
	}
	return *t.HostIp
}

// GetL2Vni retrieves the value of the leaf L2Vni from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Vni is set, it can
// safely use t.GetL2Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetL2Vni() uint32 {
	if t == nil || t.L2Vni == nil {
		return 0
	}
	return *t.L2Vni
}

// GetL3Vni retrieves the value of the leaf L3Vni from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3Vni is set, it can
// safely use t.GetL3Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetL3Vni() uint32 {
	if t == nil || t.L3Vni == nil {
		return 0
	}
	return *t.L3Vni
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.HostIp == nil {
		return nil, fmt.Errorf("nil value for key HostIp")
	}

	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"host-ip":     *t.HostIp,
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/entries/entry/producers/producer YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct {
	Esi           *string                                  `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	MobilityState E_NetworkInstance_Producer_MobilityState `path:"state/mobility-state" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *uint64                                  `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Producer      E_NetworkInstance_Producer_Producer      `path:"state/producer|producer" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"producer" shadow-module:"openconfig-network-instance"`
	SeqNumber     *uint32                                  `path:"state/seq-number" module:"openconfig-network-instance/openconfig-network-instance"`
	Sticky        *bool                                    `path:"state/sticky" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) IsYANGGoStruct() {}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMobilityState retrieves the value of the leaf MobilityState from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MobilityState is set, it can
// safely use t.GetMobilityState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MobilityState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetMobilityState() E_NetworkInstance_Producer_MobilityState {
	if t == nil || t.MobilityState == 0 {
		return 0
	}
	return t.MobilityState
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetNextHop() uint64 {
	if t == nil || t.NextHop == nil {
		return 0
	}
	return *t.NextHop
}

// GetProducer retrieves the value of the leaf Producer from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Producer is set, it can
// safely use t.GetProducer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Producer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetProducer() E_NetworkInstance_Producer_Producer {
	if t == nil || t.Producer == 0 {
		return 0
	}
	return t.Producer
}

// GetSeqNumber retrieves the value of the leaf SeqNumber from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SeqNumber is set, it can
// safely use t.GetSeqNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SeqNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetSeqNumber() uint32 {
	if t == nil || t.SeqNumber == nil {
		return 0
	}
	return *t.SeqNumber
}

// GetSticky retrieves the value of the leaf Sticky from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sticky is set, it can
// safely use t.GetSticky() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sticky == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetSticky() bool {
	if t == nil || t.Sticky == nil {
		return false
	}
	return *t.Sticky
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"producer": t.Producer,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct {
	Index        *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Label        *uint32 `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerIp       *string `path:"state/peer-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetLabel() uint32 {
	if t == nil || t.Label == nil {
		return 0
	}
	return *t.Label
}

// GetPeerIp retrieves the value of the leaf PeerIp from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIp is set, it can
// safely use t.GetPeerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetPeerIp() string {
	if t == nil || t.PeerIp == nil {
		return ""
	}
	return *t.PeerIp
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable struct {
	Entry   map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry   `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewEntry(MacAddress string) (*NetworkInstance_Fdb_L2Rib_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_L2Rib_MacTable_Entry{
		MacAddress: &MacAddress,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameEntry(oldK, newK string) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateEntry(MacAddress string) *NetworkInstance_Fdb_L2Rib_MacTable_Entry {

	key := MacAddress

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetEntry(MacAddress string) *NetworkInstance_Fdb_L2Rib_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteEntry(MacAddress string) {
	key := MacAddress

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendEntry(v *NetworkInstance_Fdb_L2Rib_MacTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key received for MacAddress")
	}

	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable.
func (*NetworkInstance_Fdb_L2Rib_MacTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_Entry struct {
	Evi        *uint32                                                                                    `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	L2Vni      *uint32                                                                                    `path:"state/l2-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress *string                                                                                    `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
	Producer   map[E_NetworkInstance_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer `path:"producers/producer" module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan       *uint16                                                                                    `path:"state/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry) IsYANGGoStruct() {}

// NewProducer creates a new entry in the Producer list of the
// NetworkInstance_Fdb_L2Rib_MacTable_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) NewProducer(Producer E_NetworkInstance_Producer_Producer) (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_NetworkInstance_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}

	key := Producer

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Producer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Producer", key)
	}

	t.Producer[key] = &NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer{
		Producer: Producer,
	}

	return t.Producer[key], nil
}

// RenameProducer renames an entry in the list Producer within
// the NetworkInstance_Fdb_L2Rib_MacTable_Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) RenameProducer(oldK, newK E_NetworkInstance_Producer_Producer) error {
	if _, ok := t.Producer[newK]; ok {
		return fmt.Errorf("key %v already exists in Producer", newK)
	}

	e, ok := t.Producer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Producer", oldK)
	}
	e.Producer = newK

	t.Producer[newK] = e
	delete(t.Producer, oldK)
	return nil
}

// GetOrCreateProducer retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetOrCreateProducer(Producer E_NetworkInstance_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {

	key := Producer

	if v, ok := t.Producer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProducer(Producer)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProducer got unexpected error: %v", err))
	}
	return v
}

// GetProducer retrieves the value with the specified key from
// the Producer map field of NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetProducer(Producer E_NetworkInstance_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {

	if t == nil {
		return nil
	}

	key := Producer

	if lm, ok := t.Producer[key]; ok {
		return lm
	}
	return nil
}

// DeleteProducer deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_Entry. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) DeleteProducer(Producer E_NetworkInstance_Producer_Producer) {
	key := Producer

	delete(t.Producer, key)
}

// AppendProducer appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct to the
// list Producer of NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) AppendProducer(v *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) error {
	key := v.Producer

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_NetworkInstance_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}

	if _, ok := t.Producer[key]; ok {
		return fmt.Errorf("duplicate key for list Producer %v", key)
	}

	t.Producer[key] = v
	return nil
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetL2Vni retrieves the value of the leaf L2Vni from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Vni is set, it can
// safely use t.GetL2Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetL2Vni() uint32 {
	if t == nil || t.L2Vni == nil {
		return 0
	}
	return *t.L2Vni
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_Entry.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/entries/entry/producers/producer YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct {
	DerivedFromMacIp *bool                                    `path:"state/derived-from-mac-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	DirectlyReceived *bool                                    `path:"state/directly-received" module:"openconfig-network-instance/openconfig-network-instance"`
	Esi              *string                                  `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	MobilityState    E_NetworkInstance_Producer_MobilityState `path:"state/mobility-state" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop          *uint64                                  `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Producer         E_NetworkInstance_Producer_Producer      `path:"state/producer|producer" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"producer" shadow-module:"openconfig-network-instance"`
	SeqNumber        *uint32                                  `path:"state/seq-number" module:"openconfig-network-instance/openconfig-network-instance"`
	Sticky           *bool                                    `path:"state/sticky" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) IsYANGGoStruct() {}

// GetDerivedFromMacIp retrieves the value of the leaf DerivedFromMacIp from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DerivedFromMacIp is set, it can
// safely use t.GetDerivedFromMacIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DerivedFromMacIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetDerivedFromMacIp() bool {
	if t == nil || t.DerivedFromMacIp == nil {
		return false
	}
	return *t.DerivedFromMacIp
}

// GetDirectlyReceived retrieves the value of the leaf DirectlyReceived from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DirectlyReceived is set, it can
// safely use t.GetDirectlyReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DirectlyReceived == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetDirectlyReceived() bool {
	if t == nil || t.DirectlyReceived == nil {
		return false
	}
	return *t.DirectlyReceived
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMobilityState retrieves the value of the leaf MobilityState from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MobilityState is set, it can
// safely use t.GetMobilityState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MobilityState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetMobilityState() E_NetworkInstance_Producer_MobilityState {
	if t == nil || t.MobilityState == 0 {
		return 0
	}
	return t.MobilityState
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetNextHop() uint64 {
	if t == nil || t.NextHop == nil {
		return 0
	}
	return *t.NextHop
}

// GetProducer retrieves the value of the leaf Producer from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Producer is set, it can
// safely use t.GetProducer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Producer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetProducer() E_NetworkInstance_Producer_Producer {
	if t == nil || t.Producer == 0 {
		return 0
	}
	return t.Producer
}

// GetSeqNumber retrieves the value of the leaf SeqNumber from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SeqNumber is set, it can
// safely use t.GetSeqNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SeqNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetSeqNumber() uint32 {
	if t == nil || t.SeqNumber == nil {
		return 0
	}
	return *t.SeqNumber
}

// GetSticky retrieves the value of the leaf Sticky from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sticky is set, it can
// safely use t.GetSticky() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sticky == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetSticky() bool {
	if t == nil || t.Sticky == nil {
		return false
	}
	return *t.Sticky
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"producer": t.Producer,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct {
	Index        *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Label        *uint32 `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerIp       *string `path:"state/peer-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetLabel() uint32 {
	if t == nil || t.Label == nil {
		return 0
	}
	return *t.Label
}

// GetPeerIp retrieves the value of the leaf PeerIp from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIp is set, it can
// safely use t.GetPeerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetPeerIp() string {
	if t == nil || t.PeerIp == nil {
		return ""
	}
	return *t.PeerIp
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacMobility represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility YANG schema element.
type NetworkInstance_Fdb_MacMobility struct {
	DuplicateIpDetectionInterval *uint16 `path:"config/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"config/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobility                  *bool   `path:"config/mac-mobility" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/mac-mobility" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobilityThreshold         *uint8  `path:"config/mac-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/mac-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobilityWindow            *uint16 `path:"config/mac-mobility-window" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/mac-mobility-window" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacMobility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacMobility) IsYANGGoStruct() {}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// GetMacMobility retrieves the value of the leaf MacMobility from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobility is set, it can
// safely use t.GetMacMobility() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobility == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobility() bool {
	if t == nil || t.MacMobility == nil {
		return false
	}
	return *t.MacMobility
}

// GetMacMobilityThreshold retrieves the value of the leaf MacMobilityThreshold from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobilityThreshold is set, it can
// safely use t.GetMacMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobilityThreshold() uint8 {
	if t == nil || t.MacMobilityThreshold == nil {
		return 5
	}
	return *t.MacMobilityThreshold
}

// GetMacMobilityWindow retrieves the value of the leaf MacMobilityWindow from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobilityWindow is set, it can
// safely use t.GetMacMobilityWindow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobilityWindow == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobilityWindow() uint16 {
	if t == nil || t.MacMobilityWindow == nil {
		return 180
	}
	return *t.MacMobilityWindow
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacMobility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacMobility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacMobility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacMobility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacMobility.
func (*NetworkInstance_Fdb_MacMobility) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table YANG schema element.
type NetworkInstance_Fdb_MacTable struct {
	Entry map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable) IsYANGGoStruct() {}

// NetworkInstance_Fdb_MacTable_Entry_Key represents the key for list Entry of element /openconfig-network-instance/network-instances/network-instance/fdb/mac-table.
type NetworkInstance_Fdb_MacTable_Entry_Key struct {
	MacAddress string `path:"mac-address"`
	Vlan       uint16 `path:"vlan"`
}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_MacTable) NewEntry(MacAddress string, Vlan uint16) (*NetworkInstance_Fdb_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_MacTable_Entry{
		MacAddress: &MacAddress,
		Vlan:       &Vlan,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_MacTable) RenameEntry(oldK, newK NetworkInstance_Fdb_MacTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.Vlan = &newK.Vlan

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_MacTable) GetOrCreateEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, Vlan)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_MacTable) GetEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_MacTable) DeleteEntry(MacAddress string, Vlan uint16) {
	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_MacTable) AppendEntry(v *NetworkInstance_Fdb_MacTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key for MacAddress")
	}

	if v.Vlan == nil {
		return fmt.Errorf("invalid nil key for Vlan")
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: *v.MacAddress,
		Vlan:       *v.Vlan,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable.
func (*NetworkInstance_Fdb_MacTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry struct {
	Age        *uint64                                       `path:"state/age" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryType  E_NetworkInstance_Entry_EntryType             `path:"state/entry-type" module:"openconfig-network-instance/openconfig-network-instance"`
	Evi        *uint32                                       `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	Interface  *NetworkInstance_Fdb_MacTable_Entry_Interface `path:"interface" module:"openconfig-network-instance"`
	MacAddress *string                                       `path:"config/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/mac-address|mac-address" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Vlan       *uint16                                       `path:"config/vlan|vlan" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/vlan|vlan" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry) IsYANGGoStruct() {}

// GetOrCreateInterface retrieves the value of the Interface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetOrCreateInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t.Interface != nil {
		return t.Interface
	}
	t.Interface = &NetworkInstance_Fdb_MacTable_Entry_Interface{}
	return t.Interface
}

// GetInterface returns the value of the Interface struct pointer
// from NetworkInstance_Fdb_MacTable_Entry. If the receiver or the field Interface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t != nil && t.Interface != nil {
		return t.Interface
	}
	return nil
}

// GetAge retrieves the value of the leaf Age from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Age is set, it can
// safely use t.GetAge() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Age == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetAge() uint64 {
	if t == nil || t.Age == nil {
		return 0
	}
	return *t.Age
}

// GetEntryType retrieves the value of the leaf EntryType from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryType is set, it can
// safely use t.GetEntryType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetEntryType() E_NetworkInstance_Entry_EntryType {
	if t == nil || t.EntryType == 0 {
		return 0
	}
	return t.EntryType
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	if t.Vlan == nil {
		return nil, fmt.Errorf("nil value for key Vlan")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
		"vlan":        *t.Vlan,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry.
func (*NetworkInstance_Fdb_MacTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry_Interface represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry_Interface struct {
	InterfaceRef *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Fdb_MacTable_Entry_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry_Interface.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_NdProxy represents the /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy YANG schema element.
type NetworkInstance_Fdb_NdProxy struct {
	DuplicateIpDetectionInterval *uint16 `path:"config/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable                       *bool   `path:"config/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"config/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NdSuppression                *bool   `path:"config/nd-suppression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/nd-suppression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_NdProxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_NdProxy) IsYANGGoStruct() {}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// GetNdSuppression retrieves the value of the leaf NdSuppression from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NdSuppression is set, it can
// safely use t.GetNdSuppression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NdSuppression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetNdSuppression() bool {
	if t == nil || t.NdSuppression == nil {
		return false
	}
	return *t.NdSuppression
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_NdProxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_NdProxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_NdProxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_NdProxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_NdProxy.
func (*NetworkInstance_Fdb_NdProxy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies YANG schema element.
type NetworkInstance_InterInstancePolicies struct {
	ApplyPolicy        *NetworkInstance_InterInstancePolicies_ApplyPolicy        `path:"apply-policy" module:"openconfig-network-instance"`
	ImportExportPolicy *NetworkInstance_InterInstancePolicies_ImportExportPolicy `path:"import-export-policy" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies) IsYANGGoStruct() {}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateImportExportPolicy retrieves the value of the ImportExportPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateImportExportPolicy() *NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	if t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	t.ImportExportPolicy = &NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
	return t.ImportExportPolicy
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetImportExportPolicy returns the value of the ImportExportPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ImportExportPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetImportExportPolicy() *NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	if t != nil && t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies.
func (*NetworkInstance_InterInstancePolicies) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies_ApplyPolicy represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy YANG schema element.
type NetworkInstance_InterInstancePolicies_ApplyPolicy struct {
	DefaultExportPolicy E_RoutingPolicy_DefaultPolicyType `path:"config/default-export-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/default-export-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DefaultImportPolicy E_RoutingPolicy_DefaultPolicyType `path:"config/default-import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/default-import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ExportPolicy        []string                          `path:"config/export-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/export-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportPolicy        []string                          `path:"config/import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies_ApplyPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies_ApplyPolicy) IsYANGGoStruct() {}

// GetDefaultExportPolicy retrieves the value of the leaf DefaultExportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultExportPolicy is set, it can
// safely use t.GetDefaultExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultExportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetDefaultExportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultExportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultExportPolicy
}

// GetDefaultImportPolicy retrieves the value of the leaf DefaultImportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultImportPolicy is set, it can
// safely use t.GetDefaultImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetDefaultImportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultImportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultImportPolicy
}

// GetExportPolicy retrieves the value of the leaf ExportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportPolicy is set, it can
// safely use t.GetExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetExportPolicy() []string {
	if t == nil || t.ExportPolicy == nil {
		return nil
	}
	return t.ExportPolicy
}

// GetImportPolicy retrieves the value of the leaf ImportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportPolicy is set, it can
// safely use t.GetImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetImportPolicy() []string {
	if t == nil || t.ImportPolicy == nil {
		return nil
	}
	return t.ImportPolicy
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies_ApplyPolicy.
func (*NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies_ImportExportPolicy represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy YANG schema element.
type NetworkInstance_InterInstancePolicies_ImportExportPolicy struct {
	ExportRouteTarget []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union `path:"config/export-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/export-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportRouteTarget []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union `path:"config/import-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/import-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies_ImportExportPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies_ImportExportPolicy) IsYANGGoStruct() {}

// GetExportRouteTarget retrieves the value of the leaf ExportRouteTarget from the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportRouteTarget is set, it can
// safely use t.GetExportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) GetExportRouteTarget() []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union {
	if t == nil || t.ExportRouteTarget == nil {
		return nil
	}
	return t.ExportRouteTarget
}

// GetImportRouteTarget retrieves the value of the leaf ImportRouteTarget from the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportRouteTarget is set, it can
// safely use t.GetImportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) GetImportRouteTarget() []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union {
	if t == nil || t.ImportRouteTarget == nil {
		return nil
	}
	return t.ImportRouteTarget
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ImportExportPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies_ImportExportPolicy.
func (*NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Interface represents the /openconfig-network-instance/network-instances/network-instance/interfaces/interface YANG schema element.
type NetworkInstance_Interface struct {
	AssociatedAddressFamilies []E_Types_ADDRESS_FAMILY                      `path:"config/associated-address-families" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/associated-address-families" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Id                        *string                                       `path:"config/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/id|id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Interface                 *string                                       `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IrbAnycastGateway         E_NetworkInstance_Interface_IrbAnycastGateway `path:"config/irb-anycast-gateway" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/irb-anycast-gateway" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacPinning                *bool                                         `path:"config/mac-pinning" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/mac-pinning" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface              *uint32                                       `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Interface) IsYANGGoStruct() {}

// GetAssociatedAddressFamilies retrieves the value of the leaf AssociatedAddressFamilies from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedAddressFamilies is set, it can
// safely use t.GetAssociatedAddressFamilies() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedAddressFamilies == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetAssociatedAddressFamilies() []E_Types_ADDRESS_FAMILY {
	if t == nil || t.AssociatedAddressFamilies == nil {
		return nil
	}
	return t.AssociatedAddressFamilies
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetIrbAnycastGateway retrieves the value of the leaf IrbAnycastGateway from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IrbAnycastGateway is set, it can
// safely use t.GetIrbAnycastGateway() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IrbAnycastGateway == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetIrbAnycastGateway() E_NetworkInstance_Interface_IrbAnycastGateway {
	if t == nil || t.IrbAnycastGateway == 0 {
		return 0
	}
	return t.IrbAnycastGateway
}

// GetMacPinning retrieves the value of the leaf MacPinning from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacPinning is set, it can
// safely use t.GetMacPinning() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacPinning == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetMacPinning() bool {
	if t == nil || t.MacPinning == nil {
		return false
	}
	return *t.MacPinning
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// ΛListKeyMap returns the keys of the NetworkInstance_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Interface.
func (*NetworkInstance_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls represents the /openconfig-network-instance/network-instances/network-instance/mpls YANG schema element.
type NetworkInstance_Mpls struct {
	Global             *NetworkInstance_Mpls_Global               `path:"global" module:"openconfig-network-instance"`
	Interface          map[string]*NetworkInstance_Mpls_Interface `path:"te-interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Lsps               *NetworkInstance_Mpls_Lsps                 `path:"lsps" module:"openconfig-network-instance"`
	SignalingProtocols *NetworkInstance_Mpls_SignalingProtocols   `path:"signaling-protocols" module:"openconfig-network-instance"`
	TeGlobalAttributes *NetworkInstance_Mpls_TeGlobalAttributes   `path:"te-global-attributes" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Interface struct to the
// list Interface of NetworkInstance_Mpls. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls) AppendInterface(v *NetworkInstance_Mpls_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateGlobal() *NetworkInstance_Mpls_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_Global{}
	return t.Global
}

// GetOrCreateLsps retrieves the value of the Lsps field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateLsps() *NetworkInstance_Mpls_Lsps {
	if t.Lsps != nil {
		return t.Lsps
	}
	t.Lsps = &NetworkInstance_Mpls_Lsps{}
	return t.Lsps
}

// GetOrCreateSignalingProtocols retrieves the value of the SignalingProtocols field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	t.SignalingProtocols = &NetworkInstance_Mpls_SignalingProtocols{}
	return t.SignalingProtocols
}

// GetOrCreateTeGlobalAttributes retrieves the value of the TeGlobalAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	t.TeGlobalAttributes = &NetworkInstance_Mpls_TeGlobalAttributes{}
	return t.TeGlobalAttributes
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetGlobal() *NetworkInstance_Mpls_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetLsps returns the value of the Lsps struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Lsps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetLsps() *NetworkInstance_Mpls_Lsps {
	if t != nil && t.Lsps != nil {
		return t.Lsps
	}
	return nil
}

// GetSignalingProtocols returns the value of the SignalingProtocols struct pointer
// from NetworkInstance_Mpls. If the receiver or the field SignalingProtocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t != nil && t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	return nil
}

// GetTeGlobalAttributes returns the value of the TeGlobalAttributes struct pointer
// from NetworkInstance_Mpls. If the receiver or the field TeGlobalAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t != nil && t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls.
func (*NetworkInstance_Mpls) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global represents the /openconfig-network-instance/network-instances/network-instance/mpls/global YANG schema element.
type NetworkInstance_Mpls_Global struct {
	Interface          map[string]*NetworkInstance_Mpls_Global_Interface          `path:"interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	NullLabel          E_MplsTypes_NULL_LABEL_TYPE                                `path:"config/null-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/null-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PwEncapsulation    E_MplsTypes_PSEUDOWIRE_ENCAPSULATION                       `path:"config/pw-encapsulation" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/pw-encapsulation" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReservedLabelBlock map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock `path:"reserved-label-blocks/reserved-label-block" module:"openconfig-network-instance/openconfig-network-instance"`
	TtlPropagation     *bool                                                      `path:"config/ttl-propagation" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/ttl-propagation" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Global_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Global_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Global_Interface struct to the
// list Interface of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendInterface(v *NetworkInstance_Mpls_Global_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewReservedLabelBlock creates a new entry in the ReservedLabelBlock list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewReservedLabelBlock(LocalId string) (*NetworkInstance_Mpls_Global_ReservedLabelBlock, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ReservedLabelBlock[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ReservedLabelBlock", key)
	}

	t.ReservedLabelBlock[key] = &NetworkInstance_Mpls_Global_ReservedLabelBlock{
		LocalId: &LocalId,
	}

	return t.ReservedLabelBlock[key], nil
}

// RenameReservedLabelBlock renames an entry in the list ReservedLabelBlock within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameReservedLabelBlock(oldK, newK string) error {
	if _, ok := t.ReservedLabelBlock[newK]; ok {
		return fmt.Errorf("key %v already exists in ReservedLabelBlock", newK)
	}

	e, ok := t.ReservedLabelBlock[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ReservedLabelBlock", oldK)
	}
	e.LocalId = &newK

	t.ReservedLabelBlock[newK] = e
	delete(t.ReservedLabelBlock, oldK)
	return nil
}

// GetOrCreateReservedLabelBlock retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	key := LocalId

	if v, ok := t.ReservedLabelBlock[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewReservedLabelBlock(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateReservedLabelBlock got unexpected error: %v", err))
	}
	return v
}

// GetReservedLabelBlock retrieves the value with the specified key from
// the ReservedLabelBlock map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.ReservedLabelBlock[key]; ok {
		return lm
	}
	return nil
}

// DeleteReservedLabelBlock deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteReservedLabelBlock(LocalId string) {
	key := LocalId

	delete(t.ReservedLabelBlock, key)
}

// AppendReservedLabelBlock appends the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock struct to the
// list ReservedLabelBlock of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendReservedLabelBlock(v *NetworkInstance_Mpls_Global_ReservedLabelBlock) error {
	if v.LocalId == nil {
		return fmt.Errorf("invalid nil key received for LocalId")
	}

	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	if _, ok := t.ReservedLabelBlock[key]; ok {
		return fmt.Errorf("duplicate key for list ReservedLabelBlock %v", key)
	}

	t.ReservedLabelBlock[key] = v
	return nil
}

// GetNullLabel retrieves the value of the leaf NullLabel from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NullLabel is set, it can
// safely use t.GetNullLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NullLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetNullLabel() E_MplsTypes_NULL_LABEL_TYPE {
	if t == nil || t.NullLabel == 0 {
		return MplsTypes_NULL_LABEL_TYPE_IMPLICIT
	}
	return t.NullLabel
}

// GetPwEncapsulation retrieves the value of the leaf PwEncapsulation from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PwEncapsulation is set, it can
// safely use t.GetPwEncapsulation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PwEncapsulation == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetPwEncapsulation() E_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	if t == nil || t.PwEncapsulation == 0 {
		return 0
	}
	return t.PwEncapsulation
}

// GetTtlPropagation retrieves the value of the leaf TtlPropagation from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TtlPropagation is set, it can
// safely use t.GetTtlPropagation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TtlPropagation == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetTtlPropagation() bool {
	if t == nil || t.TtlPropagation == nil {
		return true
	}
	return *t.TtlPropagation
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global.
func (*NetworkInstance_Mpls_Global) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_Global_Interface struct {
	InterfaceId  *string                                             `path:"config/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef *NetworkInstance_Mpls_Global_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
	MplsEnabled  *bool                                               `path:"config/mpls-enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/mpls-enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Global_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Global_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_Global_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetMplsEnabled retrieves the value of the leaf MplsEnabled from the NetworkInstance_Mpls_Global_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsEnabled is set, it can
// safely use t.GetMplsEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsEnabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface) GetMplsEnabled() bool {
	if t == nil || t.MplsEnabled == nil {
		return false
	}
	return *t.MplsEnabled
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_Interface.
func (*NetworkInstance_Mpls_Global_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_Global_Interface_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_ReservedLabelBlock represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block YANG schema element.
type NetworkInstance_Mpls_Global_ReservedLabelBlock struct {
	LocalId    *string                                                         `path:"config/local-id|local-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/local-id|local-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	LowerBound NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union `path:"config/lower-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/lower-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpperBound NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union `path:"config/upper-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/upper-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_ReservedLabelBlock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_ReservedLabelBlock) IsYANGGoStruct() {}

// GetLocalId retrieves the value of the leaf LocalId from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalId is set, it can
// safely use t.GetLocalId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetLocalId() string {
	if t == nil || t.LocalId == nil {
		return ""
	}
	return *t.LocalId
}

// GetLowerBound retrieves the value of the leaf LowerBound from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowerBound is set, it can
// safely use t.GetLowerBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowerBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetLowerBound() NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	if t == nil || t.LowerBound == nil {
		return nil
	}
	return t.LowerBound
}

// GetUpperBound retrieves the value of the leaf UpperBound from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpperBound is set, it can
// safely use t.GetUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetUpperBound() NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	if t == nil || t.UpperBound == nil {
		return nil
	}
	return t.UpperBound
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_ReservedLabelBlock struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_ReservedLabelBlock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_ReservedLabelBlock.
func (*NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_Interface struct {
	AdminGroup           []string                                             `path:"config/admin-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/admin-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IgpFloodingBandwidth *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth `path:"igp-flooding-bandwidth" module:"openconfig-network-instance"`
	InterfaceId          *string                                              `path:"config/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef         *NetworkInstance_Mpls_Interface_InterfaceRef         `path:"interface-ref" module:"openconfig-network-instance"`
	SrlgMembership       []string                                             `path:"config/srlg-membership" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/srlg-membership" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TeMetric             *uint32                                              `path:"config/te-metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/te-metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface) IsYANGGoStruct() {}

// GetOrCreateIgpFloodingBandwidth retrieves the value of the IgpFloodingBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	t.IgpFloodingBandwidth = &NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	return t.IgpFloodingBandwidth
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetIgpFloodingBandwidth returns the value of the IgpFloodingBandwidth struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field IgpFloodingBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t != nil && t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetAdminGroup retrieves the value of the leaf AdminGroup from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroup is set, it can
// safely use t.GetAdminGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetAdminGroup() []string {
	if t == nil || t.AdminGroup == nil {
		return nil
	}
	return t.AdminGroup
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetSrlgMembership retrieves the value of the leaf SrlgMembership from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrlgMembership is set, it can
// safely use t.GetSrlgMembership() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrlgMembership == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetSrlgMembership() []string {
	if t == nil || t.SrlgMembership == nil {
		return nil
	}
	return t.SrlgMembership
}

// GetTeMetric retrieves the value of the leaf TeMetric from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TeMetric is set, it can
// safely use t.GetTeMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TeMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetTeMetric() uint32 {
	if t == nil || t.TeMetric == nil {
		return 0
	}
	return *t.TeMetric
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface.
func (*NetworkInstance_Mpls_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface_IgpFloodingBandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth YANG schema element.
type NetworkInstance_Mpls_Interface_IgpFloodingBandwidth struct {
	DeltaPercentage        *uint8                                             `path:"config/delta-percentage" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/delta-percentage" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DownThresholds         []uint8                                            `path:"config/down-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/down-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ThresholdSpecification E_Mpls_IgpFloodingBandwidth_ThresholdSpecification `path:"config/threshold-specification" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/threshold-specification" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ThresholdType          E_Mpls_IgpFloodingBandwidth_ThresholdType          `path:"config/threshold-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/threshold-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpDownThresholds       []uint8                                            `path:"config/up-down-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/up-down-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpThresholds           []uint8                                            `path:"config/up-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/up-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface_IgpFloodingBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) IsYANGGoStruct() {}

// GetDeltaPercentage retrieves the value of the leaf DeltaPercentage from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeltaPercentage is set, it can
// safely use t.GetDeltaPercentage() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeltaPercentage == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetDeltaPercentage() uint8 {
	if t == nil || t.DeltaPercentage == nil {
		return 0
	}
	return *t.DeltaPercentage
}

// GetDownThresholds retrieves the value of the leaf DownThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DownThresholds is set, it can
// safely use t.GetDownThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DownThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetDownThresholds() []uint8 {
	if t == nil || t.DownThresholds == nil {
		return nil
	}
	return t.DownThresholds
}

// GetThresholdSpecification retrieves the value of the leaf ThresholdSpecification from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdSpecification is set, it can
// safely use t.GetThresholdSpecification() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdSpecification == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetThresholdSpecification() E_Mpls_IgpFloodingBandwidth_ThresholdSpecification {
	if t == nil || t.ThresholdSpecification == 0 {
		return 0
	}
	return t.ThresholdSpecification
}

// GetThresholdType retrieves the value of the leaf ThresholdType from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdType is set, it can
// safely use t.GetThresholdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetThresholdType() E_Mpls_IgpFloodingBandwidth_ThresholdType {
	if t == nil || t.ThresholdType == 0 {
		return 0
	}
	return t.ThresholdType
}

// GetUpDownThresholds retrieves the value of the leaf UpDownThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpDownThresholds is set, it can
// safely use t.GetUpDownThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpDownThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetUpDownThresholds() []uint8 {
	if t == nil || t.UpDownThresholds == nil {
		return nil
	}
	return t.UpDownThresholds
}

// GetUpThresholds retrieves the value of the leaf UpThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpThresholds is set, it can
// safely use t.GetUpThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetUpThresholds() []uint8 {
	if t == nil || t.UpThresholds == nil {
		return nil
	}
	return t.UpThresholds
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_IgpFloodingBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface_IgpFloodingBandwidth.
func (*NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_Interface_InterfaceRef struct {
	Interface    *string `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps YANG schema element.
type NetworkInstance_Mpls_Lsps struct {
	ConstrainedPath   *NetworkInstance_Mpls_Lsps_ConstrainedPath      `path:"constrained-path" module:"openconfig-network-instance"`
	StaticLsp         map[string]*NetworkInstance_Mpls_Lsps_StaticLsp `path:"static-lsps/static-lsp" module:"openconfig-network-instance/openconfig-network-instance"`
	UnconstrainedPath *NetworkInstance_Mpls_Lsps_UnconstrainedPath    `path:"unconstrained-path" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps) IsYANGGoStruct() {}

// NewStaticLsp creates a new entry in the StaticLsp list of the
// NetworkInstance_Mpls_Lsps struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps) NewStaticLsp(Name string) (*NetworkInstance_Mpls_Lsps_StaticLsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticLsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticLsp", key)
	}

	t.StaticLsp[key] = &NetworkInstance_Mpls_Lsps_StaticLsp{
		Name: &Name,
	}

	return t.StaticLsp[key], nil
}

// RenameStaticLsp renames an entry in the list StaticLsp within
// the NetworkInstance_Mpls_Lsps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps) RenameStaticLsp(oldK, newK string) error {
	if _, ok := t.StaticLsp[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticLsp", newK)
	}

	e, ok := t.StaticLsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticLsp", oldK)
	}
	e.Name = &newK

	t.StaticLsp[newK] = e
	delete(t.StaticLsp, oldK)
	return nil
}

// GetOrCreateStaticLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	key := Name

	if v, ok := t.StaticLsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticLsp(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticLsp got unexpected error: %v", err))
	}
	return v
}

// GetStaticLsp retrieves the value with the specified key from
// the StaticLsp map field of NetworkInstance_Mpls_Lsps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.StaticLsp[key]; ok {
		return lm
	}
	return nil
}

// DeleteStaticLsp deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps) DeleteStaticLsp(Name string) {
	key := Name

	delete(t.StaticLsp, key)
}

// AppendStaticLsp appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp struct to the
// list StaticLsp of NetworkInstance_Mpls_Lsps. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps) AppendStaticLsp(v *NetworkInstance_Mpls_Lsps_StaticLsp) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	if _, ok := t.StaticLsp[key]; ok {
		return fmt.Errorf("duplicate key for list StaticLsp %v", key)
	}

	t.StaticLsp[key] = v
	return nil
}

// GetOrCreateConstrainedPath retrieves the value of the ConstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	t.ConstrainedPath = &NetworkInstance_Mpls_Lsps_ConstrainedPath{}
	return t.ConstrainedPath
}

// GetOrCreateUnconstrainedPath retrieves the value of the UnconstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	t.UnconstrainedPath = &NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	return t.UnconstrainedPath
}

// GetConstrainedPath returns the value of the ConstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field ConstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t != nil && t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	return nil
}

// GetUnconstrainedPath returns the value of the UnconstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field UnconstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t != nil && t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps.
func (*NetworkInstance_Mpls_Lsps) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath struct {
	NamedExplicitPath map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath `path:"named-explicit-paths/named-explicit-path" module:"openconfig-network-instance/openconfig-network-instance"`
	Tunnel            map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel            `path:"tunnels/tunnel" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath) IsYANGGoStruct() {}

// NewNamedExplicitPath creates a new entry in the NamedExplicitPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewNamedExplicitPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NamedExplicitPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NamedExplicitPath", key)
	}

	t.NamedExplicitPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
		Name: &Name,
	}

	return t.NamedExplicitPath[key], nil
}

// RenameNamedExplicitPath renames an entry in the list NamedExplicitPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameNamedExplicitPath(oldK, newK string) error {
	if _, ok := t.NamedExplicitPath[newK]; ok {
		return fmt.Errorf("key %v already exists in NamedExplicitPath", newK)
	}

	e, ok := t.NamedExplicitPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NamedExplicitPath", oldK)
	}
	e.Name = &newK

	t.NamedExplicitPath[newK] = e
	delete(t.NamedExplicitPath, oldK)
	return nil
}

// GetOrCreateNamedExplicitPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	key := Name

	if v, ok := t.NamedExplicitPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNamedExplicitPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNamedExplicitPath got unexpected error: %v", err))
	}
	return v
}

// GetNamedExplicitPath retrieves the value with the specified key from
// the NamedExplicitPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NamedExplicitPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteNamedExplicitPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteNamedExplicitPath(Name string) {
	key := Name

	delete(t.NamedExplicitPath, key)
}

// AppendNamedExplicitPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct to the
// list NamedExplicitPath of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendNamedExplicitPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	if _, ok := t.NamedExplicitPath[key]; ok {
		return fmt.Errorf("duplicate key for list NamedExplicitPath %v", key)
	}

	t.NamedExplicitPath[key] = v
	return nil
}

// NewTunnel creates a new entry in the Tunnel list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewTunnel(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tunnel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tunnel", key)
	}

	t.Tunnel[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{
		Name: &Name,
	}

	return t.Tunnel[key], nil
}

// RenameTunnel renames an entry in the list Tunnel within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameTunnel(oldK, newK string) error {
	if _, ok := t.Tunnel[newK]; ok {
		return fmt.Errorf("key %v already exists in Tunnel", newK)
	}

	e, ok := t.Tunnel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tunnel", oldK)
	}
	e.Name = &newK

	t.Tunnel[newK] = e
	delete(t.Tunnel, oldK)
	return nil
}

// GetOrCreateTunnel retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	key := Name

	if v, ok := t.Tunnel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnel(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnel got unexpected error: %v", err))
	}
	return v
}

// GetTunnel retrieves the value with the specified key from
// the Tunnel map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Tunnel[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnel deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteTunnel(Name string) {
	key := Name

	delete(t.Tunnel, key)
}

// AppendTunnel appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct to the
// list Tunnel of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendTunnel(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	if _, ok := t.Tunnel[key]; ok {
		return fmt.Errorf("duplicate key for list Tunnel %v", key)
	}

	t.Tunnel[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct {
	ExplicitRouteObject   map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject `path:"explicit-route-objects/explicit-route-object" module:"openconfig-network-instance/openconfig-network-instance"`
	Name                  *string                                                                                    `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	SidProtectionRequired *bool                                                                                      `path:"config/sid-protection-required" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/sid-protection-required" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SidSelectionMode      E_MplsSr_NamedExplicitPath_SidSelectionMode                                                `path:"config/sid-selection-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/sid-selection-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) IsYANGGoStruct() {}

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) NewExplicitRouteObject(Index uint8) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) RenameExplicitRouteObject(oldK, newK uint8) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetOrCreateExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteExplicitRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) DeleteExplicitRouteObject(Index uint8) {
	key := Index

	delete(t.ExplicitRouteObject, key)
}

// AppendExplicitRouteObject appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct to the
// list ExplicitRouteObject of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) AppendExplicitRouteObject(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSidProtectionRequired retrieves the value of the leaf SidProtectionRequired from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidProtectionRequired is set, it can
// safely use t.GetSidProtectionRequired() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidProtectionRequired == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetSidProtectionRequired() bool {
	if t == nil || t.SidProtectionRequired == nil {
		return false
	}
	return *t.SidProtectionRequired
}

// GetSidSelectionMode retrieves the value of the leaf SidSelectionMode from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidSelectionMode is set, it can
// safely use t.GetSidSelectionMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidSelectionMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetSidSelectionMode() E_MplsSr_NamedExplicitPath_SidSelectionMode {
	if t == nil || t.SidSelectionMode == 0 {
		return MplsSr_NamedExplicitPath_SidSelectionMode_MIXED_MODE
	}
	return t.SidSelectionMode
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct {
	Address *string            `path:"config/address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HopType E_Mpls_MplsHopType `path:"config/hop-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/hop-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Index   *uint8             `path:"config/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/index|index" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetHopType retrieves the value of the leaf HopType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopType is set, it can
// safely use t.GetHopType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetHopType() E_Mpls_MplsHopType {
	if t == nil || t.HopType == 0 {
		return 0
	}
	return t.HopType
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct {
	AdminStatus              E_MplsTypes_TUNNEL_ADMIN_STATUS                                       `path:"config/admin-status" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/admin-status" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	AutoGenerated            *bool                                                                 `path:"state/auto-generated" module:"openconfig-network-instance/openconfig-network-instance"`
	Bandwidth                *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth           `path:"bandwidth" module:"openconfig-network-instance"`
	Counters                 *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters            `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	Description              *string                                                               `path:"config/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HoldPriority             *uint8                                                                `path:"config/hold-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/hold-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Metric                   *int32                                                                `path:"config/metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MetricType               E_MplsTypes_LSP_METRIC_TYPE                                           `path:"config/metric-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/metric-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name                     *string                                                               `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"state/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	OperStatus               E_MplsTypes_LSP_OPER_STATUS                                           `path:"state/oper-status" module:"openconfig-network-instance/openconfig-network-instance"`
	P2PTunnelAttributes      *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes `path:"p2p-tunnel-attributes" module:"openconfig-network-instance"`
	Preference               *uint8                                                                `path:"config/preference" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/preference" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ProtectionStyleRequested E_MplsTypes_PROTECTION_TYPE                                           `path:"config/protection-style-requested" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/protection-style-requested" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReoptimizeTimer          *uint16                                                               `path:"config/reoptimize-timer" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/reoptimize-timer" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Role                     E_MplsTypes_LSP_ROLE                                                  `path:"state/role" module:"openconfig-network-instance/openconfig-network-instance"`
	SetupPriority            *uint8                                                                `path:"config/setup-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/setup-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ShortcutEligible         *bool                                                                 `path:"config/shortcut-eligible" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/shortcut-eligible" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SignalingProtocol        E_MplsTypes_PATH_SETUP_PROTOCOL                                       `path:"config/signaling-protocol" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/signaling-protocol" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SoftPreemption           *bool                                                                 `path:"config/soft-preemption" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/soft-preemption" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Source                   *string                                                               `path:"config/source" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/source" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Type                     E_MplsTypes_TUNNEL_TYPE                                               `path:"config/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) IsYANGGoStruct() {}

// GetOrCreateBandwidth retrieves the value of the Bandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t.Bandwidth != nil {
		return t.Bandwidth
	}
	t.Bandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	return t.Bandwidth
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	return t.Counters
}

// GetOrCreateP2PTunnelAttributes retrieves the value of the P2PTunnelAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	t.P2PTunnelAttributes = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	return t.P2PTunnelAttributes
}

// GetBandwidth returns the value of the Bandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Bandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t != nil && t.Bandwidth != nil {
		return t.Bandwidth
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetP2PTunnelAttributes returns the value of the P2PTunnelAttributes struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field P2PTunnelAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t != nil && t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetAdminStatus() E_MplsTypes_TUNNEL_ADMIN_STATUS {
	if t == nil || t.AdminStatus == 0 {
		return MplsTypes_TUNNEL_ADMIN_STATUS_ADMIN_UP
	}
	return t.AdminStatus
}

// GetAutoGenerated retrieves the value of the leaf AutoGenerated from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoGenerated is set, it can
// safely use t.GetAutoGenerated() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoGenerated == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetAutoGenerated() bool {
	if t == nil || t.AutoGenerated == nil {
		return false
	}
	return *t.AutoGenerated
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetMetric() int32 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetMetricType retrieves the value of the leaf MetricType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricType is set, it can
// safely use t.GetMetricType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetMetricType() E_MplsTypes_LSP_METRIC_TYPE {
	if t == nil || t.MetricType == 0 {
		return MplsTypes_LSP_METRIC_TYPE_LSP_METRIC_INHERITED
	}
	return t.MetricType
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOperStatus() E_MplsTypes_LSP_OPER_STATUS {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetProtectionStyleRequested retrieves the value of the leaf ProtectionStyleRequested from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectionStyleRequested is set, it can
// safely use t.GetProtectionStyleRequested() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectionStyleRequested == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetProtectionStyleRequested() E_MplsTypes_PROTECTION_TYPE {
	if t == nil || t.ProtectionStyleRequested == 0 {
		return MplsTypes_PROTECTION_TYPE_UNPROTECTED
	}
	return t.ProtectionStyleRequested
}

// GetReoptimizeTimer retrieves the value of the leaf ReoptimizeTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReoptimizeTimer is set, it can
// safely use t.GetReoptimizeTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReoptimizeTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetReoptimizeTimer() uint16 {
	if t == nil || t.ReoptimizeTimer == nil {
		return 0
	}
	return *t.ReoptimizeTimer
}

// GetRole retrieves the value of the leaf Role from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Role is set, it can
// safely use t.GetRole() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Role == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetRole() E_MplsTypes_LSP_ROLE {
	if t == nil || t.Role == 0 {
		return 0
	}
	return t.Role
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetShortcutEligible retrieves the value of the leaf ShortcutEligible from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ShortcutEligible is set, it can
// safely use t.GetShortcutEligible() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ShortcutEligible == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetShortcutEligible() bool {
	if t == nil || t.ShortcutEligible == nil {
		return true
	}
	return *t.ShortcutEligible
}

// GetSignalingProtocol retrieves the value of the leaf SignalingProtocol from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SignalingProtocol is set, it can
// safely use t.GetSignalingProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SignalingProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSignalingProtocol() E_MplsTypes_PATH_SETUP_PROTOCOL {
	if t == nil || t.SignalingProtocol == 0 {
		return 0
	}
	return t.SignalingProtocol
}

// GetSoftPreemption retrieves the value of the leaf SoftPreemption from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SoftPreemption is set, it can
// safely use t.GetSoftPreemption() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SoftPreemption == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSoftPreemption() bool {
	if t == nil || t.SoftPreemption == nil {
		return false
	}
	return *t.SoftPreemption
}

// GetSource retrieves the value of the leaf Source from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Source is set, it can
// safely use t.GetSource() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Source == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSource() string {
	if t == nil || t.Source == nil {
		return ""
	}
	return *t.Source
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetType() E_MplsTypes_TUNNEL_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth struct {
	AutoBandwidth     *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth `path:"auto-bandwidth" module:"openconfig-network-instance"`
	SetBandwidth      *uint64                                                                   `path:"config/set-bandwidth" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/set-bandwidth" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SignaledBandwidth *uint64                                                                   `path:"state/signaled-bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	SpecificationType E_Mpls_TeBandwidthType                                                    `path:"config/specification-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/specification-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) IsYANGGoStruct() {}

// GetOrCreateAutoBandwidth retrieves the value of the AutoBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetOrCreateAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if t.AutoBandwidth != nil {
		return t.AutoBandwidth
	}
	t.AutoBandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	return t.AutoBandwidth
}

// GetAutoBandwidth returns the value of the AutoBandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth. If the receiver or the field AutoBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if t != nil && t.AutoBandwidth != nil {
		return t.AutoBandwidth
	}
	return nil
}

// GetSetBandwidth retrieves the value of the leaf SetBandwidth from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetBandwidth is set, it can
// safely use t.GetSetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSetBandwidth() uint64 {
	if t == nil || t.SetBandwidth == nil {
		return 0
	}
	return *t.SetBandwidth
}

// GetSignaledBandwidth retrieves the value of the leaf SignaledBandwidth from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SignaledBandwidth is set, it can
// safely use t.GetSignaledBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SignaledBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSignaledBandwidth() uint64 {
	if t == nil || t.SignaledBandwidth == nil {
		return 0
	}
	return *t.SignaledBandwidth
}

// GetSpecificationType retrieves the value of the leaf SpecificationType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpecificationType is set, it can
// safely use t.GetSpecificationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpecificationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSpecificationType() E_Mpls_TeBandwidthType {
	if t == nil || t.SpecificationType == 0 {
		return Mpls_TeBandwidthType_SPECIFIED
	}
	return t.SpecificationType
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth struct {
	AdjustInterval  *uint32                                                                             `path:"config/adjust-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/adjust-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	AdjustThreshold *uint8                                                                              `path:"config/adjust-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/adjust-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled         *bool                                                                               `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IntervalHighBw  *uint64                                                                             `path:"state/interval-high-bw" module:"openconfig-network-instance/openconfig-network-instance"`
	MaxBw           *uint64                                                                             `path:"config/max-bw" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/max-bw" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MinBw           *uint64                                                                             `path:"config/min-bw" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/min-bw" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Overflow        *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow  `path:"overflow" module:"openconfig-network-instance"`
	Underflow       *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow `path:"underflow" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) IsYANGGoStruct() {}

// GetOrCreateOverflow retrieves the value of the Overflow field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if t.Overflow != nil {
		return t.Overflow
	}
	t.Overflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	return t.Overflow
}

// GetOrCreateUnderflow retrieves the value of the Underflow field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if t.Underflow != nil {
		return t.Underflow
	}
	t.Underflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	return t.Underflow
}

// GetOverflow returns the value of the Overflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Overflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if t != nil && t.Overflow != nil {
		return t.Overflow
	}
	return nil
}

// GetUnderflow returns the value of the Underflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Underflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if t != nil && t.Underflow != nil {
		return t.Underflow
	}
	return nil
}

// GetAdjustInterval retrieves the value of the leaf AdjustInterval from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjustInterval is set, it can
// safely use t.GetAdjustInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjustInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetAdjustInterval() uint32 {
	if t == nil || t.AdjustInterval == nil {
		return 0
	}
	return *t.AdjustInterval
}

// GetAdjustThreshold retrieves the value of the leaf AdjustThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjustThreshold is set, it can
// safely use t.GetAdjustThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjustThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetAdjustThreshold() uint8 {
	if t == nil || t.AdjustThreshold == nil {
		return 0
	}
	return *t.AdjustThreshold
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetIntervalHighBw retrieves the value of the leaf IntervalHighBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IntervalHighBw is set, it can
// safely use t.GetIntervalHighBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IntervalHighBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetIntervalHighBw() uint64 {
	if t == nil || t.IntervalHighBw == nil {
		return 0
	}
	return *t.IntervalHighBw
}

// GetMaxBw retrieves the value of the leaf MaxBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxBw is set, it can
// safely use t.GetMaxBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetMaxBw() uint64 {
	if t == nil || t.MaxBw == nil {
		return 0
	}
	return *t.MaxBw
}

// GetMinBw retrieves the value of the leaf MinBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinBw is set, it can
// safely use t.GetMinBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetMinBw() uint64 {
	if t == nil || t.MinBw == nil {
		return 0
	}
	return *t.MinBw
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow struct {
	Enabled           *bool   `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	OverflowThreshold *uint8  `path:"config/overflow-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/overflow-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TriggerEventCount *uint16 `path:"config/trigger-event-count" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/trigger-event-count" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) IsYANGGoStruct() {
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetOverflowThreshold retrieves the value of the leaf OverflowThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverflowThreshold is set, it can
// safely use t.GetOverflowThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverflowThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetOverflowThreshold() uint8 {
	if t == nil || t.OverflowThreshold == nil {
		return 0
	}
	return *t.OverflowThreshold
}

// GetTriggerEventCount retrieves the value of the leaf TriggerEventCount from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TriggerEventCount is set, it can
// safely use t.GetTriggerEventCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TriggerEventCount == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetTriggerEventCount() uint16 {
	if t == nil || t.TriggerEventCount == nil {
		return 0
	}
	return *t.TriggerEventCount
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow struct {
	Enabled            *bool   `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TriggerEventCount  *uint16 `path:"config/trigger-event-count" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/trigger-event-count" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UnderflowThreshold *uint8  `path:"config/underflow-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"state/underflow-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) IsYANGGoStruct() {
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetTriggerEventCount retrieves the value of the leaf TriggerEventCount from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TriggerEventCount is set, it can
// safely use t.GetTriggerEventCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TriggerEventCount == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetTriggerEventCount() uint16 {
	if t == nil || t.TriggerEventCount == nil {
		return 0
	}
	return *t.TriggerEventCount
}

// GetUnderflowThreshold retrieves the value of the leaf UnderflowThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnderflowThreshold is set, it can
// safely use t.GetUnderflowThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnderflowThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetUnderflowThreshold() uint8 {
	if t == nil || t.UnderflowThreshold == nil {
		return 0
	}
	return *t.UnderflowThreshold
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters struct {
	Bytes                  *uint64 `path:"bytes" module:"openconfig-network-instance"`
	CurrentPathTime        *uint64 `path:"current-path-time" module:"openconfig-network-instance"`
	NextReoptimizationTime *uint64 `path:"next-reoptimization-time" module:"openconfig-network-instance"`
	OnlineTime             *uint64 `path:"online-time" module:"openconfig-network-instance"`
	Packets                *uint64 `path:"packets" module:"openconfig-network-instance"`
	PathChanges            *uint64 `path:"path-changes" module:"openconfig-network-instance"`
	StateChanges           *uint64 `path:"state-changes" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) IsYANGGoStruct() {}

// GetBytes retrieves the value of the leaf Bytes from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bytes is set, it can
// safely use t.GetBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetBytes() uint64 {
	if t == nil || t.Bytes == nil {
		return 0
	}
	return *t.Bytes
}

// GetCurrentPathTime retrieves the value of the leaf CurrentPathTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPathTime is set, it can
// safely use t.GetCurrentPathTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPathTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetCurrentPathTime() uint64 {
	if t == nil || t.CurrentPathTime == nil {
		return 0
	}
	return *t.CurrentPathTime
}

// GetNextReoptimizationTime retrieves the value of the leaf NextReoptimizationTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextReoptimizationTime is set, it can
// safely use t.GetNextReoptimizationTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextReoptimizationTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetNextReoptimizationTime() uint64 {
	if t == nil || t.NextReoptimizationTime == nil {
		return 0
	}
	return *t.NextReoptimizationTime
}

// GetOnlineTime retrieves the value of the leaf OnlineTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OnlineTime is set, it can
// safely use t.GetOnlineTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OnlineTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetOnlineTime() uint64 {
	if t == nil || t.OnlineTime == nil {
		return 0
	}
	return *t.OnlineTime
}

// GetPackets retrieves the value of the leaf Packets from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Packets is set, it can
// safely use t.GetPackets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Packets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetPackets() uint64 {
	if t == nil || t.Packets == nil {
		return 0
	}
	return *t.Packets
}

// GetPathChanges retrieves the value of the leaf PathChanges from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathChanges is set, it can
// safely use t.GetPathChanges() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathChanges == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetPathChanges() uint64 {
	if t == nil || t.PathChanges == nil {
		return 0
	}
	return *t.PathChanges
}

// GetStateChanges retrieves the value of the leaf StateChanges from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StateChanges is set, it can
// safely use t.GetStateChanges() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StateChanges == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetStateChanges() uint64 {
	if t == nil || t.StateChanges == nil {
		return 0
	}
	return *t.StateChanges
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}
