/*
Copyright 2022 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
Package tcheck provides validation helpers for Ondatra pathstructs.

These helpers wrap the .Lookup() and .Watch()/.Await() methods of Ondatra's
pathstructs, eliminating a great deal of boilerplate and allowing table-driven
testing of paths of different types.

# Overview

This package provides functions that produce Validator objects, which represent
a check that you want to perform. A Validator can then be invoked in several
different ways to actually perform the check. Typical usage looks like this:

	// Create a table of Validators.
	  validators := []tcheck.Validator{
	      tcheck.Equal(dut.Some().Path(), someValue),
	      tcheck.Present(dut.Some().OtherPath()),
	      tcheck.NotEqual(dut.Another().Path(), anotherValue),
	  }
	  // Check each one and report any failures.
	  for _, vd:= range validators {
	      t.Run(vd.Path(), func(t *testing.T) {
	        if err := vd.Check(t); err != nil {
	              t.Error(err)
	          }
	      })
	  }

# Validator functions

The most generic validation function is

	tcheck.Validate(path, testFunc func(Value[T]) error)

When run, this Validator will use testFunc to validate the value at the
specified path, returning any resulting error.

tcheck also provides a number of shorthands for common cases:

  - tcheck.Equal(path, want) checks that the path's value is want.
  - tcheck.NotEqual(path, wantNot) checks that the path has any value other
    than wantNot.
  - tcheck.Present(path) checks that the path has any value at all.
  - tcheck.NotPresent(path) checks that the path is unset.
  - tcheck.EqualOrNil(path, want) checks that the path's value is want OR that
    the path is unset.
  - tcheck.Predicate[T](path PathStruct[T], wantMsg string, predicate func(T)
    bool) checks that the value at path is present and satisfies the given
    function.

These helpers all have prewritten testFuncs that return sensible errors of the
form "<path>: <got>, <want>" - for example,

	/system/some/path: no value, want 12
	/system/hostname: got "wrongname", want "node1" or nil

All of these validation functions (except Present/NonPresent) are generic, but
are designed to work with Ondatra's non-generic ygot-generated types. The
Predicate API differs from Ondatra's own generated Watch methods in that
instead of taking a *QualifiedFoo the given predicate takes a Value[Foo], which
has the same information but structured like a ygnmi.Value.

# Validating a Validator

Given a Validator, there are several ways to test its condition:

  - vd.Check(t) fetches the value at the specified path and tests it
    immediately, returning an error if the check fails.
  - vd.Await(t, timeout) will watch the specified path and return nil as soon
    as the check passes, or an error if the timeout expires before the check
    passes.
  - vd.AwaitUntil(t, time) behaves just like Await, but waiting until the
    specified time instead for a specific duration.

# Acommodating latency

There will often be some small latency between when a configuration variable is
set via gNMI and when the corresponding operation state reflects the change. As
a result, it's common to want to test several values with the expectation that
all of them will be correct within some short window of time. The preferred way
to do this is with AwaitUntil:

	deadline := time.Now().Add(time.Second())
	for _, vd:= range[]tcheck.Validator {
	    tcheck.Equal(dut.Some().Path(), someValue),
	    tcheck.Present(dut.Some().OtherPath()),
	    tcheck.NotEqual(dut.Another().Path(), anotherValue),
	    tcheck.Validate(dut.Yet().Another().Path(), func (v tcheck.Value[uint8]) error {
	        got, present := v.Val()
	        if !present || got%4 != 0 {
	            return tcheck.Failed(got, "want a multiple of 4")
	        }
	    })
	} {
	    t.Run(vd.Path(), func(t *testing.T) {
	        if err := vd.AwaitUntil(t, deadline); err != nil {
	            t.Error(err)
	        }
	    })
	}

The above code expects that every validation will pass within one second of the
start of the block. This differs from using vd.Await(t, time.Second) mainly in
that if the device is broken (and so every check will fail), it will still only
take one second, instead of one second per validation.

# Error Messages

The error messages generated by failing checks will include the path, the value
at that path, and a description of what the validator wanted, e.g.

	some/path: got 12, want 19

When writing custom validators, use tcheck.Failed(got Value[T], wantMsg) to
standardize the error text (and the handling of nonpresent values). For
example, tcheck.Failed(Value[int]{7, true}, "want a multiple of four") will
return an error of "got 7, want a multiple of four".
*/
package tcheck

import (
	"fmt"
	"path/filepath"
	"reflect"
	"testing"
	"time"

	"github.com/openconfig/ygot/ygot"
)

// Failed returns a sensible error message for getting this value at this path.
func Failed[T any](got Value[T], wantMsg string) error {
	val, present := got.Val()
	if !present {
		return fmt.Errorf("no value, %s", wantMsg)
	}
	return fmt.Errorf("got %#v, %s", val, wantMsg)
}

// PathStruct matches ondatra pathstructs, with generic typing information.
// The functions in this package generally expect each PathStruct[T] to have
// a Lookup(testing.TB) method which returns a QualifiedT and a
// Watch(testing.TB, time.Duration) which returns a TWatcher; we cannot
// require that through this interface because of the way Go's type system
// handles function return types, so we check it manually when needed.
type PathStruct[T any] interface {
	ygot.PathStruct
	Get(testing.TB) T
}

// Value contains a value received from a gNMI request. It is similar to an
// ondatra *QualifiedT, but with an interface matching ygnmi.Value, so that
// it doesn't rely on a testing.TB
type Value[T any] interface {
	Val() (T, bool)
	IsPresent() bool
}

// formatPath stringifies a path; on an error, it will instead return the
// string "<unprintable path: [err]>".
func formatPath(path ygot.PathStruct) string {
	protoPath, _, errs := ygot.ResolvePath(path)
	if len(errs) > 0 {
		return fmt.Sprintf("<unprintable path: %v>", errs)
	}
	pathStr, err := ygot.PathToString(protoPath)
	if err != nil {
		return fmt.Sprintf("<unprintable path: %v>", err)
	}
	return pathStr
}

// formatRelPath stringifies a path relative to another.
func formatRelPath(base, path ygot.PathStruct) string {
	baseStr := formatPath(base)
	pathStr := formatPath(path)
	relStr, err := filepath.Rel(baseStr, pathStr)
	if err != nil {
		return baseStr
	}
	return relStr
}

// Validator is an interface representing a validation operation that could
// have latency. The Await and AwaitUntil methods monitor the validation for
// some time or until some deadline, returning as soon as the validation passes
// or returning an error if the time limit is exceeded; the Check method
// evaluates the underlying check immediately, and returns an error if fails.
type Validator interface {
	Path() string
	RelPath(ygot.PathStruct) string
	Check(testing.TB) error
	Await(testing.TB, time.Duration) error
	AwaitUntil(testing.TB, time.Time) error
}

// Validation is the common implementation of Validator.
type Validation[T any] struct {
	path     PathStruct[T]
	testFunc func(Value[T]) error
}

var _ Validator = (*Validation[any])(nil)

// Path returns a string representation of this validator's path.
func (vd *Validation[T]) Path() string {
	return formatPath(vd.path)
}

// RelPath returns this validator's path relative to the given base.
func (vd *Validation[T]) RelPath(base ygot.PathStruct) string {
	return formatRelPath(base, vd.path)
}

// Check tests the validation condition immediately and returns an error if it
// fails.
func (vd *Validation[T]) Check(t testing.TB) error {
	lastVal, err := callLookup(t, vd.path)
	if err != nil {
		return err
	}
	if err := vd.testFunc(lastVal); err != nil {
		return fmt.Errorf("%v: %w", formatPath(vd.path), err)
	}
	return nil
}

// Await waits up to timeout for the validation condition to run without
// error; it returns nil as soon as the condition is met, and returns an
// error if the condition isn't met by the end of the timeout.
func (vd *Validation[T]) Await(t testing.TB, timeout time.Duration) error {
	if timeout <= 0 {
		return vd.Check(t)
	}
	var lastErr error
	predicate := func(got Value[T]) bool {
		lastErr = vd.testFunc(got)
		return lastErr == nil
	}
	w, err := callWatch(t, timeout, vd.path, predicate)
	if err != nil {
		return err
	}
	_, ok, err := callAwait(t, w)
	if err != nil { // something went wrong with the reflection around Await()
		return err
	}
	if !ok { // Await() worked, but the predicate never became true
		return fmt.Errorf("%v: %w", formatPath(vd.path), lastErr)
	}
	return nil
}

// AwaitUntil waits until deadline for the validation condition to run without
// error; it returns nil as soon as the condition is met, and returns an error
// if the condition isn't met by the deadline.
func (vd *Validation[T]) AwaitUntil(t testing.TB, deadline time.Time) error {
	return vd.Await(t, time.Until(deadline))
}

// Validate expects testFunc to return no error on the path's value.
func Validate[T any, P PathStruct[T]](path P, testFunc func(Value[T]) error) *Validation[T] {
	return &Validation[T]{path, testFunc}
}

// Predicate expects that an arbitrary predicate is true of the path's value.
// If it isn't, the wantMsg will be included in the error string, e.g. if the
// wantMsg is "want a multiple of 4", the error might read:
// "/some/path: got 13, want a multiple of 4".
func Predicate[T any, P PathStruct[T]](path P, wantMsg string, predicate func(T) bool) *Validation[T] {
	return Validate(path, func(vgot Value[T]) error {
		got, present := vgot.Val()
		if !present || !predicate(got) {
			return Failed(vgot, wantMsg)
		}
		return nil
	})
}

// Equal expects the path's value to be want.
func Equal[T any, P PathStruct[T]](path P, want T) *Validation[T] {
	return Predicate(path, fmt.Sprintf("want %#v", want), func(got T) bool {
		return reflect.DeepEqual(got, want)
	})
}

// NotEqual expects the path's value to be set to anything but wantNot.
func NotEqual[T any, P PathStruct[T]](path P, want T) *Validation[T] {
	return Predicate(path, fmt.Sprintf("want != %#v", want), func(got T) bool {
		return !reflect.DeepEqual(got, want)
	})
}

// EqualOrNil expects the path to be unset or have value want.
func EqualOrNil[T any, P PathStruct[T]](path P, want T) *Validation[T] {
	return Validate(path, func(vgot Value[T]) error {
		got, present := vgot.Val()
		if present && !reflect.DeepEqual(got, want) {
			return Failed(vgot, fmt.Sprintf("want %#v or nil", want))
		}
		return nil
	})
}

// PresentValidation is its own type because a normal Validation requires a
// type parameter, which go cannot infer just from the a pathstruct. If
// Present() were generic, calling it would require instantiation, e.g.
// Present[oc.E_IsisTypes_IsisInterfaceAdjState](t, path). By using an untyped
// Validation struct instead, we avoid having to do that.
type PresentValidation struct {
	path        ygot.PathStruct
	wantPresent bool
}

var _ Validator = (*PresentValidation)(nil)

// String returns a string representation of this validator.
func (vd *PresentValidation) String() string {
	return fmt.Sprintf("%v: want %v", vd.Path(), vd.WantMsg())
}

// Path returns a string representation of this validator's path.
func (vd *PresentValidation) Path() string {
	return formatPath(vd.path)
}

// RelPath returns this validator's path relative to the given base.
func (vd *PresentValidation) RelPath(base ygot.PathStruct) string {
	return formatRelPath(base, vd.path)
}

// WantMsg returns "want any value" or "want no value" as appropriate.
func (vd *PresentValidation) WantMsg() string {
	if vd.wantPresent {
		return "want any value"
	}
	return "want no value"
}

// Check tests the validation condition immediately and returns an error if it
// fails.
func (vd *PresentValidation) Check(t testing.TB) error {
	val, err := callLookupAny(t, vd.path)
	if err != nil {
		return err
	}
	if val.IsPresent() != vd.wantPresent {
		return fmt.Errorf("%v: %w", formatPath(vd.path), Failed(val, vd.WantMsg()))
	}
	return nil
}

// Await waits up to timeout for the validation condition to be true; it
// returns nil as soon as the condition is true, and returns an error if
// something goes wrong or if the timeout elapses.
func (vd *PresentValidation) Await(t testing.TB, timeout time.Duration) error {
	if timeout <= 0 {
		return vd.Check(t)
	}
	w, err := callWatchAny(t, timeout, vd.path, func(v Value[any]) bool {
		return v.IsPresent() == vd.wantPresent
	})
	if err != nil {
		return err
	}
	val, ok, err := callAwaitAny(t, w)
	if err != nil { // something went wrong with the reflection around Await()
		return err
	}
	if !ok { // Await() worked, but the predicate never became true
		return fmt.Errorf("%v: %w", formatPath(vd.path), Failed(val, vd.WantMsg()))
	}
	return nil
}

// AwaitUntil waits until deadline for the validation condition to run without
// error; it returns nil as soon as the condition is met, and returns an error
// if the condition isn't met by the deadline.
func (vd *PresentValidation) AwaitUntil(t testing.TB, deadline time.Time) error {
	return vd.Await(t, time.Until(deadline))
}

// Present expects a path's value to be nonempty.
func Present(path ygot.PathStruct) *PresentValidation {
	return &PresentValidation{
		path:        path,
		wantPresent: true,
	}
}

// NotPresent expects a path's value to be empty.
func NotPresent(path ygot.PathStruct) *PresentValidation {
	return &PresentValidation{
		path:        path,
		wantPresent: false,
	}
}
