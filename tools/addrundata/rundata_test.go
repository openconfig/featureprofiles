package main

import (
	"bytes"
	"fmt"
	"testing"

	"github.com/google/go-cmp/cmp"
)

var pdopt = cmp.AllowUnexported(parsedData{})

func TestParsedData_FromMarkdown(t *testing.T) {
	want := parsedData{
		testPlanID:      "XX-1.1",
		testDescription: "Foo Functional Test",
		hasData:         true,
	}

	cases := []struct {
		name, heading string
	}{
		{name: "standard", heading: "# XX-1.1: Foo Functional Test"},
		{name: "excess spaces", heading: "#  XX-1.1 : Foo Functional Test  "},
		{name: "no space", heading: "#XX-1.1:Foo Functional Test"},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			const tmpl = `%s

## Summary

## Procedure
`
			data := fmt.Sprintf(tmpl, c.heading)
			var got parsedData
			if err := got.fromMarkdown(bytes.NewReader([]byte(data))); err != nil {
				t.Fatal(err)
			}
			if diff := cmp.Diff(want, got, pdopt); diff != "" {
				t.Errorf("parsedData.fromMarkdown -want,+got:\n%s", diff)
			}
		})
	}
}

func TestParsedData_FromCode(t *testing.T) {
	want := parsedData{
		testPlanID:      "XX-1.1",
		testDescription: "Foo Functional Test",
		testUUID:        "123e4567-e89b-42d3-8456-426614174000",
		hasData:         true,
	}

	const data = `// Code generated by something; DO NOT EDIT.
package foo_functional_test

import "github.com/openconfig/featureprofiles/internal/rundata"

func init() {
	rundata.TestPlanID = "XX-1.1"
	rundata.TestDescription = "Foo Functional Test"
	rundata.TestUUID = "123e4567-e89b-42d3-8456-426614174000"
}
`
	var got parsedData
	if err := got.fromCode(bytes.NewReader([]byte(data))); err != nil {
		t.Fatal(err)
	}
	if diff := cmp.Diff(want, got, pdopt); diff != "" {
		t.Errorf("parsedData.fromCode -want,+got:\n%s", diff)
	}
}

func TestParsedData_Write(t *testing.T) {
	want := parsedData{
		testPlanID:      "XX-1.1",
		testDescription: "Foo Functional Test",
		testUUID:        "123e4567-e89b-42d3-8456-426614174000",
		hasData:         true,
	}

	buf := &bytes.Buffer{}
	if err := want.write(buf, "foo_functional_test"); err != nil {
		t.Fatalf("Cannot write: %v", err)
	}
	var got parsedData
	if err := got.fromCode(buf); err != nil {
		t.Fatalf("Cannot read back: %v", err)
	}
	if diff := cmp.Diff(want, got, pdopt); diff != "" {
		t.Errorf("parsedData.write -want,+got:\n%s", diff)
	}
}
