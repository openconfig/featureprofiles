package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
)

var tcopt = cmp.AllowUnexported(testcase{}, parsedData{})

func TestCase_Read(t *testing.T) {
	const (
		markdownText = `# XX-1.1: Description from markdown

## Summary

## Procedure
`
		metadataText = `# proto/metadata.proto
uuid: "cb772d39-4f2d-41d2-b286-bca33101d575"
plan_id: "XY-1.1"
description: "Description from proto"
`
		rundataCode = `// Code generated by go run tools/addrundata; DO NOT EDIT.
package foo_functional_test

import "github.com/openconfig/featureprofiles/internal/rundata"

func init() {
	rundata.TestPlanID = "YY-1.1"
	rundata.TestDescription = "Description from code"
	rundata.TestUUID = "123e4567-e89b-42d3-8456-426614174000"
}
`
	)

	tests := []struct {
		desc         string
		markdownText string
		metadataText string
		rundataCode  string
		want         testcase
		wantErr      string
	}{{
		desc:    "empty",
		wantErr: "no such file",
	}, {
		desc:         "bad markdown",
		markdownText: "~!@#$%^&*()_+",
		wantErr:      "not parse markdown",
	}, {
		desc:         "good markdown",
		markdownText: markdownText,
		want: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Description from markdown",
				hasData:         true,
			},
		},
	}, {
		desc:         "bad rundata",
		markdownText: markdownText,
		rundataCode:  "~!@#$%^&*()_+",
		wantErr:      "not parse rundata",
	}, {
		desc:         "good rundata",
		markdownText: markdownText,
		rundataCode:  rundataCode,
		want: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Description from markdown",
				hasData:         true,
			},
			existing: parsedData{
				testUUID:        "123e4567-e89b-42d3-8456-426614174000",
				testPlanID:      "YY-1.1",
				testDescription: "Description from code",
				hasData:         true,
			},
			deprecated: true,
		},
	}, {
		desc:         "bad metadata",
		markdownText: markdownText,
		metadataText: "~!@#$%^&*()_+",
		wantErr:      "not parse metadata",
	}, {
		desc:         "good metadata",
		markdownText: markdownText,
		metadataText: metadataText,
		want: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Description from markdown",
				hasData:         true,
			},
			existing: parsedData{
				testUUID:        "cb772d39-4f2d-41d2-b286-bca33101d575",
				testPlanID:      "XY-1.1",
				testDescription: "Description from proto",
				hasData:         true,
			},
		},
	}, {
		desc:         "good metadata and rundata",
		markdownText: markdownText,
		rundataCode:  rundataCode,
		metadataText: `uuid: "cb772d39-4f2d-41d2-b286-bca33101d575"
plan_id: "XY-1.1"`,
		want: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Description from markdown",
				hasData:         true,
			},
			existing: parsedData{
				testUUID:        "cb772d39-4f2d-41d2-b286-bca33101d575",
				testPlanID:      "XY-1.1",
				testDescription: "Description from code",
				hasData:         true,
			},
			deprecated: true,
		},
	}}

	for _, test := range tests {
		t.Run(test.desc, func(t *testing.T) {
			testdir := t.TempDir()
			for fname, fdata := range map[string]string{
				"README.md":          test.markdownText,
				"rundata_test.go":    test.rundataCode,
				"metadata.textproto": test.metadataText,
			} {
				if fdata != "" {
					if err := os.WriteFile(filepath.Join(testdir, fname), []byte(fdata), 0600); err != nil {
						t.Fatalf("Could not write %s: %v", fname, err)
					}
				}
			}

			var got testcase
			err := got.read(testdir)
			if (err == nil) != (test.wantErr == "") || (err != nil && !strings.Contains(err.Error(), test.wantErr)) {
				t.Fatalf("testcase.read got error %v, want error containing %q:", err, test.wantErr)
			}
			if err != nil {
				return
			}
			if diff := cmp.Diff(test.want, got, tcopt); diff != "" {
				t.Errorf("testcase.read -want,+got:\n%s", diff)
			}
		})
	}
}

func TestCase_Check(t *testing.T) {
	cases := []struct {
		name string
		tc   testcase
		want int
	}{{
		name: "good",
		tc: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Foo Functional Test",
				hasData:         true,
			},
			existing: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Foo Functional Test",
				testUUID:        "123e4567-e89b-42d3-8456-426614174000",
				hasData:         true,
			},
		},
		want: 0,
	}, {
		name: "allbad",
		tc: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Description from markdown",
				hasData:         true,
			},
			existing: parsedData{
				testPlanID:      "YY-1.1",
				testDescription: "Description from Test",
				testUUID:        "123e4567-e89b-12d3-a456-426614174000",
				hasData:         true,
			},
		},
		want: 3,
	}, {
		name: "noexisting",
		tc: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Foo Functional Test",
				hasData:         true,
			},
		},
		want: 3,
	}, {
		name: "nodata",
		tc:   testcase{},
		want: 2,
	}}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			errs := c.tc.check()
			t.Logf("Errors from check: %#q", errs)
			if got := len(errs); got != c.want {
				t.Errorf("Number of errors from check got %d, want %d.", got, c.want)
			}
		})
	}
}

func TestCase_CheckDeprecated(t *testing.T) {
	tc := testcase{
		markdown: parsedData{
			testPlanID:      "XX-1.1",
			testDescription: "Foo Functional Test",
			hasData:         true,
		},
		existing: parsedData{
			testPlanID:      "XX-1.1",
			testDescription: "Foo Functional Test",
			testUUID:        "123e4567-e89b-42d3-8456-426614174000",
			hasData:         true,
		},
		deprecated: true,
	}

	t.Run("true", func(t *testing.T) {
		*checkDeprecated = true
		errs := tc.check("testdir")
		t.Logf("Errors from check: %#q", errs)
		if want, got := 1, len(errs); got != want {
			t.Errorf("Check got number of errors %d, want %d.", got, want)
		}
		if len(errs) > 0 {
			err := errs[0]
			if want := "deprecated"; !strings.Contains(err.Error(), want) {
				t.Errorf("Check got error %v, want containing %q.", err, want)
			}
		}
	})

	t.Run("false", func(t *testing.T) {
		*checkDeprecated = false
		errs := tc.check("testdir")
		t.Logf("Errors from check: %#q", errs)
		if len(errs) > 0 {
			t.Errorf("Check got unexpected errors: %v", errs)
		}
	})
}

func TestCase_Fix(t *testing.T) {
	tc := testcase{
		markdown: parsedData{
			testPlanID:      "XX-1.1",
			testDescription: "Foo Functional Test",
			hasData:         true,
		},
	}
	if err := tc.fix(); err != nil {
		t.Fatal(err)
	}
	got := tc.fixed
	want := parsedData{
		testPlanID:      tc.markdown.testPlanID,
		testDescription: tc.markdown.testDescription,
		testUUID:        got.testUUID,
		hasData:         true,
	}
	if diff := cmp.Diff(want, got, tcopt); diff != "" {
		t.Errorf("fixed -want,+got:\n%s", diff)
	}
}

func TestCase_FixUUID(t *testing.T) {
	tc := testcase{
		markdown: parsedData{
			testPlanID:      "XX-1.1",
			testDescription: "Foo Functional Test",
			hasData:         true,
		},
		existing: parsedData{
			testUUID: "urn:uuid:123e4567-e89b-42d3-8456-426614174000",
		},
	}
	if err := tc.fix(); err != nil {
		t.Fatal(err)
	}
	got := tc.fixed
	want := parsedData{
		testPlanID:      tc.markdown.testPlanID,
		testDescription: tc.markdown.testDescription,
		testUUID:        "123e4567-e89b-42d3-8456-426614174000",
		hasData:         true,
	}
	if diff := cmp.Diff(want, got, tcopt); diff != "" {
		t.Errorf("fixed -want,+got:\n%s", diff)
	}
}

func TestCase_Write(t *testing.T) {
	var want, got testcase

	// Prepare a testdir with just README.md
	testdir := t.TempDir()
	const markdown = `# XX-1.1: Foo Functional Test

## Summary

## Procedure
`
	if err := os.WriteFile(filepath.Join(testdir, "README.md"), []byte(markdown), 0600); err != nil {
		t.Fatal(err)
	}

	// Read, fix, and write.
	if err := want.read(testdir); err != nil {
		t.Fatal(err)
	}
	if err := want.fix(); err != nil {
		t.Fatal(err)
	}
	if err := want.write(testdir); err != nil {
		t.Fatal(err)
	}

	// Read it back to ensure we got the same data.
	if err := got.read(testdir); err != nil {
		t.Fatal(err)
	}
	if diff := cmp.Diff(want.fixed, got.existing, tcopt); diff != "" {
		t.Errorf("Write then read output differs -want,+got:\n%s", diff)
	}
}
