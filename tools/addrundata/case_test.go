package main

import (
	"errors"
	"os"
	"path/filepath"
	"testing"

	"github.com/google/go-cmp/cmp"
)

var tcopt = cmp.AllowUnexported(testcase{}, parsedData{})

func TestCase_Read(t *testing.T) {
	const (
		markDown = `# XX-1.1: Description from Markdown

## Summary

## Procedure
`
		testMain = `// License text line 1.
// License text line 2.

package foo_functional_test

import (
	"testing"

	"github.com/openconfig/featureprofiles/internal/fptest"
)

func TestMain(m *testing.M) {
	fptest.RunTests(m)
}
`
		genCode = `// Code generated by go run tools/addrundata; DO NOT EDIT.
package foo_functional_test

import "github.com/openconfig/featureprofiles/internal/rundata"

func init() {
	rundata.TestPlanID = "YY-1.1"
	rundata.TestDescription = "Description from Test"
	rundata.TestUUID = "123e4567-e89b-42d3-8456-426614174000"
}
`
	)

	testdir := t.TempDir()
	for fname, fdata := range map[string]string{
		"README.md":       markDown,
		"foo_test.go":     testMain,
		"rundata_test.go": genCode,
	} {
		if err := os.WriteFile(filepath.Join(testdir, fname), []byte(fdata), 0600); err != nil {
			t.Fatalf("Could not write %s: %v", fname, err)
		}
	}

	var got testcase
	if err := got.read(testdir); err != nil {
		t.Fatal("Unexpected error:", err)
	}

	want := testcase{
		pkg: "foo_functional_test",
		markdown: parsedData{
			testPlanID:      "XX-1.1",
			testDescription: "Description from Markdown",
			hasData:         true,
		},
		existing: parsedData{
			testPlanID:      "YY-1.1",
			testDescription: "Description from Test",
			testUUID:        "123e4567-e89b-42d3-8456-426614174000",
			hasData:         true,
		},
	}

	if diff := cmp.Diff(want, got, tcopt); diff != "" {
		t.Errorf("testcase.read -want,+got:\n%s", diff)
	}
}

func TestCase_ReadEmpty(t *testing.T) {
	testdir := t.TempDir()

	var got testcase
	if err := got.read(testdir); !errors.Is(err, os.ErrNotExist) {
		t.Fatal("Unexpected error:", err)
	} else {
		t.Log("Expected error:", err)
	}

	want := testcase{}

	if diff := cmp.Diff(want, got, tcopt); diff != "" {
		t.Errorf("testcase.read -want,+got:\n%s", diff)
	}
}

func TestCase_Check(t *testing.T) {
	cases := []struct {
		name string
		tc   testcase
		want int
	}{{
		name: "good",
		tc: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Foo Functional Test",
				hasData:         true,
			},
			existing: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Foo Functional Test",
				testUUID:        "123e4567-e89b-42d3-8456-426614174000",
				hasData:         true,
			},
		},
		want: 0,
	}, {
		name: "allbad",
		tc: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Description from Markdown",
				hasData:         true,
			},
			existing: parsedData{
				testPlanID:      "YY-1.1",
				testDescription: "Description from Test",
				testUUID:        "123e4567-e89b-12d3-a456-426614174000",
				hasData:         true,
			},
		},
		want: 3,
	}, {
		name: "noexisting",
		tc: testcase{
			markdown: parsedData{
				testPlanID:      "XX-1.1",
				testDescription: "Foo Functional Test",
				hasData:         true,
			},
		},
		want: 3,
	}, {
		name: "nodata",
		tc:   testcase{},
		want: 2,
	}}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			errs := c.tc.check("testdir")
			t.Logf("Errors from check: %#q", errs)
			if got := len(errs); got != c.want {
				t.Errorf("Number of errors from check got %d, want %d.", got, c.want)
			}
		})
	}
}

func TestCase_Fix(t *testing.T) {
	tc := testcase{
		markdown: parsedData{
			testPlanID:      "XX-1.1",
			testDescription: "Foo Functional Test",
			hasData:         true,
		},
	}
	if err := tc.fix(); err != nil {
		t.Fatal(err)
	}
	got := tc.fixed
	want := parsedData{
		testPlanID:      tc.markdown.testPlanID,
		testDescription: tc.markdown.testDescription,
		testUUID:        got.testUUID,
		hasData:         true,
	}
	if diff := cmp.Diff(want, got, tcopt); diff != "" {
		t.Errorf("fixed -want,+got:\n%s", diff)
	}
}

func TestCase_FixUUID(t *testing.T) {
	tc := testcase{
		markdown: parsedData{
			testPlanID:      "XX-1.1",
			testDescription: "Foo Functional Test",
			hasData:         true,
		},
		existing: parsedData{
			testUUID: "urn:uuid:123e4567-e89b-42d3-8456-426614174000",
		},
	}
	if err := tc.fix(); err != nil {
		t.Fatal(err)
	}
	got := tc.fixed
	want := parsedData{
		testPlanID:      tc.markdown.testPlanID,
		testDescription: tc.markdown.testDescription,
		testUUID:        "123e4567-e89b-42d3-8456-426614174000",
		hasData:         true,
	}
	if diff := cmp.Diff(want, got, tcopt); diff != "" {
		t.Errorf("fixed -want,+got:\n%s", diff)
	}
}

func TestCase_Write(t *testing.T) {
	var want, got testcase

	// Prepare a testdir with just README.md
	testdir := t.TempDir()
	const markdown = `# XX-1.1: Foo Functional Test

## Summary

## Procedure
`
	if err := os.WriteFile(filepath.Join(testdir, "README.md"), []byte(markdown), 0600); err != nil {
		t.Fatal(err)
	}

	// Read, fix, and write.
	if err := want.read(testdir); err != nil {
		t.Fatal(err)
	}
	if err := want.fix(); err != nil {
		t.Fatal(err)
	}
	want.pkg = "foo_functional_test"
	if err := want.write(testdir); err != nil {
		t.Fatal(err)
	}

	// Read it back to ensure we got the same data.
	if err := got.read(testdir); err != nil {
		t.Fatal(err)
	}
	if diff := cmp.Diff(want.fixed, got.existing, tcopt); diff != "" {
		t.Errorf("Write then read output differs -want,+got:\n%s", diff)
	}
}
