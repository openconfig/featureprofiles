package isis_scale_multi_adjacency_test

import (
	"net"
	"strconv"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/openconfig/featureprofiles/internal/cfgplugins"
	"github.com/openconfig/featureprofiles/internal/deviations"
	"github.com/openconfig/featureprofiles/internal/fptest"
	isisscalehelpers "github.com/openconfig/featureprofiles/internal/isisscale"
	otgconfighelpers "github.com/openconfig/featureprofiles/internal/otg_helpers/otg_config_helpers"
	"github.com/openconfig/ondatra/gnmi/oc"
)

type descriptor struct {
	name           string
	dimension      []int
	linkMultiplier int
	blockCount     int
}

func TestMain(m *testing.M) {
	fptest.RunTests(m)
}

func createATEISISBlocks(blocksDescriptors []descriptor) map[string]*otgconfighelpers.ISISOTGBlock {
	isisBlocks := make(map[string]*otgconfighelpers.ISISOTGBlock)
	firstOctet := 20

	for _, b := range blocksDescriptors {
		for i := 1; i <= b.blockCount; i++ {
			block := otgconfighelpers.ISISOTGBlock{
				Name:            b.name + "_" + strconv.Itoa(i),
				Col:             b.dimension[0],
				Row:             b.dimension[1],
				ISISIDFirstOct:  strconv.Itoa(firstOctet),
				LinkIP4FirstOct: firstOctet + 1,
				V6Pfx:           otgconfighelpers.Pfx{FirstOctet: strconv.Itoa(firstOctet + 2), PfxLen: 64, Count: 2},
				LinkMultiplier:  b.linkMultiplier,
			}
			if !strings.Contains(b.name, "RoutersTypeA") {
				block.V4Pfx = otgconfighelpers.Pfx{FirstOctet: strconv.Itoa(firstOctet + 2), PfxLen: 26, Count: 4}
			}
			isisBlocks[block.Name] = &block
			firstOctet += 3
		}
	}
	return isisBlocks
}

func initializeMultiAdjISISScaleTestData(t *testing.T) *isisscalehelpers.TestData {
	t.Helper()
	blocksDescriptors := []descriptor{
		{
			name:           "RoutersTypeA",
			dimension:      []int{20, 20},
			linkMultiplier: 2,
			blockCount:     4,
		},
		{
			name:           "RoutersTypeB",
			dimension:      []int{12, 12},
			linkMultiplier: 17,
			blockCount:     4,
		},
		{
			name:           "RoutersTypeC",
			dimension:      []int{16, 16},
			linkMultiplier: 17,
			blockCount:     4,
		},
		{
			name:           "Dynamic",
			dimension:      []int{12, 12},
			linkMultiplier: 4,
			blockCount:     1,
		},
	}
	aggregateCount := 8
	subInterfacesCountPerAggregate := 12
	initialVlanID := 1000
	initialIPv4Address := net.ParseIP("192.0.0.1")
	initialIPv6Address := net.ParseIP("2001:db8::1")

	// Create DUT data.
	dutData := &isisscalehelpers.DutData{
		Lags: isisscalehelpers.CreateDUTAggregateInterfacesData(t, aggregateCount, subInterfacesCountPerAggregate, initialVlanID, initialIPv4Address, initialIPv6Address),
		IsisData: &cfgplugins.ISISGlobalParams{
			DUTArea:  "49.0001",
			DUTSysID: "1920.0000.2001",
		},
	}

	// Create ATE data.
	ateEmulatedRouterData := isisscalehelpers.CreateATEEmulatedRouterData(t, dutData.Lags)
	lagToErouterMap := make(map[int][]*otgconfighelpers.AteEmulatedRouterData)
	for i := 0; i < aggregateCount; i++ {
		lagToErouterMap[i] = ateEmulatedRouterData[i*subInterfacesCountPerAggregate : (i+1)*subInterfacesCountPerAggregate]
	}
	ateData := isisscalehelpers.CreateATEData(lagToErouterMap)

	// Create ISIS blocks for ATE routers.
	isisOTGBlocks := createATEISISBlocks(blocksDescriptors)
	// Add ISIS blocks to the ATE routers
	blockIndex := 0
	for _, b := range blocksDescriptors {
		for i := 1; i <= b.blockCount; i++ {
			blockName := b.name + "_" + strconv.Itoa(i)
			if block, ok := isisOTGBlocks[blockName]; ok {
				ateData.Lags[blockIndex%aggregateCount].Erouters[0].ISISBlocks = append(ateData.Lags[blockIndex%aggregateCount].Erouters[0].ISISBlocks, block)
				blockIndex++
			} else {
				t.Fatalf("isis block %v not found in the ISISOTGBlocks map", blockName)
			}
		}
	}

	ateData.ConfigureISIS = true
	ateData.TrafficFlowsMap = make(map[*otgconfighelpers.AteEmulatedRouterData][]*otgconfighelpers.AteEmulatedRouterData)
	// Create traffic flows for the ATE routers.
	for i := 0; i < aggregateCount; i++ {
		for j := 0; j < aggregateCount; j++ {
			if i == j {
				continue
			}
			ateData.TrafficFlowsMap[ateData.Lags[i].Erouters[0]] = append(ateData.TrafficFlowsMap[ateData.Lags[i].Erouters[0]], ateData.Lags[j].Erouters[0])
		}
	}

	// Count of LSP geenrated by RouterTypeA = 400
	// Count of LSP generated by RouterTypeB = 672
	// Count of LSP generated by RouterTypeC = 1216
	// Count of LSP generated by Dynamic = 244
	// Total Count of LSPs = 4*(400 + 672 + 1216) + 244 = 9396
	// Count of IPv4 and IPv6 are calculated in the below function calculateRoutesCount based on the ISIS blocks created for ATE routers.
	// Test is hardcoded for IPV4 and IPv6 prefix count of 68048 and 6680 respectively to confirm test will fail if count or dimension of ISIS blocks are changed.
	correctLSPCount := 9396
	correctIPRouteCount := map[oc.E_Types_ADDRESS_FAMILY]int{oc.Types_ADDRESS_FAMILY_IPV4: 68048, oc.Types_ADDRESS_FAMILY_IPV6: 6680}
	correctISISAdjCount := aggregateCount * subInterfacesCountPerAggregate

	ipv4PrefixTotal := 0
	ipv6PrefixTotal := 0
	for _, l := range ateData.Lags {
		for _, r := range l.Erouters {
			for _, b := range r.ISISBlocks {
				ipv4PrefixTotal += isisscalehelpers.CalculateRoutesCount(b, "ipv4")
				ipv6PrefixTotal += isisscalehelpers.CalculateRoutesCount(b, "ipv6")
			}
		}
	}
	t.Logf("The IXIA toplogy should create %v IPv4 routes and %v IPv6 routes \ntest will fail if the IPv4 routes was less than %v or IPv6 routes was less than %v", ipv4PrefixTotal, ipv6PrefixTotal, correctIPRouteCount[oc.Types_ADDRESS_FAMILY_IPV4], correctIPRouteCount[oc.Types_ADDRESS_FAMILY_IPV6])

	return &isisscalehelpers.TestData{
		Name:                     "MultiAdjISISScale",
		DUTData:                  dutData,
		ATEData:                  ateData,
		CorrectLSPCount:          correctLSPCount,
		CorrectAggInterfaceCount: aggregateCount,
		CorrectISISAdjCount:      correctISISAdjCount,
		CorrectIPRouteCount:      correctIPRouteCount,
	}
}

func TestISISScale(t *testing.T) {
	for _, f := range []func(*testing.T) *isisscalehelpers.TestData{
		initializeMultiAdjISISScaleTestData,
	} {
		testInfo := f(t)
		t.Run(testInfo.Name, func(t *testing.T) {
			dut := isisscalehelpers.SetupTest(t, testInfo)
			var count int
			var ok bool
			t.Logf("===========Conducting pre-test checks===========")
			// Check Aggregate on DUT are UP
			count, ok = isisscalehelpers.CheckIntsOpState(t, dut, 2*time.Minute)
			switch {
			case ok && count == testInfo.CorrectAggInterfaceCount:
				t.Logf("Check passed: All interfaces participating in ISIS are operationally up  need %v up interfaces got %v", testInfo.CorrectAggInterfaceCount, count)
			default:
				t.Fatalf("check failed: not all interfaces participating in ISIS are operationally up  need %v up interfaces got %v", testInfo.CorrectAggInterfaceCount, count)
			}

			// Check ISIS Adjacency
			if deviations.ISISAdjacencyStreamUnsupported(dut) {
				count, ok = isisscalehelpers.FindISISAdjCountNonStream(t, dut, 2*time.Minute, testInfo.CorrectISISAdjCount)
			} else {
				count, ok = isisscalehelpers.FindISISAdjCount(t, dut, 2*time.Minute, testInfo.CorrectISISAdjCount)
			}
			switch {
			case !ok:
				t.Fatalf("check failed: not all isis adjacencies are up need %v up adjacencies got %v", testInfo.CorrectISISAdjCount, count)
			case count == testInfo.CorrectISISAdjCount:
				t.Logf("Check passed: All ISIS adjacencies are up  need %v up adjacencies got %v", testInfo.CorrectISISAdjCount, count)
			case count > testInfo.CorrectISISAdjCount:
				t.Errorf("ISIS adjacencies are more than expected  need %v up adjacencies got %v", testInfo.CorrectISISAdjCount, count)
			default:
				t.Fatalf("check failed: not all ISIS adjacencies are up : need %v up adjacencies got %v", testInfo.CorrectISISAdjCount, count)
			}

			t.Logf("===========Sleep for 5 minutes to check DUT stabilty===========")
			// Test will not check any metrics for 5 minutes to make sure DUT is stable.
			time.Sleep(5 * 60 * time.Second)
			t.Run("LSP_Count", func(t *testing.T) {
				// Check LSP Count
				if deviations.ISISLSPTlvsOCUnsupported(dut) {
					count, ok = isisscalehelpers.FindISISLSPCount(t, dut, 3*time.Minute, testInfo.CorrectLSPCount)
				} else {
					count, ok = isisscalehelpers.FindISISActiveLSPCount(t, dut, 3*time.Minute, testInfo.CorrectLSPCount)
				}
				if ok {
					t.Logf("Check passed: correct ISIS LSP count need %v lsps got %v", testInfo.CorrectLSPCount, count)
				} else {
					t.Errorf("check failed: incorrect isis lsp count need %v lsps got %v", testInfo.CorrectLSPCount, count)
				}
			})

			t.Run("Route_Count", func(t *testing.T) {
				var wg sync.WaitGroup
				for _, f := range []oc.E_Types_ADDRESS_FAMILY{oc.Types_ADDRESS_FAMILY_IPV4, oc.Types_ADDRESS_FAMILY_IPV6} {
					wg.Add(1)
					family := f
					go func() {
						defer wg.Done()
						if deviations.AFTSummaryOCUnsupported(dut) {
							count, ok := isisscalehelpers.FindProtocolRouteCount(t, dut, family, oc.PolicyTypes_INSTALL_PROTOCOL_TYPE_ISIS, 1*time.Minute, testInfo.CorrectIPRouteCount[family])
							if !ok {
								t.Errorf("check failed: incorrect %s route count need %v routes got %v", family.String(), testInfo.CorrectIPRouteCount[family], count)
								return
							}
							t.Logf("Check passed: correct %s route count need %v routes got %v", family.String(), testInfo.CorrectIPRouteCount[family], count)
						} else {
							count := isisscalehelpers.FindProtocolSummaryRouteCount(t, dut, family, oc.PolicyTypes_INSTALL_PROTOCOL_TYPE_ISIS, 1*time.Minute, testInfo.CorrectIPRouteCount[family])
							if count >= testInfo.CorrectIPRouteCount[family] {
								t.Logf("Check passed: correct route count for the family %s need %v routes got %v", family.String(), testInfo.CorrectIPRouteCount[family], count)
							} else {
								t.Errorf("check failed: incorrect route count for the family %s need %v routes got %v", family.String(), testInfo.CorrectIPRouteCount[family], count)
							}
						}
					}()
				}
				wg.Wait()
			})

			t.Run("Traffic_Loss", func(t *testing.T) {
				// Start and stop traffic
				testInfo.ATEData.ATE.OTG().StartTraffic(t)
				time.Sleep(60 * time.Second)
				testInfo.ATEData.ATE.OTG().StopTraffic(t)
				// Check Traffic Loss
				errs := isisscalehelpers.CheckTraffic(t, testInfo.ATEData.ATE, testInfo.ATEData.TrafficFlows)
				if len(errs) > 0 {
					for _, err := range errs {
						t.Errorf("%v", err.Error())
					}
				} else {
					t.Logf("Check passed: no traffic loss found for the flows")
				}
			})
		})
	}
}
